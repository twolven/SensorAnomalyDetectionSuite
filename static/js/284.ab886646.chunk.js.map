{"version":3,"file":"static/js/284.ab886646.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/common/lib/backend-impl.ts","../node_modules/common/lib/backend.ts","../node_modules/common/lib/version.ts","../node_modules/common/lib/env-impl.ts","../node_modules/common/lib/env.ts","../node_modules/common/lib/tensor-conversion-impl.ts","../node_modules/common/lib/tensor-factory-impl.ts","../node_modules/common/lib/tensor-impl-type-mapping.ts","../node_modules/common/lib/tensor-utils-impl.ts","../node_modules/common/lib/tensor-impl.ts","../node_modules/common/lib/tensor.ts","../node_modules/common/lib/trace.ts","../node_modules/common/lib/inference-session-impl.ts","../node_modules/common/lib/inference-session.ts","../node_modules/common/lib/tensor-conversion.ts","../node_modules/common/lib/tensor-factory.ts","../node_modules/common/lib/onnx-model.ts","../node_modules/common/lib/onnx-value.ts","../node_modules/common/lib/training-session-impl.ts","../node_modules/common/lib/training-session.ts","../node_modules/common/lib/index.ts","../node_modules/onnxruntime-web/lib/onnxjs/instrument.ts","../node_modules/onnxruntime-web/lib/onnxjs/opset.ts","../node_modules/onnxruntime-web/node_modules/guid-typescript/dist/guid.js","../node_modules/onnxruntime-web/node_modules/long/index.js","../node_modules/onnxruntime-web/node_modules/flatbuffers/js/flatbuffers.mjs","../node_modules/onnxruntime-web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts","../node_modules/onnxruntime-web/node_modules/@protobufjs/aspromise/index.js","../node_modules/onnxruntime-web/node_modules/@protobufjs/base64/index.js","../node_modules/onnxruntime-web/node_modules/@protobufjs/eventemitter/index.js","../node_modules/onnxruntime-web/node_modules/@protobufjs/float/index.js","../node_modules/onnxruntime-web/node_modules/@protobufjs/inquire/index.js","../node_modules/onnxruntime-web/node_modules/@protobufjs/utf8/index.js","../node_modules/onnxruntime-web/node_modules/@protobufjs/pool/index.js","../node_modules/onnxruntime-web/node_modules/protobufjs/src/util/longbits.js","../node_modules/onnxruntime-web/node_modules/protobufjs/src/util/minimal.js","../node_modules/onnxruntime-web/node_modules/protobufjs/src/writer.js","../node_modules/onnxruntime-web/node_modules/protobufjs/src/writer_buffer.js","../node_modules/onnxruntime-web/node_modules/protobufjs/src/reader.js","../node_modules/onnxruntime-web/node_modules/protobufjs/src/reader_buffer.js","../node_modules/onnxruntime-web/node_modules/protobufjs/src/rpc/service.js","../node_modules/onnxruntime-web/node_modules/protobufjs/src/rpc.js","../node_modules/onnxruntime-web/node_modules/protobufjs/src/roots.js","../node_modules/onnxruntime-web/node_modules/protobufjs/src/index-minimal.js","../node_modules/onnxruntime-web/node_modules/protobufjs/minimal.js","../node_modules/onnxruntime-web/lib/onnxjs/ort-schema/protobuf/onnx.js","../node_modules/onnxruntime-web/lib/onnxjs/util.ts","../node_modules/onnxruntime-web/lib/onnxjs/tensor.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-source.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/types.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/utils.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/packing-utils.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/pack.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/unpack.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/texture-data-encoder.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/texture-layout.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/inference-handler.ts","../node_modules/onnxruntime-web/lib/onnxjs/attribute-with-cache-key.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-definitions.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/binary-op.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/cast.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/concat-packed.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/concat.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/unary-op.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/matmul.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv-pack.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/im2col.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/dot-product.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/transpose.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/flatten.ts","../node_modules/onnxruntime-web/lib/onnxjs/operators.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/gather.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/gemm.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/image-scaler.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/lrn.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/pad.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/pool.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/reduce.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/reshape.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/upsample.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/resize-packed.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/shape.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/slice.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/softmax.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/split.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/squeeze.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/sum.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/tile.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/op-resolve-rules.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/program-manager.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/texture-manager.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/session-handler.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/webgl-context.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/webgl/webgl-context-factory.ts","../node_modules/onnxruntime-web/lib/onnxjs/backends/backend-webgl.ts","../node_modules/onnxruntime-web/lib/onnxjs/backend.ts","../node_modules/onnxruntime-web/lib/onnxjs/execution-plan.ts","../node_modules/onnxruntime-web/lib/onnxjs/attribute.ts","../node_modules/onnxruntime-web/lib/onnxjs/graph.ts","../node_modules/onnxruntime-web/lib/onnxjs/model.ts","../node_modules/onnxruntime-web/lib/onnxjs/session.ts","../node_modules/onnxruntime-web/lib/onnxjs/session-handler-inference.ts","../node_modules/onnxruntime-web/lib/backend-onnxjs.ts","../node_modules/onnxruntime-web/lib/wasm/wasm-utils-env.ts","../node_modules/onnxruntime-web/lib/wasm/proxy-worker/main.ts","../node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.mjs","../node_modules/onnxruntime-web/lib/wasm/wasm-utils-import.ts","../node_modules/onnxruntime-web/lib/wasm/wasm-factory.ts","../node_modules/onnxruntime-web/lib/wasm/wasm-utils.ts","../node_modules/onnxruntime-web/lib/wasm/run-options.ts","../node_modules/onnxruntime-web/lib/wasm/session-options.ts","../node_modules/onnxruntime-web/lib/wasm/wasm-common.ts","../node_modules/onnxruntime-web/lib/wasm/wasm-utils-load-file.ts","../node_modules/onnxruntime-web/lib/wasm/wasm-core-impl.ts","../node_modules/onnxruntime-web/lib/wasm/proxy-wrapper.ts","../node_modules/onnxruntime-web/lib/wasm/session-handler-inference.ts","../node_modules/onnxruntime-web/lib/backend-wasm.ts","../node_modules/onnxruntime-web/lib/index.ts","../node_modules/onnxruntime-web/lib/version.ts"],"sourcesContent":["import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nexport { _objectSpread2 as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Backend } from './backend.js';\nimport { InferenceSession } from './inference-session.js';\n\ninterface BackendInfo {\n  backend: Backend;\n  priority: number;\n\n  initPromise?: Promise<void>;\n  initialized?: boolean;\n  aborted?: boolean;\n  error?: string;\n}\n\nconst backends: Map<string, BackendInfo> = new Map();\nconst backendsSortedByPriority: string[] = [];\n\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @ignore\n */\nexport const registerBackend = (name: string, backend: Backend, priority: number): void => {\n  if (backend && typeof backend.init === 'function' && typeof backend.createInferenceSessionHandler === 'function') {\n    const currentBackend = backends.get(name);\n    if (currentBackend === undefined) {\n      backends.set(name, { backend, priority });\n    } else if (currentBackend.priority > priority) {\n      // same name is already registered with a higher priority. skip registeration.\n      return;\n    } else if (currentBackend.priority === priority) {\n      if (currentBackend.backend !== backend) {\n        throw new Error(`cannot register backend \"${name}\" using priority ${priority}`);\n      }\n    }\n\n    if (priority >= 0) {\n      const i = backendsSortedByPriority.indexOf(name);\n      if (i !== -1) {\n        backendsSortedByPriority.splice(i, 1);\n      }\n\n      for (let i = 0; i < backendsSortedByPriority.length; i++) {\n        if (backends.get(backendsSortedByPriority[i])!.priority <= priority) {\n          backendsSortedByPriority.splice(i, 0, name);\n          return;\n        }\n      }\n      backendsSortedByPriority.push(name);\n    }\n    return;\n  }\n\n  throw new TypeError('not a valid backend');\n};\n\n/**\n * Try to resolve and initialize a backend.\n *\n * @param backendName - the name of the backend.\n * @returns the backend instance if resolved and initialized successfully, or an error message if failed.\n */\nconst tryResolveAndInitializeBackend = async (backendName: string): Promise<Backend | string> => {\n  const backendInfo = backends.get(backendName);\n  if (!backendInfo) {\n    return 'backend not found.';\n  }\n\n  if (backendInfo.initialized) {\n    return backendInfo.backend;\n  } else if (backendInfo.aborted) {\n    return backendInfo.error!;\n  } else {\n    const isInitializing = !!backendInfo.initPromise;\n    try {\n      if (!isInitializing) {\n        backendInfo.initPromise = backendInfo.backend.init(backendName);\n      }\n      await backendInfo.initPromise;\n      backendInfo.initialized = true;\n      return backendInfo.backend;\n    } catch (e) {\n      if (!isInitializing) {\n        backendInfo.error = `${e}`;\n        backendInfo.aborted = true;\n      }\n      return backendInfo.error!;\n    } finally {\n      delete backendInfo.initPromise;\n    }\n  }\n};\n\n/**\n * Resolve execution providers from the specific session options.\n *\n * @param options - the session options object.\n * @returns a promise that resolves to a tuple of an initialized backend instance and a session options object with\n * filtered EP list.\n *\n * @ignore\n */\nexport const resolveBackendAndExecutionProviders = async (\n  options: InferenceSession.SessionOptions,\n): Promise<[backend: Backend, options: InferenceSession.SessionOptions]> => {\n  // extract backend hints from session options\n  const eps = options.executionProviders || [];\n  const backendHints = eps.map((i) => (typeof i === 'string' ? i : i.name));\n  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n\n  // try to resolve and initialize all requested backends\n  let backend: Backend | undefined;\n  const errors = [];\n  const availableBackendNames = new Set<string>();\n  for (const backendName of backendNames) {\n    const resolveResult = await tryResolveAndInitializeBackend(backendName);\n    if (typeof resolveResult === 'string') {\n      errors.push({ name: backendName, err: resolveResult });\n    } else {\n      if (!backend) {\n        backend = resolveResult;\n      }\n      if (backend === resolveResult) {\n        availableBackendNames.add(backendName);\n      }\n    }\n  }\n\n  // if no backend is available, throw error.\n  if (!backend) {\n    throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(', ')}`);\n  }\n\n  // for each explicitly requested backend, if it's not available, output warning message.\n  for (const { name, err } of errors) {\n    if (backendHints.includes(name)) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `removing requested execution provider \"${name}\" from session options because it is not available: ${err}`,\n      );\n    }\n  }\n\n  const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === 'string' ? i : i.name));\n\n  return [\n    backend,\n    new Proxy(options, {\n      get: (target, prop) => {\n        if (prop === 'executionProviders') {\n          return filteredEps;\n        }\n        return Reflect.get(target, prop);\n      },\n    }),\n  ];\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession } from './inference-session.js';\nimport { OnnxValue } from './onnx-value.js';\nimport { TrainingSession } from './training-session.js';\n\n/**\n * @ignore\n */\nexport declare namespace SessionHandler {\n  type FeedsType = { [name: string]: OnnxValue };\n  type FetchesType = { [name: string]: OnnxValue | null };\n  type ReturnType = { [name: string]: OnnxValue };\n}\n\n/**\n * Represents shared SessionHandler functionality\n *\n * @ignore\n */\ninterface SessionHandler {\n  dispose(): Promise<void>;\n\n  readonly inputNames: readonly string[];\n  readonly outputNames: readonly string[];\n}\n\n/**\n * Represent a handler instance of an inference session.\n *\n * @ignore\n */\nexport interface InferenceSessionHandler extends SessionHandler {\n  startProfiling(): void;\n  endProfiling(): void;\n\n  run(\n    feeds: SessionHandler.FeedsType,\n    fetches: SessionHandler.FetchesType,\n    options: InferenceSession.RunOptions,\n  ): Promise<SessionHandler.ReturnType>;\n}\n\n/**\n * Represent a handler instance of a training inference session.\n *\n * @ignore\n */\nexport interface TrainingSessionHandler extends SessionHandler {\n  readonly evalInputNames: readonly string[];\n  readonly evalOutputNames: readonly string[];\n\n  lazyResetGrad(): Promise<void>;\n  runTrainStep(\n    feeds: SessionHandler.FeedsType,\n    fetches: SessionHandler.FetchesType,\n    options: InferenceSession.RunOptions,\n  ): Promise<SessionHandler.ReturnType>;\n  runOptimizerStep(options: InferenceSession.RunOptions): Promise<void>;\n  runEvalStep(\n    feeds: SessionHandler.FeedsType,\n    fetches: SessionHandler.FetchesType,\n    options: InferenceSession.RunOptions,\n  ): Promise<SessionHandler.ReturnType>;\n\n  getParametersSize(trainableOnly: boolean): Promise<number>;\n  loadParametersBuffer(buffer: Uint8Array, trainableOnly: boolean): Promise<void>;\n  getContiguousParameters(trainableOnly: boolean): Promise<OnnxValue>;\n}\n\n/**\n * Represent a backend that provides implementation of model inferencing.\n *\n * @ignore\n */\nexport interface Backend {\n  /**\n   * Initialize the backend asynchronously. Should throw when failed.\n   */\n  init(backendName: string): Promise<void>;\n\n  createInferenceSessionHandler(\n    uriOrBuffer: string | Uint8Array,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSessionHandler>;\n\n  createTrainingSessionHandler?(\n    checkpointStateUriOrBuffer: TrainingSession.UriOrBuffer,\n    trainModelUriOrBuffer: TrainingSession.UriOrBuffer,\n    evalModelUriOrBuffer: TrainingSession.UriOrBuffer,\n    optimizerModelUriOrBuffer: TrainingSession.UriOrBuffer,\n    options: InferenceSession.SessionOptions,\n  ): Promise<TrainingSessionHandler>;\n}\n\nexport { registerBackend } from './backend-impl.js';\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// This file is generated by /js/scripts/update-version.ts\n// Do not modify file content manually.\n\nexport const version = '1.20.1';\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Env } from './env.js';\nimport { version } from './version.js';\n\ntype LogLevelType = Env['logLevel'];\n\nlet logLevelValue: Required<LogLevelType> = 'warning';\n\nexport const env: Env = {\n  wasm: {} as Env.WebAssemblyFlags,\n  webgl: {} as Env.WebGLFlags,\n  webgpu: {} as Env.WebGpuFlags,\n  versions: { common: version },\n\n  set logLevel(value: LogLevelType) {\n    if (value === undefined) {\n      return;\n    }\n    if (typeof value !== 'string' || ['verbose', 'info', 'warning', 'error', 'fatal'].indexOf(value) === -1) {\n      throw new Error(`Unsupported logging level: ${value}`);\n    }\n    logLevelValue = value;\n  },\n  get logLevel(): Required<LogLevelType> {\n    return logLevelValue;\n  },\n};\n\n// set property 'logLevel' so that they can be correctly transferred to worker by `postMessage()`.\nObject.defineProperty(env, 'logLevel', { enumerable: true });\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env as envImpl } from './env-impl.js';\n\nexport declare namespace Env {\n  export type WasmPathPrefix = string;\n  export interface WasmFilePaths {\n    /**\n     * Specify the override path for the main .wasm file.\n     *\n     * This path should be an absolute path.\n     *\n     * If not modified, the filename of the .wasm file is:\n     * - `ort-wasm-simd-threaded.wasm` for default build\n     * - `ort-wasm-simd-threaded.jsep.wasm` for JSEP build (with WebGPU and WebNN)\n     * - `ort-training-wasm-simd-threaded.wasm` for training build\n     */\n    wasm?: URL | string;\n    /**\n     * Specify the override path for the main .mjs file.\n     *\n     * This path should be an absolute path.\n     *\n     * If not modified, the filename of the .mjs file is:\n     * - `ort-wasm-simd-threaded.mjs` for default build\n     * - `ort-wasm-simd-threaded.jsep.mjs` for JSEP build (with WebGPU and WebNN)\n     * - `ort-training-wasm-simd-threaded.mjs` for training build\n     */\n    mjs?: URL | string;\n  }\n  export type WasmPrefixOrFilePaths = WasmPathPrefix | WasmFilePaths;\n  export interface WebAssemblyFlags {\n    /**\n     * set or get number of thread(s). If omitted or set to 0, number of thread(s) will be determined by system. If set\n     * to 1, no worker thread will be spawned.\n     *\n     * This setting is available only when WebAssembly multithread feature is available in current context.\n     *\n     * @defaultValue `0`\n     */\n    numThreads?: number;\n\n    /**\n     * set or get a boolean value indicating whether to enable SIMD. If set to false, SIMD will be forcely disabled.\n     *\n     * This setting is available only when WebAssembly SIMD feature is available in current context.\n     *\n     * @deprecated This property is deprecated. Since SIMD is supported by all major JavaScript engines, non-SIMD\n     * build is no longer provided. This property will be removed in future release.\n     * @defaultValue `true`\n     */\n    simd?: boolean;\n\n    /**\n     * set or get a boolean value indicating whether to enable trace.\n     *\n     * @deprecated Use `env.trace` instead. If `env.trace` is set, this property will be ignored.\n     * @defaultValue `false`\n     */\n    trace?: boolean;\n\n    /**\n     * Set or get a number specifying the timeout for initialization of WebAssembly backend, in milliseconds. A zero\n     * value indicates no timeout is set.\n     *\n     * @defaultValue `0`\n     */\n    initTimeout?: number;\n\n    /**\n     * Set a custom URL prefix to the .wasm/.mjs files, or an object of overrides for both .wasm/.mjs file. The override\n     * path should be an absolute path.\n     */\n    wasmPaths?: WasmPrefixOrFilePaths;\n\n    /**\n     * Set a custom buffer which contains the WebAssembly binary. If this property is set, the `wasmPaths` property will\n     * be ignored.\n     */\n    wasmBinary?: ArrayBufferLike | Uint8Array;\n\n    /**\n     * Set or get a boolean value indicating whether to proxy the execution of main thread to a worker thread.\n     *\n     * @defaultValue `false`\n     */\n    proxy?: boolean;\n  }\n\n  export interface WebGLFlags {\n    /**\n     * Set or get the WebGL Context ID (webgl or webgl2).\n     *\n     * @defaultValue `'webgl2'`\n     */\n    contextId?: 'webgl' | 'webgl2';\n    /**\n     * Get the WebGL rendering context.\n     */\n    readonly context: WebGLRenderingContext;\n    /**\n     * Set or get the maximum batch size for matmul. 0 means to disable batching.\n     *\n     * @deprecated\n     */\n    matmulMaxBatchSize?: number;\n    /**\n     * Set or get the texture cache mode.\n     *\n     * @defaultValue `'full'`\n     */\n    textureCacheMode?: 'initializerOnly' | 'full';\n    /**\n     * Set or get the packed texture mode\n     *\n     * @defaultValue `false`\n     */\n    pack?: boolean;\n    /**\n     * Set or get whether enable async download.\n     *\n     * @defaultValue `false`\n     */\n    async?: boolean;\n  }\n\n  export interface WebGpuProfilingDataV1TensorMetadata {\n    dims: readonly number[];\n    dataType: string;\n  }\n  export interface WebGpuProfilingDataV1 {\n    version: 1;\n    inputsMetadata: readonly WebGpuProfilingDataV1TensorMetadata[];\n    outputsMetadata: readonly WebGpuProfilingDataV1TensorMetadata[];\n    kernelId: number;\n    kernelType: string;\n    kernelName: string;\n    programName: string;\n    startTime: number;\n    endTime: number;\n  }\n\n  export type WebGpuProfilingData = WebGpuProfilingDataV1;\n\n  export interface WebGpuFlags {\n    /**\n     * Set or get the profiling mode.\n     *\n     * @deprecated Use `env.webgpu.profiling.mode` instead. If `env.webgpu.profiling.mode` is set, this property will be\n     * ignored.\n     */\n    profilingMode?: 'off' | 'default';\n    /**\n     * Set or get the profiling configuration.\n     */\n    profiling?: {\n      /**\n       * Set or get the profiling mode.\n       *\n       * @defaultValue `'off'`\n       */\n      mode?: 'off' | 'default';\n\n      /**\n       * Set or get a callback function when a profiling data is received. If not set, the profiling data will be\n       * printed to console.\n       */\n      ondata?: (data: WebGpuProfilingData) => void;\n    };\n    /**\n     * Set or get the power preference.\n     *\n     * Setting this property only has effect before the first WebGPU inference session is created. The value will be\n     * used as options for `navigator.gpu.requestAdapter()`.\n     *\n     * See {@link https://gpuweb.github.io/gpuweb/#dictdef-gpurequestadapteroptions} for more details.\n     *\n     * @defaultValue `undefined`\n     */\n    powerPreference?: 'low-power' | 'high-performance';\n    /**\n     * Set or get the force fallback adapter flag.\n     *\n     * Setting this property only has effect before the first WebGPU inference session is created. The value will be\n     * used as options for `navigator.gpu.requestAdapter()`.\n     *\n     * See {@link https://gpuweb.github.io/gpuweb/#dictdef-gpurequestadapteroptions} for more details.\n     *\n     * @defaultValue `undefined`\n     */\n    forceFallbackAdapter?: boolean;\n    /**\n     * Set or get the adapter for WebGPU.\n     *\n     * Setting this property only has effect before the first WebGPU inference session is created. The value will be\n     * used as the GPU adapter for the underlying WebGPU backend to create GPU device.\n     *\n     * If this property is not set, it will be available to get after the first WebGPU inference session is created. The\n     * value will be the GPU adapter that created by the underlying WebGPU backend.\n     *\n     * When use with TypeScript, the type of this property is `GPUAdapter` defined in \"@webgpu/types\".\n     * Use `const adapter = env.webgpu.adapter as GPUAdapter;` in TypeScript to access this property with correct type.\n     *\n     * see comments on {@link Tensor.GpuBufferType}\n     */\n    adapter: unknown;\n    /**\n     * Get the device for WebGPU.\n     *\n     * This property is only available after the first WebGPU inference session is created.\n     *\n     * When use with TypeScript, the type of this property is `GPUDevice` defined in \"@webgpu/types\".\n     * Use `const device = env.webgpu.device as GPUDevice;` in TypeScript to access this property with correct type.\n     *\n     * see comments on {@link Tensor.GpuBufferType} for more details about why not use types defined in \"@webgpu/types\".\n     */\n    readonly device: unknown;\n    /**\n     * Set or get whether validate input content.\n     *\n     * @defaultValue `false`\n     */\n    validateInputContent?: boolean;\n  }\n}\n\nexport interface Env {\n  /**\n   * set the severity level for logging.\n   *\n   * @defaultValue `'warning'`\n   */\n  logLevel?: 'verbose' | 'info' | 'warning' | 'error' | 'fatal';\n\n  /**\n   * Indicate whether run in debug mode.\n   *\n   * @defaultValue `false`\n   */\n  debug?: boolean;\n\n  /**\n   * set or get a boolean value indicating whether to enable trace.\n   *\n   * @defaultValue `false`\n   */\n  trace?: boolean;\n\n  /**\n   * Get version of the current package.\n   */\n  readonly versions: {\n    readonly common: string;\n    readonly web?: string;\n    readonly node?: string;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    readonly 'react-native'?: string;\n  };\n\n  /**\n   * Represent a set of flags for WebAssembly\n   */\n  readonly wasm: Env.WebAssemblyFlags;\n\n  /**\n   * Represent a set of flags for WebGL\n   */\n  readonly webgl: Env.WebGLFlags;\n\n  /**\n   * Represent a set of flags for WebGPU\n   */\n  readonly webgpu: Env.WebGpuFlags;\n\n  [name: string]: unknown;\n}\n\n/**\n * Represent a set of flags as a global singleton.\n */\nexport const env: Env = envImpl;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { TensorToDataUrlOptions, TensorToImageDataOptions } from './tensor-conversion.js';\nimport { Tensor } from './tensor.js';\n\n/**\n * implementation of Tensor.toDataURL()\n */\nexport const tensorToDataURL = (tensor: Tensor, options?: TensorToDataUrlOptions): string => {\n  const canvas = typeof document !== 'undefined' ? document.createElement('canvas') : new OffscreenCanvas(1, 1);\n  canvas.width = tensor.dims[3];\n  canvas.height = tensor.dims[2];\n  const pixels2DContext = canvas.getContext('2d') as\n    | CanvasRenderingContext2D\n    | OffscreenCanvasRenderingContext2D\n    | null;\n\n  if (pixels2DContext != null) {\n    // Default values for height and width & format\n    let width: number;\n    let height: number;\n    if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {\n      width = tensor.dims[2];\n      height = tensor.dims[3];\n    } else {\n      // Default layout is NCWH\n      width = tensor.dims[3];\n      height = tensor.dims[2];\n    }\n\n    const inputformat = options?.format !== undefined ? options.format : 'RGB';\n\n    const norm = options?.norm;\n    let normMean: [number, number, number, number];\n    let normBias: [number, number, number, number];\n    if (norm === undefined || norm.mean === undefined) {\n      normMean = [255, 255, 255, 255];\n    } else {\n      if (typeof norm.mean === 'number') {\n        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n      } else {\n        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];\n        if (norm.mean[3] !== undefined) {\n          normMean[3] = norm.mean[3];\n        }\n      }\n    }\n    if (norm === undefined || norm.bias === undefined) {\n      normBias = [0, 0, 0, 0];\n    } else {\n      if (typeof norm.bias === 'number') {\n        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n      } else {\n        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];\n        if (norm.bias[3] !== undefined) {\n          normBias[3] = norm.bias[3];\n        }\n      }\n    }\n\n    const stride = height * width;\n    // Default pointer assignments\n    let rTensorPointer = 0,\n      gTensorPointer = stride,\n      bTensorPointer = stride * 2,\n      aTensorPointer = -1;\n\n    // Updating the pointer assignments based on the input image format\n    if (inputformat === 'RGBA') {\n      rTensorPointer = 0;\n      gTensorPointer = stride;\n      bTensorPointer = stride * 2;\n      aTensorPointer = stride * 3;\n    } else if (inputformat === 'RGB') {\n      rTensorPointer = 0;\n      gTensorPointer = stride;\n      bTensorPointer = stride * 2;\n    } else if (inputformat === 'RBG') {\n      rTensorPointer = 0;\n      bTensorPointer = stride;\n      gTensorPointer = stride * 2;\n    }\n\n    for (let i = 0; i < height; i++) {\n      for (let j = 0; j < width; j++) {\n        const R = ((tensor.data[rTensorPointer++] as number) - normBias[0]) * normMean[0]; // R value\n        const G = ((tensor.data[gTensorPointer++] as number) - normBias[1]) * normMean[1]; // G value\n        const B = ((tensor.data[bTensorPointer++] as number) - normBias[2]) * normMean[2]; // B value\n        const A = aTensorPointer === -1 ? 255 : ((tensor.data[aTensorPointer++] as number) - normBias[3]) * normMean[3]; // A value\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        pixels2DContext.fillStyle = 'rgba(' + R + ',' + G + ',' + B + ',' + A + ')';\n        pixels2DContext.fillRect(j, i, 1, 1);\n      }\n    }\n    if ('toDataURL' in canvas) {\n      return canvas.toDataURL();\n    } else {\n      throw new Error('toDataURL is not supported');\n    }\n  } else {\n    throw new Error('Can not access image data');\n  }\n};\n\n/**\n * implementation of Tensor.toImageData()\n */\nexport const tensorToImageData = (tensor: Tensor, options?: TensorToImageDataOptions): ImageData => {\n  const pixels2DContext =\n    typeof document !== 'undefined'\n      ? document.createElement('canvas').getContext('2d')\n      : (new OffscreenCanvas(1, 1).getContext('2d') as OffscreenCanvasRenderingContext2D);\n  let image: ImageData;\n  if (pixels2DContext != null) {\n    // Default values for height and width & format\n    let width: number;\n    let height: number;\n    let channels: number;\n    if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {\n      width = tensor.dims[2];\n      height = tensor.dims[1];\n      channels = tensor.dims[3];\n    } else {\n      // Default layout is NCWH\n      width = tensor.dims[3];\n      height = tensor.dims[2];\n      channels = tensor.dims[1];\n    }\n    const inputformat = options !== undefined ? (options.format !== undefined ? options.format : 'RGB') : 'RGB';\n\n    const norm = options?.norm;\n    let normMean: [number, number, number, number];\n    let normBias: [number, number, number, number];\n    if (norm === undefined || norm.mean === undefined) {\n      normMean = [255, 255, 255, 255];\n    } else {\n      if (typeof norm.mean === 'number') {\n        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n      } else {\n        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];\n        if (norm.mean[3] !== undefined) {\n          normMean[3] = norm.mean[3];\n        }\n      }\n    }\n    if (norm === undefined || norm.bias === undefined) {\n      normBias = [0, 0, 0, 0];\n    } else {\n      if (typeof norm.bias === 'number') {\n        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n      } else {\n        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];\n        if (norm.bias[3] !== undefined) {\n          normBias[3] = norm.bias[3];\n        }\n      }\n    }\n\n    const stride = height * width;\n    if (options !== undefined) {\n      if (\n        (options.format !== undefined && channels === 4 && options.format !== 'RGBA') ||\n        (channels === 3 && options.format !== 'RGB' && options.format !== 'BGR')\n      ) {\n        throw new Error(\"Tensor format doesn't match input tensor dims\");\n      }\n    }\n\n    // Default pointer assignments\n    const step = 4;\n    let rImagePointer = 0,\n      gImagePointer = 1,\n      bImagePointer = 2,\n      aImagePointer = 3;\n    let rTensorPointer = 0,\n      gTensorPointer = stride,\n      bTensorPointer = stride * 2,\n      aTensorPointer = -1;\n\n    // Updating the pointer assignments based on the input image format\n    if (inputformat === 'RGBA') {\n      rTensorPointer = 0;\n      gTensorPointer = stride;\n      bTensorPointer = stride * 2;\n      aTensorPointer = stride * 3;\n    } else if (inputformat === 'RGB') {\n      rTensorPointer = 0;\n      gTensorPointer = stride;\n      bTensorPointer = stride * 2;\n    } else if (inputformat === 'RBG') {\n      rTensorPointer = 0;\n      bTensorPointer = stride;\n      gTensorPointer = stride * 2;\n    }\n\n    image = pixels2DContext.createImageData(width, height);\n\n    for (\n      let i = 0;\n      i < height * width;\n      rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++\n    ) {\n      image.data[rImagePointer] = ((tensor.data[rTensorPointer++] as number) - normBias[0]) * normMean[0]; // R value\n      image.data[gImagePointer] = ((tensor.data[gTensorPointer++] as number) - normBias[1]) * normMean[1]; // G value\n      image.data[bImagePointer] = ((tensor.data[bTensorPointer++] as number) - normBias[2]) * normMean[2]; // B value\n      image.data[aImagePointer] =\n        aTensorPointer === -1 ? 255 : ((tensor.data[aTensorPointer++] as number) - normBias[3]) * normMean[3]; // A value\n    }\n  } else {\n    throw new Error('Can not access image data');\n  }\n  return image;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  OptionsDimensions,\n  OptionsFormat,\n  OptionsNormalizationParameters,\n  OptionsTensorFormat,\n  OptionsTensorLayout,\n  TensorFromGpuBufferOptions,\n  TensorFromImageBitmapOptions,\n  TensorFromImageDataOptions,\n  TensorFromImageElementOptions,\n  TensorFromMLTensorOptions,\n  TensorFromTextureOptions,\n  TensorFromUrlOptions,\n} from './tensor-factory.js';\nimport { Tensor } from './tensor-impl.js';\nimport { Tensor as TensorInterface } from './tensor.js';\n\ninterface BufferToTensorOptions\n  extends OptionsDimensions,\n    OptionsTensorLayout,\n    OptionsNormalizationParameters,\n    OptionsFormat,\n    OptionsTensorFormat {}\n\n/**\n * Create a new tensor object from image object\n *\n * @param buffer - Extracted image buffer data - assuming RGBA format\n * @param imageFormat - input image configuration - required configurations height, width, format\n * @param tensorFormat - output tensor configuration - Default is RGB format\n */\nexport const bufferToTensor = (buffer: Uint8ClampedArray | undefined, options: BufferToTensorOptions): Tensor => {\n  if (buffer === undefined) {\n    throw new Error('Image buffer must be defined');\n  }\n  if (options.height === undefined || options.width === undefined) {\n    throw new Error('Image height and width must be defined');\n  }\n  if (options.tensorLayout === 'NHWC') {\n    throw new Error('NHWC Tensor layout is not supported yet');\n  }\n\n  const { height, width } = options;\n\n  const norm = options.norm ?? { mean: 255, bias: 0 };\n  let normMean: [number, number, number, number];\n  let normBias: [number, number, number, number];\n\n  if (typeof norm.mean === 'number') {\n    normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n  } else {\n    normMean = [norm.mean![0], norm.mean![1], norm.mean![2], norm.mean![3] ?? 255];\n  }\n\n  if (typeof norm.bias === 'number') {\n    normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n  } else {\n    normBias = [norm.bias![0], norm.bias![1], norm.bias![2], norm.bias![3] ?? 0];\n  }\n\n  const inputformat = options.format !== undefined ? options.format : 'RGBA';\n  // default value is RGBA since imagedata and HTMLImageElement uses it\n\n  const outputformat =\n    options.tensorFormat !== undefined ? (options.tensorFormat !== undefined ? options.tensorFormat : 'RGB') : 'RGB';\n  const stride = height * width;\n  const float32Data = outputformat === 'RGBA' ? new Float32Array(stride * 4) : new Float32Array(stride * 3);\n\n  // Default pointer assignments\n  let step = 4,\n    rImagePointer = 0,\n    gImagePointer = 1,\n    bImagePointer = 2,\n    aImagePointer = 3;\n  let rTensorPointer = 0,\n    gTensorPointer = stride,\n    bTensorPointer = stride * 2,\n    aTensorPointer = -1;\n\n  // Updating the pointer assignments based on the input image format\n  if (inputformat === 'RGB') {\n    step = 3;\n    rImagePointer = 0;\n    gImagePointer = 1;\n    bImagePointer = 2;\n    aImagePointer = -1;\n  }\n\n  // Updating the pointer assignments based on the output tensor format\n  if (outputformat === 'RGBA') {\n    aTensorPointer = stride * 3;\n  } else if (outputformat === 'RBG') {\n    rTensorPointer = 0;\n    bTensorPointer = stride;\n    gTensorPointer = stride * 2;\n  } else if (outputformat === 'BGR') {\n    bTensorPointer = 0;\n    gTensorPointer = stride;\n    rTensorPointer = stride * 2;\n  }\n\n  for (\n    let i = 0;\n    i < stride;\n    i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step\n  ) {\n    float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];\n    float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];\n    float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];\n    if (aTensorPointer !== -1 && aImagePointer !== -1) {\n      float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];\n    }\n  }\n\n  // Float32Array -> ort.Tensor\n  const outputTensor =\n    outputformat === 'RGBA'\n      ? new Tensor('float32', float32Data, [1, 4, height, width])\n      : new Tensor('float32', float32Data, [1, 3, height, width]);\n  return outputTensor;\n};\n\n/**\n * implementation of Tensor.fromImage().\n */\nexport const tensorFromImage = async (\n  image: ImageData | HTMLImageElement | ImageBitmap | string,\n  options?:\n    | TensorFromImageDataOptions\n    | TensorFromImageElementOptions\n    | TensorFromImageBitmapOptions\n    | TensorFromUrlOptions,\n): Promise<Tensor> => {\n  // checking the type of image object\n  const isHTMLImageEle = typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement;\n  const isImageDataEle = typeof ImageData !== 'undefined' && image instanceof ImageData;\n  const isImageBitmap = typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap;\n  const isString = typeof image === 'string';\n\n  let data: Uint8ClampedArray | undefined;\n  let bufferToTensorOptions: BufferToTensorOptions = options ?? {};\n\n  const createCanvas = () => {\n    if (typeof document !== 'undefined') {\n      return document.createElement('canvas');\n    } else if (typeof OffscreenCanvas !== 'undefined') {\n      return new OffscreenCanvas(1, 1);\n    } else {\n      throw new Error('Canvas is not supported');\n    }\n  };\n  const createCanvasContext = (canvas: HTMLCanvasElement | OffscreenCanvas) => {\n    if (typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement) {\n      return canvas.getContext('2d');\n    } else if (canvas instanceof OffscreenCanvas) {\n      return canvas.getContext('2d') as OffscreenCanvasRenderingContext2D;\n    } else {\n      return null;\n    }\n  };\n  // filling and checking image configuration options\n  if (isHTMLImageEle) {\n    // HTMLImageElement - image object - format is RGBA by default\n    const canvas = createCanvas();\n    canvas.width = image.width;\n    canvas.height = image.height;\n    const pixels2DContext = createCanvasContext(canvas);\n\n    if (pixels2DContext != null) {\n      let height = image.height;\n      let width = image.width;\n      if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {\n        height = options.resizedHeight;\n        width = options.resizedWidth;\n      }\n\n      if (options !== undefined) {\n        bufferToTensorOptions = options;\n        if (options.tensorFormat !== undefined) {\n          throw new Error('Image input config format must be RGBA for HTMLImageElement');\n        } else {\n          bufferToTensorOptions.tensorFormat = 'RGBA';\n        }\n        bufferToTensorOptions.height = height;\n        bufferToTensorOptions.width = width;\n      } else {\n        bufferToTensorOptions.tensorFormat = 'RGBA';\n        bufferToTensorOptions.height = height;\n        bufferToTensorOptions.width = width;\n      }\n\n      pixels2DContext.drawImage(image, 0, 0);\n      data = pixels2DContext.getImageData(0, 0, width, height).data;\n    } else {\n      throw new Error('Can not access image data');\n    }\n  } else if (isImageDataEle) {\n    let height: number;\n    let width: number;\n\n    if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {\n      height = options.resizedHeight;\n      width = options.resizedWidth;\n    } else {\n      height = image.height;\n      width = image.width;\n    }\n\n    if (options !== undefined) {\n      bufferToTensorOptions = options;\n    }\n    bufferToTensorOptions.format = 'RGBA';\n    bufferToTensorOptions.height = height;\n    bufferToTensorOptions.width = width;\n\n    if (options !== undefined) {\n      const tempCanvas = createCanvas();\n\n      tempCanvas.width = width;\n      tempCanvas.height = height;\n\n      const pixels2DContext = createCanvasContext(tempCanvas);\n\n      if (pixels2DContext != null) {\n        pixels2DContext.putImageData(image, 0, 0);\n        data = pixels2DContext.getImageData(0, 0, width, height).data;\n      } else {\n        throw new Error('Can not access image data');\n      }\n    } else {\n      data = image.data;\n    }\n  } else if (isImageBitmap) {\n    // ImageBitmap - image object - format must be provided by user\n    if (options === undefined) {\n      throw new Error('Please provide image config with format for Imagebitmap');\n    }\n\n    const canvas = createCanvas();\n    canvas.width = image.width;\n    canvas.height = image.height;\n    const pixels2DContext = createCanvasContext(canvas);\n\n    if (pixels2DContext != null) {\n      const height = image.height;\n      const width = image.width;\n      pixels2DContext.drawImage(image, 0, 0, width, height);\n      data = pixels2DContext.getImageData(0, 0, width, height).data;\n      bufferToTensorOptions.height = height;\n      bufferToTensorOptions.width = width;\n      return bufferToTensor(data, bufferToTensorOptions);\n    } else {\n      throw new Error('Can not access image data');\n    }\n  } else if (isString) {\n    return new Promise((resolve, reject) => {\n      const canvas = createCanvas();\n      const context = createCanvasContext(canvas);\n      if (!image || !context) {\n        return reject();\n      }\n      const newImage = new Image();\n      newImage.crossOrigin = 'Anonymous';\n      newImage.src = image;\n      newImage.onload = () => {\n        canvas.width = newImage.width;\n        canvas.height = newImage.height;\n        context.drawImage(newImage, 0, 0, canvas.width, canvas.height);\n        const img = context.getImageData(0, 0, canvas.width, canvas.height);\n\n        bufferToTensorOptions.height = canvas.height;\n        bufferToTensorOptions.width = canvas.width;\n        resolve(bufferToTensor(img.data, bufferToTensorOptions));\n      };\n    });\n  } else {\n    throw new Error('Input data provided is not supported - aborted tensor creation');\n  }\n\n  if (data !== undefined) {\n    return bufferToTensor(data, bufferToTensorOptions);\n  } else {\n    throw new Error('Input data provided is not supported - aborted tensor creation');\n  }\n};\n\n/**\n * implementation of Tensor.fromTexture().\n */\nexport const tensorFromTexture = <T extends TensorInterface.TextureDataTypes>(\n  texture: TensorInterface.TextureType,\n  options: TensorFromTextureOptions<T>,\n): Tensor => {\n  const { width, height, download, dispose } = options;\n  // Always assume RGBAF32. TODO: support different texture format\n  const dims = [1, height, width, 4];\n  return new Tensor({ location: 'texture', type: 'float32', texture, dims, download, dispose });\n};\n\n/**\n * implementation of Tensor.fromGpuBuffer().\n */\nexport const tensorFromGpuBuffer = <T extends TensorInterface.GpuBufferDataTypes>(\n  gpuBuffer: TensorInterface.GpuBufferType,\n  options: TensorFromGpuBufferOptions<T>,\n): Tensor => {\n  const { dataType, dims, download, dispose } = options;\n  return new Tensor({ location: 'gpu-buffer', type: dataType ?? 'float32', gpuBuffer, dims, download, dispose });\n};\n\n/**\n * implementation of Tensor.fromMLTensor().\n */\nexport const tensorFromMLTensor = <T extends TensorInterface.MLTensorDataTypes>(\n  mlTensor: TensorInterface.MLTensorType,\n  options: TensorFromMLTensorOptions<T>,\n): Tensor => {\n  const { dataType, dims, download, dispose } = options;\n  return new Tensor({ location: 'ml-tensor', type: dataType ?? 'float32', mlTensor, dims, download, dispose });\n};\n\n/**\n * implementation of Tensor.fromPinnedBuffer().\n */\nexport const tensorFromPinnedBuffer = <T extends TensorInterface.CpuPinnedDataTypes>(\n  type: T,\n  buffer: TensorInterface.DataTypeMap[T],\n  dims?: readonly number[],\n): Tensor => new Tensor({ location: 'cpu-pinned', type, data: buffer, dims: dims ?? [buffer.length] });\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from './tensor.js';\n\nexport type SupportedTypedArrayConstructors =\n  | Float32ArrayConstructor\n  | Uint8ArrayConstructor\n  | Int8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | BigInt64ArrayConstructor\n  | Uint8ArrayConstructor\n  | Float64ArrayConstructor\n  | Uint32ArrayConstructor\n  | BigUint64ArrayConstructor;\nexport type SupportedTypedArray = InstanceType<SupportedTypedArrayConstructors>;\n\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nexport const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map<string, SupportedTypedArrayConstructors>([\n  ['float32', Float32Array],\n  ['uint8', Uint8Array],\n  ['int8', Int8Array],\n  ['uint16', Uint16Array],\n  ['int16', Int16Array],\n  ['int32', Int32Array],\n  ['bool', Uint8Array],\n  ['float64', Float64Array],\n  ['uint32', Uint32Array],\n  ['int4', Uint8Array],\n  ['uint4', Uint8Array],\n]);\n\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nexport const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map<SupportedTypedArrayConstructors, Tensor.Type>([\n  [Float32Array, 'float32'],\n  [Uint8Array, 'uint8'],\n  [Int8Array, 'int8'],\n  [Uint16Array, 'uint16'],\n  [Int16Array, 'int16'],\n  [Int32Array, 'int32'],\n  [Float64Array, 'float64'],\n  [Uint32Array, 'uint32'],\n]);\n\n// a dummy type declaration for Float16Array in case any polyfill is available.\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-explicit-any\n  const Float16Array: any;\n}\n\n// the following code allows delaying execution of BigInt/Float16Array checking. This allows lazy initialization for\n// NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP and NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, which allows BigInt/Float16Array\n// polyfill if available.\nlet isTypedArrayChecked = false;\nexport const checkTypedArray = () => {\n  if (!isTypedArrayChecked) {\n    isTypedArrayChecked = true;\n    const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && BigInt64Array.from;\n    const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && BigUint64Array.from;\n    const isFloat16ArrayAvailable = typeof Float16Array !== 'undefined' && Float16Array.from;\n\n    if (isBigInt64ArrayAvailable) {\n      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n    }\n    if (isBigUint64ArrayAvailable) {\n      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n    }\n    if (isFloat16ArrayAvailable) {\n      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('float16', Float16Array);\n      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, 'float16');\n    } else {\n      // if Float16Array is not available, use 'Uint16Array' to store the data.\n      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('float16', Uint16Array);\n    }\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  CpuPinnedConstructorParameters,\n  GpuBufferConstructorParameters,\n  MLTensorConstructorParameters,\n  TextureConstructorParameters,\n} from './tensor-factory.js';\nimport { Tensor } from './tensor-impl.js';\n\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\nexport const calculateSize = (dims: readonly unknown[]): number => {\n  let size = 1;\n  for (let i = 0; i < dims.length; i++) {\n    const dim = dims[i];\n    if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n      throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n    }\n    if (dim < 0) {\n      throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n    }\n    size *= dim;\n  }\n  return size;\n};\n\n/**\n * implementation of Tensor.reshape()\n */\nexport const tensorReshape = (tensor: Tensor, dims: readonly number[]): Tensor => {\n  switch (tensor.location) {\n    case 'cpu':\n      return new Tensor(tensor.type, tensor.data, dims);\n    case 'cpu-pinned':\n      return new Tensor({\n        location: 'cpu-pinned',\n        data: tensor.data as CpuPinnedConstructorParameters['data'],\n        type: tensor.type as CpuPinnedConstructorParameters['type'],\n        dims,\n      });\n    case 'texture':\n      return new Tensor({\n        location: 'texture',\n        texture: tensor.texture,\n        type: tensor.type as TextureConstructorParameters['type'],\n        dims,\n      });\n    case 'gpu-buffer':\n      return new Tensor({\n        location: 'gpu-buffer',\n        gpuBuffer: tensor.gpuBuffer,\n        type: tensor.type as GpuBufferConstructorParameters['type'],\n        dims,\n      });\n    case 'ml-tensor':\n      return new Tensor({\n        location: 'ml-tensor',\n        mlTensor: tensor.mlTensor,\n        type: tensor.type as MLTensorConstructorParameters['type'],\n        dims,\n      });\n    default:\n      throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { tensorToDataURL, tensorToImageData } from './tensor-conversion-impl.js';\nimport { TensorToDataUrlOptions, TensorToImageDataOptions } from './tensor-conversion.js';\nimport {\n  tensorFromGpuBuffer,\n  tensorFromImage,\n  tensorFromMLTensor,\n  tensorFromPinnedBuffer,\n  tensorFromTexture,\n} from './tensor-factory-impl.js';\nimport {\n  CpuPinnedConstructorParameters,\n  GpuBufferConstructorParameters,\n  MLTensorConstructorParameters,\n  TensorFromGpuBufferOptions,\n  TensorFromImageBitmapOptions,\n  TensorFromImageDataOptions,\n  TensorFromImageElementOptions,\n  TensorFromMLTensorOptions,\n  TensorFromTextureOptions,\n  TensorFromUrlOptions,\n  TextureConstructorParameters,\n} from './tensor-factory.js';\nimport {\n  checkTypedArray,\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP,\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP,\n  SupportedTypedArray,\n  SupportedTypedArrayConstructors,\n} from './tensor-impl-type-mapping.js';\nimport { calculateSize, tensorReshape } from './tensor-utils-impl.js';\nimport { Tensor as TensorInterface } from './tensor.js';\n\n// type aliases for those exported from Tensor interface\n\ntype TensorType = TensorInterface.Type;\ntype TensorDataType = TensorInterface.DataType;\ntype TensorDataLocation = TensorInterface.DataLocation;\ntype TensorTextureType = TensorInterface.TextureType;\ntype TensorGpuBufferType = TensorInterface.GpuBufferType;\ntype TensorMLTensorType = TensorInterface.MLTensorType;\n\n/**\n * the implementation of Tensor interface.\n *\n * @ignore\n */\nexport class Tensor implements TensorInterface {\n  // #region constructors\n\n  /**\n   * Construct a new CPU tensor object from the given type, data and dims.\n   */\n  constructor(\n    type: TensorType,\n    data: TensorDataType | Uint8ClampedArray | readonly string[] | readonly number[] | readonly boolean[],\n    dims?: readonly number[],\n  );\n  /**\n   * Construct a new CPU tensor object from the given data and dims. Type is inferred from data.\n   */\n  constructor(\n    data: TensorDataType | Uint8ClampedArray | readonly string[] | readonly boolean[],\n    dims?: readonly number[],\n  );\n  /**\n   * Construct a new tensor object from the pinned CPU data with the given type and dims.\n   *\n   * Tensor's location will be set to 'cpu-pinned'.\n   *\n   * @param params - Specify the parameters to construct the tensor.\n   */\n  constructor(params: CpuPinnedConstructorParameters);\n  /**\n   * Construct a new tensor object from the WebGL texture with the given type and dims.\n   *\n   * Tensor's location will be set to 'texture'.\n   *\n   * @param params - Specify the parameters to construct the tensor.\n   */\n  constructor(params: TextureConstructorParameters);\n  /**\n   * Construct a new tensor object from the WebGPU buffer with the given type and dims.\n   *\n   * Tensor's location will be set to 'gpu-buffer'.\n   *\n   * @param params - Specify the parameters to construct the tensor.\n   */\n  constructor(params: GpuBufferConstructorParameters);\n\n  /**\n   * Construct a new tensor object from the WebNN MLTensor with the given type and dims.\n   *\n   * Tensor's location will be set to 'ml-tensor'.\n   *\n   * @param params - Specify the parameters to construct the tensor.\n   */\n  constructor(params: MLTensorConstructorParameters);\n\n  /**\n   * implementation.\n   */\n  constructor(\n    arg0:\n      | TensorType\n      | TensorDataType\n      | Uint8ClampedArray\n      | readonly string[]\n      | readonly boolean[]\n      | CpuPinnedConstructorParameters\n      | TextureConstructorParameters\n      | GpuBufferConstructorParameters\n      | MLTensorConstructorParameters,\n    arg1?: TensorDataType | Uint8ClampedArray | readonly number[] | readonly string[] | readonly boolean[],\n    arg2?: readonly number[],\n  ) {\n    // perform one-time check for BigInt/Float16Array support\n    checkTypedArray();\n\n    let type: TensorType;\n    let dims: readonly number[];\n\n    if (typeof arg0 === 'object' && 'location' in arg0) {\n      //\n      // constructing tensor from specific location\n      //\n      this.dataLocation = arg0.location;\n      type = arg0.type;\n      dims = arg0.dims;\n      switch (arg0.location) {\n        case 'cpu-pinned': {\n          const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);\n          if (!expectedTypedArrayConstructor) {\n            throw new TypeError(`unsupported type \"${type}\" to create tensor from pinned buffer`);\n          }\n          if (!(arg0.data instanceof expectedTypedArrayConstructor)) {\n            throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);\n          }\n          this.cpuData = arg0.data;\n          break;\n        }\n        case 'texture': {\n          if (type !== 'float32') {\n            throw new TypeError(`unsupported type \"${type}\" to create tensor from texture`);\n          }\n          this.gpuTextureData = arg0.texture;\n          this.downloader = arg0.download;\n          this.disposer = arg0.dispose;\n          break;\n        }\n        case 'gpu-buffer': {\n          if (\n            type !== 'float32' &&\n            type !== 'float16' &&\n            type !== 'int32' &&\n            type !== 'int64' &&\n            type !== 'uint32' &&\n            type !== 'uint8' &&\n            type !== 'bool' &&\n            type !== 'uint4' &&\n            type !== 'int4'\n          ) {\n            throw new TypeError(`unsupported type \"${type}\" to create tensor from gpu buffer`);\n          }\n          this.gpuBufferData = arg0.gpuBuffer;\n          this.downloader = arg0.download;\n          this.disposer = arg0.dispose;\n          break;\n        }\n        case 'ml-tensor': {\n          if (\n            type !== 'float32' &&\n            type !== 'float16' &&\n            type !== 'int32' &&\n            type !== 'int64' &&\n            type !== 'uint32' &&\n            type !== 'uint64' &&\n            type !== 'int8' &&\n            type !== 'uint8' &&\n            type !== 'bool'\n          ) {\n            throw new TypeError(`unsupported type \"${type}\" to create tensor from MLTensor`);\n          }\n          this.mlTensorData = arg0.mlTensor;\n          this.downloader = arg0.download;\n          this.disposer = arg0.dispose;\n          break;\n        }\n        default:\n          throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);\n      }\n    } else {\n      //\n      // constructing tensor of location 'cpu'\n      //\n      let data: TensorDataType;\n      let maybeDims: typeof arg1 | typeof arg2;\n      // check whether arg0 is type or data\n      if (typeof arg0 === 'string') {\n        //\n        // Override: constructor(type, data, ...)\n        //\n        type = arg0;\n        maybeDims = arg2;\n        if (arg0 === 'string') {\n          // string tensor\n          if (!Array.isArray(arg1)) {\n            throw new TypeError(\"A string tensor's data must be a string array.\");\n          }\n          // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n          // error will be populated at inference\n          data = arg1;\n        } else {\n          // numeric tensor\n          const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n          if (typedArrayConstructor === undefined) {\n            throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n          }\n          if (Array.isArray(arg1)) {\n            if ((arg0 === 'float16' && typedArrayConstructor === Uint16Array) || arg0 === 'uint4' || arg0 === 'int4') {\n              // - 'float16':\n              //   When no Float16Array polyfill is used, we cannot create 'float16' tensor from number array.\n              //\n              //   Throw error here because when user try to use number array as data,\n              //   e.g. new Tensor('float16', [1, 2, 3, 4], dims)), it will actually call\n              //   Uint16Array.from(arg1) which generates wrong data.\n              //\n              // - 'uint4' and 'int4':\n              //   Uint8Array.from(arg1) will generate wrong data for 'uint4' and 'int4' tensor.\n              //\n              throw new TypeError(\n                `Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`,\n              );\n            } else if (arg0 === 'uint64' || arg0 === 'int64') {\n              // use 'as any' here because:\n              // 1. TypeScript's check on type of 'Array.isArray()' does not work with readonly arrays.\n              // see https://github.com/microsoft/TypeScript/issues/17002\n              // 2. TypeScript's check on union type of '(BigInt64ArrayConstructor|BigUint64ArrayConstructor).from()'\n              // does not accept parameter mapFn.\n              // 3. parameters of 'SupportedTypedArrayConstructors.from()' does not match the requirement of the union\n              // type.\n\n              // assume 'arg1' is of type \"readonly number[]|readonly bigint[]\" here.\n\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              data = (typedArrayConstructor as any).from(arg1, BigInt);\n            } else {\n              // assume 'arg1' is of type \"readonly number[]\" here.\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              data = (typedArrayConstructor as any).from(arg1);\n            }\n          } else if (arg1 instanceof typedArrayConstructor) {\n            data = arg1;\n          } else if (arg1 instanceof Uint8ClampedArray) {\n            if (arg0 === 'uint8') {\n              data = Uint8Array.from(arg1);\n            } else {\n              throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);\n            }\n          } else {\n            throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n          }\n        }\n      } else {\n        //\n        // Override: constructor(data, ...)\n        //\n        maybeDims = arg1;\n        if (Array.isArray(arg0)) {\n          // only boolean[] and string[] is supported\n          if (arg0.length === 0) {\n            throw new TypeError('Tensor type cannot be inferred from an empty array.');\n          }\n          const firstElementType = typeof arg0[0];\n          if (firstElementType === 'string') {\n            type = 'string';\n            data = arg0;\n          } else if (firstElementType === 'boolean') {\n            type = 'bool';\n            // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n            // wrong type. We use 'as any' to make it happy.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            data = Uint8Array.from(arg0 as any[]);\n          } else {\n            throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n          }\n        } else if (arg0 instanceof Uint8ClampedArray) {\n          type = 'uint8';\n          data = Uint8Array.from(arg0);\n        } else {\n          // get tensor type from TypedArray\n          const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(\n            arg0.constructor as SupportedTypedArrayConstructors,\n          );\n          if (mappedType === undefined) {\n            throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n          }\n          type = mappedType;\n          data = arg0 as SupportedTypedArray;\n        }\n      }\n\n      // type and data is processed, now processing dims\n      if (maybeDims === undefined) {\n        // assume 1-D tensor if dims omitted\n        maybeDims = [data.length];\n      } else if (!Array.isArray(maybeDims)) {\n        throw new TypeError(\"A tensor's dims must be a number array\");\n      }\n      dims = maybeDims as readonly number[];\n\n      this.cpuData = data;\n      this.dataLocation = 'cpu';\n    }\n\n    // perform check on dims\n    const size = calculateSize(dims);\n    // if data is on CPU, check whether data length matches tensor size\n    if (this.cpuData && size !== this.cpuData.length) {\n      if ((type === 'uint4' || type === 'int4') && Math.ceil(size / 2) === this.cpuData.length) {\n        // for (u)int4, the data length is half of the tensor size. So we check this special case when size is odd.\n      } else {\n        throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);\n      }\n    }\n\n    this.type = type;\n    this.dims = dims;\n    this.size = size;\n  }\n  // #endregion\n\n  // #region factory\n  static async fromImage(\n    image: ImageData | HTMLImageElement | ImageBitmap | string,\n    options?:\n      | TensorFromImageDataOptions\n      | TensorFromImageElementOptions\n      | TensorFromImageBitmapOptions\n      | TensorFromUrlOptions,\n  ): Promise<TensorInterface> {\n    return tensorFromImage(image, options);\n  }\n\n  static fromTexture<T extends TensorInterface.TextureDataTypes>(\n    texture: TensorTextureType,\n    options: TensorFromTextureOptions<T>,\n  ): TensorInterface {\n    return tensorFromTexture(texture, options);\n  }\n\n  static fromGpuBuffer<T extends TensorInterface.GpuBufferDataTypes>(\n    gpuBuffer: TensorGpuBufferType,\n    options: TensorFromGpuBufferOptions<T>,\n  ): TensorInterface {\n    return tensorFromGpuBuffer(gpuBuffer, options);\n  }\n\n  static fromMLTensor<T extends TensorInterface.MLTensorDataTypes>(\n    mlTensor: TensorMLTensorType,\n    options: TensorFromMLTensorOptions<T>,\n  ): TensorInterface {\n    return tensorFromMLTensor(mlTensor, options);\n  }\n\n  static fromPinnedBuffer<T extends TensorInterface.CpuPinnedDataTypes>(\n    type: T,\n    buffer: TensorInterface.DataTypeMap[T],\n    dims?: readonly number[],\n  ): Tensor {\n    return tensorFromPinnedBuffer(type, buffer, dims);\n  }\n\n  // #endregion\n\n  // #region conversions\n  toDataURL(options?: TensorToDataUrlOptions): string {\n    return tensorToDataURL(this, options);\n  }\n\n  toImageData(options?: TensorToImageDataOptions): ImageData {\n    return tensorToImageData(this, options);\n  }\n  // #endregion\n\n  // #region public fields\n  readonly dims: readonly number[];\n  readonly type: TensorType;\n  readonly size: number;\n  // #endregion\n\n  // #region private fields\n\n  /**\n   * stores the location of the data.\n   */\n  private dataLocation: TensorDataLocation;\n\n  /**\n   * stores the data on CPU, if location is 'cpu' or 'cpu-pinned'. otherwise empty.\n   */\n  private cpuData?: TensorDataType;\n\n  /**\n   * stores the underlying texture when location is 'texture'. otherwise empty.\n   */\n  private gpuTextureData?: TensorTextureType;\n\n  /**\n   * stores the underlying GPU buffer when location is 'gpu-buffer'. otherwise empty.\n   */\n  private gpuBufferData?: TensorGpuBufferType;\n\n  /**\n   * stores the underlying WebNN MLTensor when location is 'ml-tensor'. otherwise empty.\n   */\n  private mlTensorData?: TensorMLTensorType;\n\n  /**\n   * stores an optional downloader function to download data from GPU to CPU.\n   */\n  private downloader?(): Promise<TensorDataType>;\n\n  /**\n   * a flag indicating whether the data is being downloaded from GPU to CPU.\n   */\n  private isDownloading?: boolean;\n\n  /**\n   * stores an optional disposer function to dispose the underlying data.\n   */\n  private disposer?(): void;\n  // #endregion\n\n  // #region properties\n  get data(): TensorDataType {\n    this.ensureValid();\n    if (!this.cpuData) {\n      throw new Error(\n        'The data is not on CPU. Use `getData()` to download GPU data to CPU, ' +\n          'or use `texture` or `gpuBuffer` property to access the GPU data directly.',\n      );\n    }\n    return this.cpuData;\n  }\n\n  get location(): TensorDataLocation {\n    return this.dataLocation;\n  }\n\n  get texture(): TensorTextureType {\n    this.ensureValid();\n    if (!this.gpuTextureData) {\n      throw new Error('The data is not stored as a WebGL texture.');\n    }\n    return this.gpuTextureData;\n  }\n\n  get gpuBuffer(): TensorGpuBufferType {\n    this.ensureValid();\n    if (!this.gpuBufferData) {\n      throw new Error('The data is not stored as a WebGPU buffer.');\n    }\n    return this.gpuBufferData;\n  }\n\n  get mlTensor(): TensorMLTensorType {\n    this.ensureValid();\n    if (!this.mlTensorData) {\n      throw new Error('The data is not stored as a WebNN MLTensor.');\n    }\n    return this.mlTensorData;\n  }\n  // #endregion\n\n  // #region methods\n\n  async getData(releaseData?: boolean): Promise<TensorDataType> {\n    this.ensureValid();\n    switch (this.dataLocation) {\n      case 'cpu':\n      case 'cpu-pinned':\n        return this.data;\n      case 'texture':\n      case 'gpu-buffer':\n      case 'ml-tensor': {\n        if (!this.downloader) {\n          throw new Error('The current tensor is not created with a specified data downloader.');\n        }\n        if (this.isDownloading) {\n          throw new Error('The current tensor is being downloaded.');\n        }\n        try {\n          this.isDownloading = true;\n          const data = await this.downloader();\n          this.downloader = undefined;\n          this.dataLocation = 'cpu';\n          this.cpuData = data;\n\n          if (releaseData && this.disposer) {\n            this.disposer();\n            this.disposer = undefined;\n          }\n\n          return data;\n        } finally {\n          this.isDownloading = false;\n        }\n      }\n      default:\n        throw new Error(`cannot get data from location: ${this.dataLocation}`);\n    }\n  }\n\n  dispose(): void {\n    if (this.isDownloading) {\n      throw new Error('The current tensor is being downloaded.');\n    }\n\n    if (this.disposer) {\n      this.disposer();\n      this.disposer = undefined;\n    }\n    this.cpuData = undefined;\n    this.gpuTextureData = undefined;\n    this.gpuBufferData = undefined;\n    this.mlTensorData = undefined;\n    this.downloader = undefined;\n    this.isDownloading = undefined;\n\n    this.dataLocation = 'none';\n  }\n\n  // #endregion\n\n  // #region tensor utilities\n  private ensureValid(): void {\n    if (this.dataLocation === 'none') {\n      throw new Error('The tensor is disposed.');\n    }\n  }\n\n  reshape(dims: readonly number[]): TensorInterface {\n    this.ensureValid();\n    if (this.downloader || this.disposer) {\n      throw new Error('Cannot reshape a tensor that owns GPU resource.');\n    }\n    return tensorReshape(this, dims);\n  }\n  // #endregion\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { TensorFactory } from './tensor-factory.js';\nimport { Tensor as TensorImpl } from './tensor-impl.js';\nimport { TypedTensorUtils } from './tensor-utils.js';\n\n/* eslint-disable @typescript-eslint/no-redeclare */\n\n/**\n * represent a basic tensor with specified dimensions and data type.\n */\ninterface TypedTensorBase<T extends Tensor.Type> {\n  /**\n   * Get the dimensions of the tensor.\n   */\n  readonly dims: readonly number[];\n  /**\n   * Get the data type of the tensor.\n   */\n  readonly type: T;\n  /**\n   * Get the buffer data of the tensor.\n   *\n   * If the data is not on CPU (eg. it's in the form of WebGL texture or WebGPU buffer), throw error.\n   */\n  readonly data: Tensor.DataTypeMap[T];\n  /**\n   * Get the location of the data.\n   */\n  readonly location: Tensor.DataLocation;\n  /**\n   * Get the WebGL texture that holds the tensor data.\n   *\n   * If the data is not on GPU as WebGL texture, throw error.\n   */\n  readonly texture: Tensor.TextureType;\n  /**\n   * Get the WebGPU buffer that holds the tensor data.\n   *\n   * If the data is not on GPU as WebGPU buffer, throw error.\n   */\n  readonly gpuBuffer: Tensor.GpuBufferType;\n\n  /**\n   * Get the WebNN MLTensor that holds the tensor data.\n   *\n   * If the data is not in a WebNN MLTensor, throw error.\n   */\n  readonly mlTensor: Tensor.MLTensorType;\n\n  /**\n   * Get the buffer data of the tensor.\n   *\n   * If the data is on CPU, returns the data immediately.\n   * If the data is on GPU, downloads the data and returns the promise.\n   *\n   * @param releaseData - whether release the data on GPU. Ignore if data is already on CPU.\n   */\n  getData(releaseData?: boolean): Promise<Tensor.DataTypeMap[T]>;\n\n  /**\n   * Dispose the tensor data.\n   *\n   * If the data is on CPU, remove its internal reference to the underlying data.\n   * If the data is on GPU, release the data on GPU.\n   *\n   * After calling this function, the tensor is considered no longer valid. Its location will be set to 'none'.\n   */\n  dispose(): void;\n}\n\nexport declare namespace Tensor {\n  interface DataTypeMap {\n    float32: Float32Array;\n    uint8: Uint8Array;\n    int8: Int8Array;\n    uint16: Uint16Array;\n    int16: Int16Array;\n    int32: Int32Array;\n    int64: BigInt64Array;\n    string: string[];\n    bool: Uint8Array;\n    float16: Uint16Array; // Keep using Uint16Array until we have a concrete solution for float 16.\n    float64: Float64Array;\n    uint32: Uint32Array;\n    uint64: BigUint64Array;\n    // complex64: never;\n    // complex128: never;\n    // bfloat16: never;\n    uint4: Uint8Array;\n    int4: Int8Array;\n  }\n\n  interface ElementTypeMap {\n    float32: number;\n    uint8: number;\n    int8: number;\n    uint16: number;\n    int16: number;\n    int32: number;\n    int64: bigint;\n    string: string;\n    bool: boolean;\n    float16: number; // Keep using Uint16Array until we have a concrete solution for float 16.\n    float64: number;\n    uint32: number;\n    uint64: bigint;\n    // complex64: never;\n    // complex128: never;\n    // bfloat16: never;\n    uint4: number;\n    int4: number;\n  }\n\n  type DataType = DataTypeMap[Type];\n  type ElementType = ElementTypeMap[Type];\n\n  /**\n   * supported data types for constructing a tensor from a pinned CPU buffer\n   */\n  export type CpuPinnedDataTypes = Exclude<Tensor.Type, 'string'>;\n\n  /**\n   * type alias for WebGL texture\n   */\n  export type TextureType = WebGLTexture;\n\n  /**\n   * supported data types for constructing a tensor from a WebGL texture\n   */\n  export type TextureDataTypes = 'float32';\n\n  /**\n   * type alias for WebGPU buffer\n   *\n   * The reason why we don't use type \"GPUBuffer\" defined in webgpu.d.ts from @webgpu/types is because \"@webgpu/types\"\n   * requires \"@types/dom-webcodecs\" as peer dependency when using TypeScript < v5.1 and its version need to be chosen\n   * carefully according to the TypeScript version being used. This means so far there is not a way to keep every\n   * TypeScript version happy. It turns out that we will easily broke users on some TypeScript version.\n   *\n   * for more info see https://github.com/gpuweb/types/issues/127\n   */\n  export type GpuBufferType = { size: number; mapState: 'unmapped' | 'pending' | 'mapped' };\n\n  /**\n   * type alias for WebNN MLTensor\n   *\n   * The specification for WebNN's MLTensor is currently in flux.\n   */\n  export type MLTensorType = unknown;\n\n  /**\n   * supported data types for constructing a tensor from a WebGPU buffer\n   */\n  export type GpuBufferDataTypes = 'float32' | 'float16' | 'int32' | 'int64' | 'uint32' | 'uint8' | 'bool';\n\n  /**\n   * supported data types for constructing a tensor from a WebNN MLTensor\n   */\n  export type MLTensorDataTypes =\n    | 'float32'\n    | 'float16'\n    | 'int8'\n    | 'uint8'\n    | 'int32'\n    | 'uint32'\n    | 'int64'\n    | 'uint64'\n    | 'bool';\n\n  /**\n   * represent where the tensor data is stored\n   */\n  export type DataLocation = 'none' | 'cpu' | 'cpu-pinned' | 'texture' | 'gpu-buffer' | 'ml-tensor';\n\n  /**\n   * represent the data type of a tensor\n   */\n  export type Type = keyof DataTypeMap;\n}\n\n/**\n * Represent multi-dimensional arrays to feed to or fetch from model inferencing.\n */\nexport interface TypedTensor<T extends Tensor.Type> extends TypedTensorBase<T>, TypedTensorUtils<T> {}\n/**\n * Represent multi-dimensional arrays to feed to or fetch from model inferencing.\n */\nexport interface Tensor extends TypedTensorBase<Tensor.Type>, TypedTensorUtils<Tensor.Type> {}\n\n/**\n * type TensorConstructor defines the constructors of 'Tensor' to create CPU tensor instances.\n */\nexport interface TensorConstructor extends TensorFactory {\n  // #region CPU tensor - specify element type\n  /**\n   * Construct a new string tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (\n    type: 'string',\n    data: Tensor.DataTypeMap['string'] | readonly string[],\n    dims?: readonly number[],\n  ): TypedTensor<'string'>;\n\n  /**\n   * Construct a new bool tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (\n    type: 'bool',\n    data: Tensor.DataTypeMap['bool'] | readonly boolean[],\n    dims?: readonly number[],\n  ): TypedTensor<'bool'>;\n\n  /**\n   * Construct a new uint8 tensor object from a Uint8ClampedArray, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (type: 'uint8', data: Uint8ClampedArray, dims?: readonly number[]): TypedTensor<'uint8'>;\n\n  /**\n   * Construct a new 64-bit integer typed tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new <T extends 'uint64' | 'int64'>(\n    type: T,\n    data: Tensor.DataTypeMap[T] | readonly bigint[] | readonly number[],\n    dims?: readonly number[],\n  ): TypedTensor<T>;\n\n  /**\n   * Construct a new numeric tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new <T extends Exclude<Tensor.Type, 'string' | 'bool' | 'uint64' | 'int64'>>(\n    type: T,\n    data: Tensor.DataTypeMap[T] | readonly number[],\n    dims?: readonly number[],\n  ): TypedTensor<T>;\n  // #endregion\n\n  // #region CPU tensor - infer element types\n\n  /**\n   * Construct a new float32 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Float32Array, dims?: readonly number[]): TypedTensor<'float32'>;\n\n  /**\n   * Construct a new int8 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Int8Array, dims?: readonly number[]): TypedTensor<'int8'>;\n\n  /**\n   * Construct a new uint8 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Uint8Array, dims?: readonly number[]): TypedTensor<'uint8'>;\n\n  /**\n   * Construct a new uint8 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Uint8ClampedArray, dims?: readonly number[]): TypedTensor<'uint8'>;\n\n  /**\n   * Construct a new uint16 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Uint16Array, dims?: readonly number[]): TypedTensor<'uint16'>;\n\n  /**\n   * Construct a new int16 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Int16Array, dims?: readonly number[]): TypedTensor<'int16'>;\n\n  /**\n   * Construct a new int32 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Int32Array, dims?: readonly number[]): TypedTensor<'int32'>;\n\n  /**\n   * Construct a new int64 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: BigInt64Array, dims?: readonly number[]): TypedTensor<'int64'>;\n\n  /**\n   * Construct a new string tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: readonly string[], dims?: readonly number[]): TypedTensor<'string'>;\n\n  /**\n   * Construct a new bool tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: readonly boolean[], dims?: readonly number[]): TypedTensor<'bool'>;\n\n  /**\n   * Construct a new float64 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Float64Array, dims?: readonly number[]): TypedTensor<'float64'>;\n\n  /**\n   * Construct a new uint32 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Uint32Array, dims?: readonly number[]): TypedTensor<'uint32'>;\n\n  /**\n   * Construct a new uint64 tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: BigUint64Array, dims?: readonly number[]): TypedTensor<'uint64'>;\n\n  // #endregion\n\n  // #region CPU tensor - fall back to non-generic tensor type declaration\n\n  /**\n   * Construct a new tensor object from the given type, data and dims.\n   *\n   * @param type - Specify the element type.\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (\n    type: Tensor.Type,\n    data: Tensor.DataType | readonly number[] | readonly string[] | readonly bigint[] | readonly boolean[],\n    dims?: readonly number[],\n  ): Tensor;\n\n  /**\n   * Construct a new tensor object from the given data and dims.\n   *\n   * @param data - Specify the CPU tensor data.\n   * @param dims - Specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   */\n  new (data: Tensor.DataType, dims?: readonly number[]): Tensor;\n  // #endregion\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Tensor = TensorImpl as TensorConstructor;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env } from './env-impl.js';\n\n/**\n * @ignore\n */\nexport const TRACE = (deviceType: string, label: string) => {\n  if (typeof env.trace === 'undefined' ? !env.wasm.trace : !env.trace) {\n    return;\n  }\n  // eslint-disable-next-line no-console\n  console.timeStamp(`${deviceType}::ORT::${label}`);\n};\n\nconst TRACE_FUNC = (msg: string, extraMsg?: string) => {\n  const stack = new Error().stack?.split(/\\r\\n|\\r|\\n/g) || [];\n  let hasTraceFunc = false;\n  for (let i = 0; i < stack.length; i++) {\n    if (hasTraceFunc && !stack[i].includes('TRACE_FUNC')) {\n      let label = `FUNC_${msg}::${stack[i].trim().split(' ')[1]}`;\n      if (extraMsg) {\n        label += `::${extraMsg}`;\n      }\n      TRACE('CPU', label);\n      return;\n    }\n    if (stack[i].includes('TRACE_FUNC')) {\n      hasTraceFunc = true;\n    }\n  }\n};\n\n/**\n * @ignore\n */\nexport const TRACE_FUNC_BEGIN = (extraMsg?: string) => {\n  if (typeof env.trace === 'undefined' ? !env.wasm.trace : !env.trace) {\n    return;\n  }\n  TRACE_FUNC('BEGIN', extraMsg);\n};\n\n/**\n * @ignore\n */\nexport const TRACE_FUNC_END = (extraMsg?: string) => {\n  if (typeof env.trace === 'undefined' ? !env.wasm.trace : !env.trace) {\n    return;\n  }\n  TRACE_FUNC('END', extraMsg);\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { resolveBackendAndExecutionProviders } from './backend-impl.js';\nimport { InferenceSessionHandler } from './backend.js';\nimport { InferenceSession as InferenceSessionInterface } from './inference-session.js';\nimport { OnnxValue } from './onnx-value.js';\nimport { Tensor } from './tensor.js';\nimport { TRACE_FUNC_BEGIN, TRACE_FUNC_END } from './trace.js';\n\ntype SessionOptions = InferenceSessionInterface.SessionOptions;\ntype RunOptions = InferenceSessionInterface.RunOptions;\ntype FeedsType = InferenceSessionInterface.FeedsType;\ntype FetchesType = InferenceSessionInterface.FetchesType;\ntype ReturnType = InferenceSessionInterface.ReturnType;\n\nexport class InferenceSession implements InferenceSessionInterface {\n  private constructor(handler: InferenceSessionHandler) {\n    this.handler = handler;\n  }\n  run(feeds: FeedsType, options?: RunOptions): Promise<ReturnType>;\n  run(feeds: FeedsType, fetches: FetchesType, options?: RunOptions): Promise<ReturnType>;\n  async run(feeds: FeedsType, arg1?: FetchesType | RunOptions, arg2?: RunOptions): Promise<ReturnType> {\n    TRACE_FUNC_BEGIN();\n    const fetches: { [name: string]: OnnxValue | null } = {};\n    let options: RunOptions = {};\n    // check inputs\n    if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\n      throw new TypeError(\n        \"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\",\n      );\n    }\n\n    let isFetchesEmpty = true;\n    // determine which override is being used\n    if (typeof arg1 === 'object') {\n      if (arg1 === null) {\n        throw new TypeError('Unexpected argument[1]: cannot be null.');\n      }\n      if (arg1 instanceof Tensor) {\n        throw new TypeError(\"'fetches' cannot be a Tensor\");\n      }\n\n      if (Array.isArray(arg1)) {\n        if (arg1.length === 0) {\n          throw new TypeError(\"'fetches' cannot be an empty array.\");\n        }\n        isFetchesEmpty = false;\n        // output names\n        for (const name of arg1) {\n          if (typeof name !== 'string') {\n            throw new TypeError(\"'fetches' must be a string array or an object.\");\n          }\n          if (this.outputNames.indexOf(name) === -1) {\n            throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n          }\n          fetches[name] = null;\n        }\n\n        if (typeof arg2 === 'object' && arg2 !== null) {\n          options = arg2;\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError(\"'options' must be an object.\");\n        }\n      } else {\n        // decide whether arg1 is fetches or options\n        // if any output name is present and its value is valid OnnxValue, we consider it fetches\n        let isFetches = false;\n        const arg1Keys = Object.getOwnPropertyNames(arg1);\n        for (const name of this.outputNames) {\n          if (arg1Keys.indexOf(name) !== -1) {\n            const v = (arg1 as InferenceSessionInterface.NullableOnnxValueMapType)[name];\n            if (v === null || v instanceof Tensor) {\n              isFetches = true;\n              isFetchesEmpty = false;\n              fetches[name] = v;\n            }\n          }\n        }\n\n        if (isFetches) {\n          if (typeof arg2 === 'object' && arg2 !== null) {\n            options = arg2;\n          } else if (typeof arg2 !== 'undefined') {\n            throw new TypeError(\"'options' must be an object.\");\n          }\n        } else {\n          options = arg1 as RunOptions;\n        }\n      }\n    } else if (typeof arg1 !== 'undefined') {\n      throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n    }\n\n    // check if all inputs are in feed\n    for (const name of this.inputNames) {\n      if (typeof feeds[name] === 'undefined') {\n        throw new Error(`input '${name}' is missing in 'feeds'.`);\n      }\n    }\n\n    // if no fetches is specified, we use the full output names list\n    if (isFetchesEmpty) {\n      for (const name of this.outputNames) {\n        fetches[name] = null;\n      }\n    }\n\n    // feeds, fetches and options are prepared\n\n    const results = await this.handler.run(feeds, fetches, options);\n    const returnValue: { [name: string]: OnnxValue } = {};\n    for (const key in results) {\n      if (Object.hasOwnProperty.call(results, key)) {\n        const result = results[key];\n        if (result instanceof Tensor) {\n          returnValue[key] = result;\n        } else {\n          returnValue[key] = new Tensor(result.type, result.data, result.dims);\n        }\n      }\n    }\n    TRACE_FUNC_END();\n    return returnValue;\n  }\n\n  async release(): Promise<void> {\n    return this.handler.dispose();\n  }\n\n  static create(path: string, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static create(buffer: ArrayBufferLike, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static create(\n    buffer: ArrayBufferLike,\n    byteOffset: number,\n    byteLength?: number,\n    options?: SessionOptions,\n  ): Promise<InferenceSessionInterface>;\n  static create(buffer: Uint8Array, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static async create(\n    arg0: string | ArrayBufferLike | Uint8Array,\n    arg1?: SessionOptions | number,\n    arg2?: number,\n    arg3?: SessionOptions,\n  ): Promise<InferenceSessionInterface> {\n    TRACE_FUNC_BEGIN();\n    // either load from a file or buffer\n    let filePathOrUint8Array: string | Uint8Array;\n    let options: SessionOptions = {};\n\n    if (typeof arg0 === 'string') {\n      filePathOrUint8Array = arg0;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError(\"'options' must be an object.\");\n      }\n    } else if (arg0 instanceof Uint8Array) {\n      filePathOrUint8Array = arg0;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError(\"'options' must be an object.\");\n      }\n    } else if (\n      arg0 instanceof ArrayBuffer ||\n      (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)\n    ) {\n      const buffer = arg0;\n      let byteOffset = 0;\n      let byteLength = arg0.byteLength;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 === 'number') {\n        byteOffset = arg1;\n        if (!Number.isSafeInteger(byteOffset)) {\n          throw new RangeError(\"'byteOffset' must be an integer.\");\n        }\n        if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n          throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n        }\n        byteLength = arg0.byteLength - byteOffset;\n        if (typeof arg2 === 'number') {\n          byteLength = arg2;\n          if (!Number.isSafeInteger(byteLength)) {\n            throw new RangeError(\"'byteLength' must be an integer.\");\n          }\n          if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n            throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n          }\n          if (typeof arg3 === 'object' && arg3 !== null) {\n            options = arg3;\n          } else if (typeof arg3 !== 'undefined') {\n            throw new TypeError(\"'options' must be an object.\");\n          }\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError(\"'byteLength' must be a number.\");\n        }\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError(\"'options' must be an object.\");\n      }\n      filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n    } else {\n      throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n    }\n\n    // resolve backend, update session options with validated EPs, and create session handler\n    const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);\n    const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);\n    TRACE_FUNC_END();\n    return new InferenceSession(handler);\n  }\n\n  startProfiling(): void {\n    this.handler.startProfiling();\n  }\n  endProfiling(): void {\n    this.handler.endProfiling();\n  }\n\n  get inputNames(): readonly string[] {\n    return this.handler.inputNames;\n  }\n  get outputNames(): readonly string[] {\n    return this.handler.outputNames;\n  }\n\n  private handler: InferenceSessionHandler;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession as InferenceSessionImpl } from './inference-session-impl.js';\nimport { OnnxModelOptions } from './onnx-model.js';\nimport { OnnxValue, OnnxValueDataLocation } from './onnx-value.js';\n\n/* eslint-disable @typescript-eslint/no-redeclare */\n\nexport declare namespace InferenceSession {\n  // #region input/output types\n\n  type OnnxValueMapType = { readonly [name: string]: OnnxValue };\n  type NullableOnnxValueMapType = { readonly [name: string]: OnnxValue | null };\n\n  /**\n   * A feeds (model inputs) is an object that uses input names as keys and OnnxValue as corresponding values.\n   */\n  type FeedsType = OnnxValueMapType;\n\n  /**\n   * A fetches (model outputs) could be one of the following:\n   *\n   * - Omitted. Use model's output names definition.\n   * - An array of string indicating the output names.\n   * - An object that use output names as keys and OnnxValue or null as corresponding values.\n   *\n   * @remark\n   * different from input argument, in output, OnnxValue is optional. If an OnnxValue is present it will be\n   * used as a pre-allocated value by the inference engine; if omitted, inference engine will allocate buffer\n   * internally.\n   */\n  type FetchesType = readonly string[] | NullableOnnxValueMapType;\n\n  /**\n   * A inferencing return type is an object that uses output names as keys and OnnxValue as corresponding values.\n   */\n  type ReturnType = OnnxValueMapType;\n\n  // #endregion\n\n  // #region session options\n\n  /**\n   * A set of configurations for session behavior.\n   */\n  export interface SessionOptions extends OnnxModelOptions {\n    /**\n     * An array of execution provider options.\n     *\n     * An execution provider option can be a string indicating the name of the execution provider,\n     * or an object of corresponding type.\n     */\n    executionProviders?: readonly ExecutionProviderConfig[];\n\n    /**\n     * The intra OP threads number.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native).\n     */\n    intraOpNumThreads?: number;\n\n    /**\n     * The inter OP threads number.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native).\n     */\n    interOpNumThreads?: number;\n\n    /**\n     * The free dimension override.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    freeDimensionOverrides?: { readonly [dimensionName: string]: number };\n\n    /**\n     * The optimization level.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    graphOptimizationLevel?: 'disabled' | 'basic' | 'extended' | 'all';\n\n    /**\n     * Whether enable CPU memory arena.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    enableCpuMemArena?: boolean;\n\n    /**\n     * Whether enable memory pattern.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    enableMemPattern?: boolean;\n\n    /**\n     * Execution mode.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    executionMode?: 'sequential' | 'parallel';\n\n    /**\n     * Optimized model file path.\n     *\n     * If this setting is specified, the optimized model will be dumped. In browser, a blob will be created\n     * with a pop-up window.\n     */\n    optimizedModelFilePath?: string;\n\n    /**\n     * Whether enable profiling.\n     *\n     * This setting is a placeholder for a future use.\n     */\n    enableProfiling?: boolean;\n\n    /**\n     * File prefix for profiling.\n     *\n     * This setting is a placeholder for a future use.\n     */\n    profileFilePrefix?: string;\n\n    /**\n     * Log ID.\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    logId?: string;\n\n    /**\n     * Log severity level. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/common/logging/severity.h\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    logSeverityLevel?: 0 | 1 | 2 | 3 | 4;\n\n    /**\n     * Log verbosity level.\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     */\n    logVerbosityLevel?: number;\n\n    /**\n     * Specify string as a preferred data location for all outputs, or an object that use output names as keys and a\n     * preferred data location as corresponding values.\n     *\n     * This setting is available only in ONNXRuntime Web for WebGL and WebGPU EP.\n     */\n    preferredOutputLocation?: OnnxValueDataLocation | { readonly [outputName: string]: OnnxValueDataLocation };\n\n    /**\n     * Whether enable graph capture.\n     * This setting is available only in ONNXRuntime Web for WebGPU EP.\n     */\n    enableGraphCapture?: boolean;\n\n    /**\n     * Store configurations for a session. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/session/\n     * onnxruntime_session_options_config_keys.h\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     *\n     * @example\n     * ```js\n     * extra: {\n     *   session: {\n     *     set_denormal_as_zero: \"1\",\n     *     disable_prepacking: \"1\"\n     *   },\n     *   optimization: {\n     *     enable_gelu_approximation: \"1\"\n     *   }\n     * }\n     * ```\n     */\n    extra?: Record<string, unknown>;\n  }\n\n  // #region execution providers\n\n  // Currently, we have the following backends to support execution providers:\n  // Backend Node.js binding: supports 'cpu', 'dml' (win32), 'coreml' (macOS) and 'cuda' (linux).\n  // Backend WebAssembly: supports 'cpu', 'wasm', 'webgpu' and 'webnn'.\n  // Backend ONNX.js: supports 'webgl'.\n  // Backend React Native: supports 'cpu', 'xnnpack', 'coreml' (iOS), 'nnapi' (Android).\n  interface ExecutionProviderOptionMap {\n    coreml: CoreMLExecutionProviderOption;\n    cpu: CpuExecutionProviderOption;\n    cuda: CudaExecutionProviderOption;\n    dml: DmlExecutionProviderOption;\n    nnapi: NnapiExecutionProviderOption;\n    tensorrt: TensorRtExecutionProviderOption;\n    wasm: WebAssemblyExecutionProviderOption;\n    webgl: WebGLExecutionProviderOption;\n    webgpu: WebGpuExecutionProviderOption;\n    webnn: WebNNExecutionProviderOption;\n    qnn: QnnExecutionProviderOption;\n    xnnpack: XnnpackExecutionProviderOption;\n  }\n\n  type ExecutionProviderName = keyof ExecutionProviderOptionMap;\n  type ExecutionProviderConfig =\n    | ExecutionProviderOptionMap[ExecutionProviderName]\n    | ExecutionProviderOption\n    | ExecutionProviderName\n    | string;\n\n  export interface ExecutionProviderOption {\n    readonly name: string;\n  }\n  export interface CpuExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'cpu';\n    useArena?: boolean;\n  }\n  export interface CudaExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'cuda';\n    deviceId?: number;\n  }\n  export interface DmlExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'dml';\n    deviceId?: number;\n  }\n  export interface TensorRtExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'tensorrt';\n    deviceId?: number;\n  }\n  export interface WebAssemblyExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'wasm';\n  }\n  export interface WebGLExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'webgl';\n    // TODO: add flags\n  }\n  export interface XnnpackExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'xnnpack';\n  }\n  export interface WebGpuExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'webgpu';\n    preferredLayout?: 'NCHW' | 'NHWC';\n  }\n\n  // #region WebNN options\n\n  interface WebNNExecutionProviderName extends ExecutionProviderOption {\n    readonly name: 'webnn';\n  }\n\n  /**\n   * Represents a set of options for creating a WebNN MLContext.\n   *\n   * @see https://www.w3.org/TR/webnn/#dictdef-mlcontextoptions\n   */\n  export interface WebNNContextOptions {\n    deviceType?: 'cpu' | 'gpu' | 'npu';\n    numThreads?: number;\n    powerPreference?: 'default' | 'low-power' | 'high-performance';\n  }\n\n  /**\n   * Represents a set of options for WebNN execution provider without MLContext.\n   */\n  export interface WebNNOptionsWithoutMLContext extends WebNNExecutionProviderName, WebNNContextOptions {\n    context?: never;\n  }\n\n  /**\n   * Represents a set of options for WebNN execution provider with MLContext.\n   *\n   * When MLContext is provided, the deviceType is also required so that the WebNN EP can determine the preferred\n   * channel layout.\n   *\n   * @see https://www.w3.org/TR/webnn/#dom-ml-createcontext\n   */\n  export interface WebNNOptionsWithMLContext\n    extends WebNNExecutionProviderName,\n      Omit<WebNNContextOptions, 'deviceType'>,\n      Required<Pick<WebNNContextOptions, 'deviceType'>> {\n    context: unknown /* MLContext */;\n  }\n\n  /**\n   * Represents a set of options for WebNN execution provider with MLContext which is created from GPUDevice.\n   *\n   * @see https://www.w3.org/TR/webnn/#dom-ml-createcontext-gpudevice\n   */\n  export interface WebNNOptionsWebGpu extends WebNNExecutionProviderName {\n    context: unknown /* MLContext */;\n    gpuDevice: unknown /* GPUDevice */;\n  }\n\n  /**\n   * Options for WebNN execution provider.\n   */\n  export type WebNNExecutionProviderOption =\n    | WebNNOptionsWithoutMLContext\n    | WebNNOptionsWithMLContext\n    | WebNNOptionsWebGpu;\n\n  // #endregion\n\n  export interface QnnExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'qnn';\n    // TODO add flags\n  }\n  export interface CoreMLExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'coreml';\n    /**\n     * The bit flags for CoreML execution provider.\n     *\n     * ```\n     * COREML_FLAG_USE_CPU_ONLY = 0x001\n     * COREML_FLAG_ENABLE_ON_SUBGRAPH = 0x002\n     * COREML_FLAG_ONLY_ENABLE_DEVICE_WITH_ANE = 0x004\n     * COREML_FLAG_ONLY_ALLOW_STATIC_INPUT_SHAPES = 0x008\n     * COREML_FLAG_CREATE_MLPROGRAM = 0x010\n     * COREML_FLAG_USE_CPU_AND_GPU = 0x020\n     * ```\n     *\n     * See include/onnxruntime/core/providers/coreml/coreml_provider_factory.h for more details.\n     *\n     * This flag is available only in ONNXRuntime (Node.js binding).\n     */\n    coreMlFlags?: number;\n    /**\n     * Specify whether to use CPU only in CoreML EP.\n     *\n     * This setting is available only in ONNXRuntime (react-native).\n     */\n    useCPUOnly?: boolean;\n    useCPUAndGPU?: boolean;\n    /**\n     * Specify whether to enable CoreML EP on subgraph.\n     *\n     * This setting is available only in ONNXRuntime (react-native).\n     */\n    enableOnSubgraph?: boolean;\n    /**\n     * Specify whether to only enable CoreML EP for Apple devices with ANE (Apple Neural Engine).\n     *\n     * This setting is available only in ONNXRuntime (react-native).\n     */\n    onlyEnableDeviceWithANE?: boolean;\n  }\n  export interface NnapiExecutionProviderOption extends ExecutionProviderOption {\n    readonly name: 'nnapi';\n    useFP16?: boolean;\n    useNCHW?: boolean;\n    cpuDisabled?: boolean;\n    cpuOnly?: boolean;\n  }\n  // #endregion\n\n  // #endregion\n\n  // #region run options\n\n  /**\n   * A set of configurations for inference run behavior\n   */\n  export interface RunOptions {\n    /**\n     * Log severity level. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/common/logging/severity.h\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    logSeverityLevel?: 0 | 1 | 2 | 3 | 4;\n\n    /**\n     * Log verbosity level.\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     */\n    logVerbosityLevel?: number;\n\n    /**\n     * Terminate all incomplete OrtRun calls as soon as possible if true\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     */\n    terminate?: boolean;\n\n    /**\n     * A tag for the Run() calls using this\n     *\n     * This setting is available only in ONNXRuntime (Node.js binding and react-native) or WebAssembly backend\n     */\n    tag?: string;\n\n    /**\n     * Set a single run configuration entry. See\n     * https://github.com/microsoft/onnxruntime/blob/main/include/onnxruntime/core/session/\n     * onnxruntime_run_options_config_keys.h\n     *\n     * This setting is available only in WebAssembly backend. Will support Node.js binding and react-native later\n     *\n     * @example\n     *\n     * ```js\n     * extra: {\n     *   memory: {\n     *     enable_memory_arena_shrinkage: \"1\",\n     *   }\n     * }\n     * ```\n     */\n    extra?: Record<string, unknown>;\n  }\n\n  // #endregion\n\n  // #region value metadata\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface ValueMetadata {\n    // TBD\n  }\n\n  // #endregion\n}\n\n/**\n * Represent a runtime instance of an ONNX model.\n */\nexport interface InferenceSession {\n  // #region run()\n\n  /**\n   * Execute the model asynchronously with the given feeds and options.\n   *\n   * @param feeds - Representation of the model input. See type description of `InferenceSession.InputType` for detail.\n   * @param options - Optional. A set of options that controls the behavior of model inference.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding values.\n   */\n  run(feeds: InferenceSession.FeedsType, options?: InferenceSession.RunOptions): Promise<InferenceSession.ReturnType>;\n\n  /**\n   * Execute the model asynchronously with the given feeds, fetches and options.\n   *\n   * @param feeds - Representation of the model input. See type description of `InferenceSession.InputType` for detail.\n   * @param fetches - Representation of the model output. See type description of `InferenceSession.OutputType` for\n   * detail.\n   * @param options - Optional. A set of options that controls the behavior of model inference.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding values.\n   */\n  run(\n    feeds: InferenceSession.FeedsType,\n    fetches: InferenceSession.FetchesType,\n    options?: InferenceSession.RunOptions,\n  ): Promise<InferenceSession.ReturnType>;\n\n  // #endregion\n\n  // #region release()\n\n  /**\n   * Release the inference session and the underlying resources.\n   */\n  release(): Promise<void>;\n\n  // #endregion\n\n  // #region profiling\n\n  /**\n   * Start profiling.\n   */\n  startProfiling(): void;\n\n  /**\n   * End profiling.\n   */\n  endProfiling(): void;\n\n  // #endregion\n\n  // #region metadata\n\n  /**\n   * Get input names of the loaded model.\n   */\n  readonly inputNames: readonly string[];\n\n  /**\n   * Get output names of the loaded model.\n   */\n  readonly outputNames: readonly string[];\n\n  // /**\n  //  * Get input metadata of the loaded model.\n  //  */\n  // readonly inputMetadata: ReadonlyArray<Readonly<InferenceSession.ValueMetadata>>;\n\n  // /**\n  //  * Get output metadata of the loaded model.\n  //  */\n  // readonly outputMetadata: ReadonlyArray<Readonly<InferenceSession.ValueMetadata>>;\n\n  // #endregion\n}\n\nexport interface InferenceSessionFactory {\n  // #region create()\n\n  /**\n   * Create a new inference session and load model asynchronously from an ONNX model file.\n   *\n   * @param uri - The URI or file path of the model to load.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(uri: string, options?: InferenceSession.SessionOptions): Promise<InferenceSession>;\n\n  /**\n   * Create a new inference session and load model asynchronously from an array bufer.\n   *\n   * @param buffer - An ArrayBuffer representation of an ONNX model.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(buffer: ArrayBufferLike, options?: InferenceSession.SessionOptions): Promise<InferenceSession>;\n\n  /**\n   * Create a new inference session and load model asynchronously from segment of an array bufer.\n   *\n   * @param buffer - An ArrayBuffer representation of an ONNX model.\n   * @param byteOffset - The beginning of the specified portion of the array buffer.\n   * @param byteLength - The length in bytes of the array buffer.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(\n    buffer: ArrayBufferLike,\n    byteOffset: number,\n    byteLength?: number,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSession>;\n\n  /**\n   * Create a new inference session and load model asynchronously from a Uint8Array.\n   *\n   * @param buffer - A Uint8Array representation of an ONNX model.\n   * @param options - specify configuration for creating a new inference session.\n   * @returns A promise that resolves to an InferenceSession object.\n   */\n  create(buffer: Uint8Array, options?: InferenceSession.SessionOptions): Promise<InferenceSession>;\n\n  // #endregion\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const InferenceSession: InferenceSessionFactory = InferenceSessionImpl;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { OptionsFormat, OptionsNormalizationParameters, OptionsTensorLayout } from './tensor-factory.js';\n\nexport interface TensorToDataUrlOptions extends OptionsTensorLayout, OptionsFormat, OptionsNormalizationParameters {}\n\nexport interface TensorToImageDataOptions extends OptionsTensorLayout, OptionsFormat, OptionsNormalizationParameters {}\n\nexport interface ConversionUtils {\n  /**\n   * creates a DataURL instance from tensor\n   *\n   * @param options - An optional object representing options for creating a DataURL instance from the tensor.\n   *\n   * The following default settings will be applied:\n   * - `format`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * @returns a DataURL string representing the image converted from tensor data\n   */\n  toDataURL(options?: TensorToDataUrlOptions): string;\n\n  /**\n   * creates an ImageData instance from tensor\n   *\n   * @param options - An optional object representing options for creating an ImageData instance from the tensor.\n   *\n   * The following default settings will be applied:\n   * - `format`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * @returns an ImageData instance representing the image converted from tensor data\n   */\n  toImageData(options?: TensorToImageDataOptions): ImageData;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor, TypedTensor } from './tensor.js';\n\nexport type ImageFormat = 'RGB' | 'RGBA' | 'BGR' | 'RBG';\nexport type ImageTensorLayout = 'NHWC' | 'NCHW';\n\n// the following region contains type definitions for constructing tensor from a specific location.\n\n// #region types for constructing a tensor from a specific location\n\n/**\n * represent common properties of the parameter for constructing a tensor from a specific location.\n */\ninterface CommonConstructorParameters<T> extends Pick<Tensor, 'dims'> {\n  /**\n   * Specify the data type of the tensor.\n   */\n  readonly type: T;\n}\n\n/**\n * represent the parameter for constructing a tensor from a GPU resource.\n */\ninterface GpuResourceConstructorParameters<T extends Tensor.Type> {\n  /**\n   * an optional callback function to download data from GPU to CPU.\n   *\n   * If not provided, the tensor treat the GPU data as external resource.\n   */\n  download?(): Promise<Tensor.DataTypeMap[T]>;\n\n  /**\n   * an optional callback function that will be called when the tensor is disposed.\n   *\n   * If not provided, the tensor treat the GPU data as external resource.\n   */\n  dispose?(): void;\n}\n\n/**\n * represent the parameter for constructing a tensor from a pinned CPU buffer\n */\nexport interface CpuPinnedConstructorParameters<T extends Tensor.CpuPinnedDataTypes = Tensor.CpuPinnedDataTypes>\n  extends CommonConstructorParameters<T> {\n  /**\n   * Specify the location of the data to be 'cpu-pinned'.\n   */\n  readonly location: 'cpu-pinned';\n  /**\n   * Specify the CPU pinned buffer that holds the tensor data.\n   */\n  readonly data: Tensor.DataTypeMap[T];\n}\n\n/**\n * represent the parameter for constructing a tensor from a WebGL texture\n */\nexport interface TextureConstructorParameters<T extends Tensor.TextureDataTypes = Tensor.TextureDataTypes>\n  extends CommonConstructorParameters<T>,\n    GpuResourceConstructorParameters<T> {\n  /**\n   * Specify the location of the data to be 'texture'.\n   */\n  readonly location: 'texture';\n  /**\n   * Specify the WebGL texture that holds the tensor data.\n   */\n  readonly texture: Tensor.TextureType;\n}\n\n/**\n * represent the parameter for constructing a tensor from a WebGPU buffer\n */\nexport interface GpuBufferConstructorParameters<T extends Tensor.GpuBufferDataTypes = Tensor.GpuBufferDataTypes>\n  extends CommonConstructorParameters<T>,\n    GpuResourceConstructorParameters<T> {\n  /**\n   * Specify the location of the data to be 'gpu-buffer'.\n   */\n  readonly location: 'gpu-buffer';\n  /**\n   * Specify the WebGPU buffer that holds the tensor data.\n   */\n  readonly gpuBuffer: Tensor.GpuBufferType;\n}\n\nexport interface MLTensorConstructorParameters<T extends Tensor.MLTensorDataTypes = Tensor.MLTensorDataTypes>\n  extends CommonConstructorParameters<T>,\n    GpuResourceConstructorParameters<T> {\n  /**\n   * Specify the location of the data to be 'ml-tensor'.\n   */\n  readonly location: 'ml-tensor';\n\n  /**\n   * Specify the WebNN MLTensor that holds the tensor data.\n   */\n  readonly mlTensor: Tensor.MLTensorType;\n}\n\n// #endregion\n\n// the following region contains type definitions of each individual options.\n// the tensor factory functions use a composition of those options as the parameter type.\n\n// #region Options fields\n\nexport interface OptionsFormat {\n  /**\n   * Describes the image format represented in RGBA color space.\n   */\n  format?: ImageFormat;\n}\n\nexport interface OptionsTensorFormat {\n  /**\n   * Describes the image format of the tensor.\n   *\n   * NOTE: this is different from option 'format'. While option 'format' represents the original image, 'tensorFormat'\n   * represents the target format of the tensor. A transpose will be performed if they are different.\n   */\n  tensorFormat?: ImageFormat;\n}\n\nexport interface OptionsTensorDataType {\n  /**\n   * Describes the data type of the tensor.\n   */\n  dataType?: 'float32' | 'uint8';\n}\n\nexport interface OptionsTensorLayout {\n  /**\n   * Describes the tensor layout when representing data of one or more image(s).\n   */\n  tensorLayout?: ImageTensorLayout;\n}\n\nexport interface OptionsDimensions {\n  /**\n   * Describes the image height in pixel\n   */\n  height?: number;\n  /**\n   * Describes the image width in pixel\n   */\n  width?: number;\n}\n\nexport interface OptionResizedDimensions {\n  /**\n   * Describes the resized height. If omitted, original height will be used.\n   */\n  resizedHeight?: number;\n  /**\n   * Describes resized width - can be accessed via tensor dimensions as well\n   */\n  resizedWidth?: number;\n}\n\nexport interface OptionsNormalizationParameters {\n  /**\n   * Describes normalization parameters when preprocessing the image as model input.\n   *\n   * Data element are ranged from 0 to 255.\n   */\n  norm?: {\n    /**\n     * The 'bias' value for image normalization.\n     * - If omitted, use default value 0.\n     * - If it's a single number, apply to each channel\n     * - If it's an array of 3 or 4 numbers, apply element-wise. Number of elements need to match the number of channels\n     * for the corresponding image format\n     */\n    bias?: number | [number, number, number] | [number, number, number, number];\n    /**\n     * The 'mean' value for image normalization.\n     * - If omitted, use default value 255.\n     * - If it's a single number, apply to each channel\n     * - If it's an array of 3 or 4 numbers, apply element-wise. Number of elements need to match the number of channels\n     * for the corresponding image format\n     */\n    mean?: number | [number, number, number] | [number, number, number, number];\n  };\n}\n\n// #endregion\n\n// #region Options composition\n\nexport interface TensorFromImageDataOptions\n  extends OptionResizedDimensions,\n    OptionsTensorFormat,\n    OptionsTensorLayout,\n    OptionsTensorDataType,\n    OptionsNormalizationParameters {}\n\nexport interface TensorFromImageElementOptions\n  extends OptionResizedDimensions,\n    OptionsTensorFormat,\n    OptionsTensorLayout,\n    OptionsTensorDataType,\n    OptionsNormalizationParameters {}\n\nexport interface TensorFromUrlOptions\n  extends OptionsDimensions,\n    OptionResizedDimensions,\n    OptionsTensorFormat,\n    OptionsTensorLayout,\n    OptionsTensorDataType,\n    OptionsNormalizationParameters {}\n\nexport interface TensorFromImageBitmapOptions\n  extends OptionResizedDimensions,\n    OptionsTensorFormat,\n    OptionsTensorLayout,\n    OptionsTensorDataType,\n    OptionsNormalizationParameters {}\n\nexport interface TensorFromTextureOptions<T extends Tensor.TextureDataTypes>\n  extends Required<OptionsDimensions>,\n    OptionsFormat,\n    GpuResourceConstructorParameters<T> /* TODO: add more */ {}\n\nexport interface TensorFromGpuBufferOptions<T extends Tensor.GpuBufferDataTypes>\n  extends Pick<Tensor, 'dims'>,\n    GpuResourceConstructorParameters<T> {\n  /**\n   * Describes the data type of the tensor.\n   */\n  dataType?: T;\n}\n\nexport interface TensorFromMLTensorOptions<T extends Tensor.MLTensorDataTypes>\n  extends Pick<Tensor, 'dims'>,\n    GpuResourceConstructorParameters<T> {\n  /**\n   * Describes the data type of the tensor.\n   */\n  dataType?: T;\n}\n\n// #endregion\n\n/**\n * type TensorFactory defines the factory functions of 'Tensor' to create tensor instances from existing data or\n * resources.\n */\nexport interface TensorFactory {\n  /**\n   * create a tensor from an ImageData object\n   *\n   * @param imageData - the ImageData object to create tensor from\n   * @param options - An optional object representing options for creating tensor from ImageData.\n   *\n   * The following default settings will be applied:\n   * - `tensorFormat`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * - `dataType`: `'float32'`\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(\n    imageData: ImageData,\n    options?: TensorFromImageDataOptions,\n  ): Promise<TypedTensor<'float32'> | TypedTensor<'uint8'>>;\n\n  /**\n   * create a tensor from a HTMLImageElement object\n   *\n   * @param imageElement - the HTMLImageElement object to create tensor from\n   * @param options - An optional object representing options for creating tensor from HTMLImageElement.\n   *\n   * The following default settings will be applied:\n   * - `tensorFormat`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * - `dataType`: `'float32'`\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(\n    imageElement: HTMLImageElement,\n    options?: TensorFromImageElementOptions,\n  ): Promise<TypedTensor<'float32'> | TypedTensor<'uint8'>>;\n\n  /**\n   * create a tensor from URL\n   *\n   * @param urlSource - a string as a URL to the image or a data URL containing the image data.\n   * @param options - An optional object representing options for creating tensor from URL.\n   *\n   * The following default settings will be applied:\n   * - `tensorFormat`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * - `dataType`: `'float32'`\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(urlSource: string, options?: TensorFromUrlOptions): Promise<TypedTensor<'float32'> | TypedTensor<'uint8'>>;\n\n  /**\n   * create a tensor from an ImageBitmap object\n   *\n   * @param bitmap - the ImageBitmap object to create tensor from\n   * @param options - An optional object representing options for creating tensor from URL.\n   *\n   * The following default settings will be applied:\n   * - `tensorFormat`: `'RGB'`\n   * - `tensorLayout`: `'NCHW'`\n   * - `dataType`: `'float32'`\n   * @returns A promise that resolves to a tensor object\n   */\n  fromImage(\n    bitmap: ImageBitmap,\n    options: TensorFromImageBitmapOptions,\n  ): Promise<TypedTensor<'float32'> | TypedTensor<'uint8'>>;\n\n  /**\n   * create a tensor from a WebGL texture\n   *\n   * @param texture - the WebGLTexture object to create tensor from\n   * @param options - An optional object representing options for creating tensor from WebGL texture.\n   *\n   * The options include following properties:\n   * - `width`: the width of the texture. Required.\n   * - `height`: the height of the texture. Required.\n   * - `format`: the format of the texture. If omitted, assume 'RGBA'.\n   * - `download`: an optional function to download the tensor data from GPU to CPU. If omitted, the GPU data\n   * will not be able to download. Usually, this is provided by a GPU backend for the inference outputs. Users don't\n   * need to provide this function.\n   * - `dispose`: an optional function to dispose the tensor data on GPU. If omitted, the GPU data will not be disposed.\n   * Usually, this is provided by a GPU backend for the inference outputs. Users don't need to provide this function.\n   *\n   * @returns a tensor object\n   */\n  fromTexture<T extends Tensor.TextureDataTypes = 'float32'>(\n    texture: Tensor.TextureType,\n    options: TensorFromTextureOptions<T>,\n  ): TypedTensor<'float32'>;\n\n  /**\n   * create a tensor from a WebGPU buffer\n   *\n   * @param buffer - the GPUBuffer object to create tensor from\n   * @param options - An optional object representing options for creating tensor from WebGPU buffer.\n   *\n   * The options include following properties:\n   * - `dataType`: the data type of the tensor. If omitted, assume 'float32'.\n   * - `dims`: the dimension of the tensor. Required.\n   * - `download`: an optional function to download the tensor data from GPU to CPU. If omitted, the GPU data\n   * will not be able to download. Usually, this is provided by a GPU backend for the inference outputs. Users don't\n   * need to provide this function.\n   * - `dispose`: an optional function to dispose the tensor data on GPU. If omitted, the GPU data will not be disposed.\n   * Usually, this is provided by a GPU backend for the inference outputs. Users don't need to provide this function.\n   *\n   * @returns a tensor object\n   */\n  fromGpuBuffer<T extends Tensor.GpuBufferDataTypes>(\n    buffer: Tensor.GpuBufferType,\n    options: TensorFromGpuBufferOptions<T>,\n  ): TypedTensor<T>;\n\n  /**\n   * create a tensor from a WebNN MLTensor\n   *\n   * @param tensor - the MLTensor object to create tensor from\n   * @param options - An optional object representing options for creating tensor from a WebNN MLTensor.\n   *\n   * The options include following properties:\n   * - `dataType`: the data type of the tensor. If omitted, assume 'float32'.\n   * - `dims`: the dimension of the tensor. Required.\n   * - `download`: an optional function to download the tensor data from the MLTensor to CPU. If omitted, the MLTensor\n   * data will not be able to download. Usually, this is provided by the WebNN backend for the inference outputs.\n   * Users don't need to provide this function.\n   * - `dispose`: an optional function to dispose the tensor data on the WebNN MLTensor. If omitted, the MLTensor will\n   * not be disposed. Usually, this is provided by the WebNN backend for the inference outputs. Users don't need to\n   * provide this function.\n   *\n   * @returns a tensor object\n   */\n  fromMLTensor<T extends Tensor.MLTensorDataTypes>(\n    tensor: Tensor.MLTensorType,\n    options: TensorFromMLTensorOptions<T>,\n  ): TypedTensor<T>;\n\n  /**\n   * create a tensor from a pre-allocated buffer. The buffer will be used as a pinned buffer.\n   *\n   * @param type - the tensor element type.\n   * @param buffer - a TypedArray corresponding to the type.\n   * @param dims - specify the dimension of the tensor. If omitted, a 1-D tensor is assumed.\n   *\n   * @returns a tensor object\n   */\n  fromPinnedBuffer<T extends Exclude<Tensor.Type, 'string'>>(\n    type: T,\n    buffer: Tensor.DataTypeMap[T],\n    dims?: readonly number[],\n  ): TypedTensor<T>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * A string that represents a file's URL or path.\n *\n * Path is vailable only in onnxruntime-node or onnxruntime-web running in Node.js.\n */\nexport type FileUrlOrPath = string;\n\n/**\n * A Blob object that represents a file.\n */\nexport type FileBlob = Blob;\n\n/**\n * A Uint8Array, ArrayBuffer or SharedArrayBuffer object that represents a file content.\n *\n * When it is an ArrayBuffer or SharedArrayBuffer, the whole buffer is assumed to be the file content.\n */\nexport type FileData = Uint8Array | ArrayBufferLike;\n\n/**\n * Represents a file that can be loaded by the ONNX Runtime JavaScript API.\n */\nexport type FileType = FileUrlOrPath | FileBlob | FileData;\n\n/**\n * Represents an external data file.\n */\nexport interface ExternalDataFileDescription {\n  /**\n   * Specify the external data file.\n   */\n  data: FileType;\n  /**\n   * Specify the file path.\n   */\n  path: string;\n}\n\n/**\n * Represents an external data file.\n *\n * When using a string, it should be a file URL or path that in the same directory as the model file.\n */\nexport type ExternalDataFileType = ExternalDataFileDescription | FileUrlOrPath;\n\n/**\n * Options for model loading.\n */\nexport interface OnnxModelOptions {\n  /**\n   * Specifying a list of files that represents the external data.\n   */\n  externalData?: readonly ExternalDataFileType[];\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from './tensor.js';\n\nexport type NonTensorType = never;\n\n/**\n * Type OnnxValue Represents both tensors and non-tensors value for model's inputs/outputs.\n *\n * NOTE: currently not support non-tensor\n */\nexport type OnnxValue = Tensor | NonTensorType;\n\n/**\n * Type OnnxValueDataLocation represents the location of the data of an OnnxValue.\n */\nexport type OnnxValueDataLocation = Tensor.DataLocation;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { resolveBackendAndExecutionProviders } from './backend-impl.js';\nimport { SessionHandler, TrainingSessionHandler } from './backend.js';\nimport { InferenceSession as InferenceSession } from './inference-session.js';\nimport { OnnxValue } from './onnx-value.js';\nimport { Tensor } from './tensor.js';\nimport { TrainingSession as TrainingSessionInterface, TrainingSessionCreateOptions } from './training-session.js';\n\ntype SessionOptions = InferenceSession.SessionOptions;\ntype FeedsType = InferenceSession.FeedsType;\ntype FetchesType = InferenceSession.FetchesType;\ntype ReturnType = InferenceSession.ReturnType;\ntype RunOptions = InferenceSession.RunOptions;\n\nconst noBackendErrMsg: string =\n  'Training backend could not be resolved. ' + \"Make sure you're using the correct configuration & WebAssembly files.\";\n\nexport class TrainingSession implements TrainingSessionInterface {\n  private constructor(handler: TrainingSessionHandler, hasOptimizerModel: boolean, hasEvalModel: boolean) {\n    this.handler = handler;\n    this.hasOptimizerModel = hasOptimizerModel;\n    this.hasEvalModel = hasEvalModel;\n  }\n  private handler: TrainingSessionHandler;\n  private hasOptimizerModel: boolean;\n  private hasEvalModel: boolean;\n\n  get trainingInputNames(): readonly string[] {\n    return this.handler.inputNames;\n  }\n  get trainingOutputNames(): readonly string[] {\n    return this.handler.outputNames;\n  }\n\n  get evalInputNames(): readonly string[] {\n    if (this.hasEvalModel) {\n      return this.handler.evalInputNames;\n    } else {\n      throw new Error('This training session has no evalModel loaded.');\n    }\n  }\n  get evalOutputNames(): readonly string[] {\n    if (this.hasEvalModel) {\n      return this.handler.evalOutputNames;\n    } else {\n      throw new Error('This training session has no evalModel loaded.');\n    }\n  }\n\n  static async create(\n    trainingOptions: TrainingSessionCreateOptions,\n    sessionOptions?: SessionOptions,\n  ): Promise<TrainingSession> {\n    const evalModel: string | Uint8Array = trainingOptions.evalModel || '';\n    const optimizerModel: string | Uint8Array = trainingOptions.optimizerModel || '';\n    const options: SessionOptions = sessionOptions || {};\n\n    // resolve backend, update session options with validated EPs, and create session handler\n    const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);\n    if (backend.createTrainingSessionHandler) {\n      const handler = await backend.createTrainingSessionHandler(\n        trainingOptions.checkpointState,\n        trainingOptions.trainModel,\n        evalModel,\n        optimizerModel,\n        optionsWithValidatedEPs,\n      );\n      return new TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);\n    } else {\n      throw new Error(noBackendErrMsg);\n    }\n  }\n\n  /**\n   * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from\n   * the given parameters to SessionHandler.FetchesType and RunOptions.\n   *\n   * @param inputNames the feeds object is checked that they contain all input names in the provided list of input\n   * names.\n   * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output\n   * names.\n   * @param feeds the required input\n   * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object\n   * @param arg2 optional RunOptions object.\n   * @returns\n   */\n  typeNarrowingForRunStep(\n    inputNames: readonly string[],\n    outputNames: readonly string[],\n    feeds: FeedsType,\n    arg1?: FetchesType | RunOptions,\n    arg2?: RunOptions,\n  ): [SessionHandler.FetchesType, RunOptions] {\n    const fetches: { [name: string]: OnnxValue | null } = {};\n    let options: RunOptions = {};\n    // check inputs\n    if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\n      throw new TypeError(\n        \"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\",\n      );\n    }\n\n    let isFetchesEmpty = true;\n    // determine which override is being used\n    if (typeof arg1 === 'object') {\n      if (arg1 === null) {\n        throw new TypeError('Unexpected argument[1]: cannot be null.');\n      }\n      if (arg1 instanceof Tensor) {\n        throw new TypeError(\"'fetches' cannot be a Tensor\");\n      }\n\n      if (Array.isArray(arg1)) {\n        if (arg1.length === 0) {\n          throw new TypeError(\"'fetches' cannot be an empty array.\");\n        }\n        isFetchesEmpty = false;\n        // output names\n        for (const name of arg1) {\n          if (typeof name !== 'string') {\n            throw new TypeError(\"'fetches' must be a string array or an object.\");\n          }\n          if (outputNames.indexOf(name) === -1) {\n            throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n          }\n          fetches[name] = null;\n        }\n\n        if (typeof arg2 === 'object' && arg2 !== null) {\n          options = arg2;\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError(\"'options' must be an object.\");\n        }\n      } else {\n        // decide whether arg1 is fetches or options\n        // if any output name is present and its value is valid OnnxValue, we consider it fetches\n        let isFetches = false;\n        const arg1Keys = Object.getOwnPropertyNames(arg1);\n        for (const name of outputNames) {\n          if (arg1Keys.indexOf(name) !== -1) {\n            const v = (arg1 as InferenceSession.NullableOnnxValueMapType)[name];\n            if (v === null || v instanceof Tensor) {\n              isFetches = true;\n              isFetchesEmpty = false;\n              fetches[name] = v;\n            }\n          }\n        }\n\n        if (isFetches) {\n          if (typeof arg2 === 'object' && arg2 !== null) {\n            options = arg2;\n          } else if (typeof arg2 !== 'undefined') {\n            throw new TypeError(\"'options' must be an object.\");\n          }\n        } else {\n          options = arg1 as RunOptions;\n        }\n      }\n    } else if (typeof arg1 !== 'undefined') {\n      throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n    }\n\n    // check if all inputs are in feed\n    for (const name of inputNames) {\n      if (typeof feeds[name] === 'undefined') {\n        throw new Error(`input '${name}' is missing in 'feeds'.`);\n      }\n    }\n\n    // if no fetches is specified, we use the full output names list\n    if (isFetchesEmpty) {\n      for (const name of outputNames) {\n        fetches[name] = null;\n      }\n    }\n\n    return [fetches, options];\n  }\n\n  /**\n   * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler\n   * and changes it into a map of Tensors.\n   *\n   * @param results\n   * @returns\n   */\n  convertHandlerReturnTypeToMapOfTensors(results: SessionHandler.ReturnType): ReturnType {\n    const returnValue: { [name: string]: OnnxValue } = {};\n    for (const key in results) {\n      if (Object.hasOwnProperty.call(results, key)) {\n        const result = results[key];\n        if (result instanceof Tensor) {\n          returnValue[key] = result;\n        } else {\n          returnValue[key] = new Tensor(result.type, result.data, result.dims);\n        }\n      }\n    }\n    return returnValue;\n  }\n\n  async lazyResetGrad(): Promise<void> {\n    await this.handler.lazyResetGrad();\n  }\n\n  runTrainStep(feeds: FeedsType, options?: RunOptions): Promise<ReturnType>;\n  runTrainStep(feeds: FeedsType, fetches: FetchesType, options?: RunOptions): Promise<ReturnType>;\n  async runTrainStep(feeds: FeedsType, arg1?: FetchesType | RunOptions, arg2?: RunOptions): Promise<ReturnType> {\n    const [fetches, options] = this.typeNarrowingForRunStep(\n      this.trainingInputNames,\n      this.trainingOutputNames,\n      feeds,\n      arg1,\n      arg2,\n    );\n    const results = await this.handler.runTrainStep(feeds, fetches, options);\n    return this.convertHandlerReturnTypeToMapOfTensors(results);\n  }\n\n  async runOptimizerStep(options?: InferenceSession.RunOptions | undefined): Promise<void> {\n    if (this.hasOptimizerModel) {\n      await this.handler.runOptimizerStep(options || {});\n    } else {\n      throw new Error('This TrainingSession has no OptimizerModel loaded.');\n    }\n  }\n\n  runEvalStep(feeds: FeedsType, options?: RunOptions | undefined): Promise<ReturnType>;\n  runEvalStep(feeds: FeedsType, fetches: FetchesType, options?: RunOptions | undefined): Promise<ReturnType>;\n  async runEvalStep(feeds: FeedsType, arg1?: FetchesType | RunOptions, arg2?: RunOptions): Promise<ReturnType> {\n    if (this.hasEvalModel) {\n      const [fetches, options] = this.typeNarrowingForRunStep(\n        this.evalInputNames,\n        this.evalOutputNames,\n        feeds,\n        arg1,\n        arg2,\n      );\n      const results = await this.handler.runEvalStep(feeds, fetches, options);\n      return this.convertHandlerReturnTypeToMapOfTensors(results);\n    } else {\n      throw new Error('This TrainingSession has no EvalModel loaded.');\n    }\n  }\n\n  async getParametersSize(trainableOnly = true): Promise<number> {\n    return this.handler.getParametersSize(trainableOnly);\n  }\n\n  async loadParametersBuffer(array: Uint8Array, trainableOnly = true): Promise<void> {\n    const paramsSize = await this.getParametersSize(trainableOnly);\n    // checking that the size of the Uint8Array is equivalent to the byte length of a Float32Array of the number\n    // of parameters\n    if (array.length !== 4 * paramsSize) {\n      throw new Error(\n        'Size of the buffer passed into loadParametersBuffer must match the number of parameters in ' +\n          'the model. Please use getParametersSize method to check.',\n      );\n    }\n    return this.handler.loadParametersBuffer(array, trainableOnly);\n  }\n\n  async getContiguousParameters(trainableOnly = true): Promise<OnnxValue> {\n    return this.handler.getContiguousParameters(trainableOnly);\n  }\n\n  async release(): Promise<void> {\n    return this.handler.dispose();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession } from './inference-session.js';\nimport { OnnxValue } from './onnx-value.js';\nimport { TrainingSession as TrainingSessionImpl } from './training-session-impl.js';\n\n/* eslint-disable @typescript-eslint/no-redeclare */\n\nexport declare namespace TrainingSession {\n  /**\n   * Either URI file path (string) or Uint8Array containing model or checkpoint information.\n   */\n  type UriOrBuffer = string | Uint8Array;\n}\n\n/**\n * Represent a runtime instance of an ONNX training session,\n * which contains a model that can be trained, and, optionally,\n * an eval and optimizer model.\n */\nexport interface TrainingSession {\n  // #region run()\n\n  /**\n   * Lazily resets the gradients of all trainable parameters to zero. Should happen after the invocation of\n   * runOptimizerStep.\n   */\n  lazyResetGrad(): Promise<void>;\n\n  /**\n   * Run TrainStep asynchronously with the given feeds and options.\n   *\n   * @param feeds - Representation of the model input. See type description of `InferenceSession.InputType` for\n   detail.\n   * @param options - Optional. A set of options that controls the behavior of model training.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding values.\n   */\n  runTrainStep(\n    feeds: InferenceSession.FeedsType,\n    options?: InferenceSession.RunOptions,\n  ): Promise<InferenceSession.ReturnType>;\n\n  /**\n   * Run a single train step with the given inputs and options.\n   *\n   * @param feeds - Representation of the model input.\n   * @param fetches - Representation of the model output.\n   * detail.\n   * @param options - Optional. A set of options that controls the behavior of model training.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding\n   values.\n   */\n  runTrainStep(\n    feeds: InferenceSession.FeedsType,\n    fetches: InferenceSession.FetchesType,\n    options?: InferenceSession.RunOptions,\n  ): Promise<InferenceSession.ReturnType>;\n\n  /**\n   * Runs a single optimizer step, which performs weight updates for the trainable parameters using the optimizer model.\n   *\n   * @param options - Optional. A set of options that controls the behavior of model optimizing.\n   */\n  runOptimizerStep(options?: InferenceSession.RunOptions): Promise<void>;\n\n  /**\n   * Run a single eval step with the given inputs and options using the eval model.\n   *\n   * @param feeds - Representation of the model input.\n   * @param options - Optional. A set of options that controls the behavior of model eval step.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding\n   values.\n   */\n  runEvalStep(\n    feeds: InferenceSession.FeedsType,\n    options?: InferenceSession.RunOptions,\n  ): Promise<InferenceSession.ReturnType>;\n\n  /**\n   * Run a single eval step with the given inputs and options using the eval model.\n   *\n   * @param feeds - Representation of the model input.\n   * @param fetches - Representation of the model output.\n   * detail.\n   * @param options - Optional. A set of options that controls the behavior of model eval step.\n   * @returns A promise that resolves to a map, which uses output names as keys and OnnxValue as corresponding\n   values.\n   */\n  runEvalStep(\n    feeds: InferenceSession.FeedsType,\n    fetches: InferenceSession.FetchesType,\n    options?: InferenceSession.RunOptions,\n  ): Promise<InferenceSession.ReturnType>;\n\n  // #endregion\n\n  // #region copy parameters\n\n  /**\n   * Retrieves the size of all parameters for the training state. Calculates the total number of primitive (datatype of\n   * the parameters) elements of all the parameters in the training state.\n   *\n   * @param trainableOnly - When set to true, the size is calculated for trainable params only. Default value is true.\n   */\n  getParametersSize(trainableOnly: boolean): Promise<number>;\n\n  /**\n   * Copies parameter values from the given buffer to the training state. Currently, only supporting models with\n   * parameters of type Float32.\n   *\n   * @param buffer - A Uint8Array representation of Float32 parameters.\n   * @param trainableOnly - True if trainable parameters only to be modified, false otherwise. Default value is true.\n   */\n  loadParametersBuffer(buffer: Uint8Array, trainableOnly: boolean): Promise<void>;\n\n  /**\n   * Copies the model parameters to a contiguous buffer. Usually used in the context of Federated Learning.\n   * Currently, only supporting models with parameters of type Float32.\n   *\n   * @param trainableOnly - When set to true, only trainable parameters are copied. Trainable parameters are parameters\n   * for which requires_grad is set to true. Default value is true.\n   * @returns A promise that resolves to a Float32 OnnxValue of the requested parameters.\n   */\n  getContiguousParameters(trainableOnly: boolean): Promise<OnnxValue>;\n  // #endregion\n\n  // #region release()\n\n  /**\n   * Release the inference session and the underlying resources.\n   */\n  release(): Promise<void>;\n  // #endregion\n\n  // #region metadata\n\n  /**\n   * Get input names of the loaded training model.\n   */\n  readonly trainingInputNames: readonly string[];\n\n  /**\n   * Get output names of the loaded training model.\n   */\n  readonly trainingOutputNames: readonly string[];\n\n  /**\n   * Get input names of the loaded eval model. Is an empty array if no eval model is loaded.\n   */\n  readonly evalInputNames: readonly string[];\n\n  /**\n   * Get output names of the loaded eval model. Is an empty array if no eval model is loaded.\n   */\n  readonly evalOutputNames: readonly string[];\n\n  // #endregion\n}\n\n/**\n * Represents the optional parameters that can be passed into the TrainingSessionFactory.\n */\nexport interface TrainingSessionCreateOptions {\n  /**\n   * URI or buffer for a .ckpt file that contains the checkpoint for the training model.\n   */\n  checkpointState: TrainingSession.UriOrBuffer;\n  /**\n   * URI or buffer for the .onnx training file.\n   */\n  trainModel: TrainingSession.UriOrBuffer;\n  /**\n   * Optional. URI or buffer for the .onnx optimizer model file.\n   */\n  optimizerModel?: TrainingSession.UriOrBuffer;\n  /**\n   * Optional. URI or buffer for the .onnx eval model file.\n   */\n  evalModel?: TrainingSession.UriOrBuffer;\n}\n\n/**\n * Defines method overload possibilities for creating a TrainingSession.\n */\nexport interface TrainingSessionFactory {\n  // #region create()\n\n  /**\n   * Creates a new TrainingSession and asynchronously loads any models passed in through trainingOptions\n   *\n   * @param trainingOptions specify models and checkpoints to load into the Training Session\n   * @param sessionOptions specify configuration for training session behavior\n   *\n   * @returns Promise that resolves to a TrainingSession object\n   */\n  create(\n    trainingOptions: TrainingSessionCreateOptions,\n    sessionOptions?: InferenceSession.SessionOptions,\n  ): Promise<TrainingSession>;\n\n  // #endregion\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const TrainingSession: TrainingSessionFactory = TrainingSessionImpl;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * # ONNX Runtime JavaScript API\n *\n * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:\n *\n * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)\n * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)\n * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)\n *\n * See also:\n * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript/)\n * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)\n *\n * @packageDocumentation\n */\n\nexport * from './backend.js';\nexport * from './env.js';\nexport * from './inference-session.js';\nexport * from './tensor.js';\nexport * from './tensor-conversion.js';\nexport * from './tensor-factory.js';\nexport * from './trace.js';\nexport * from './onnx-model.js';\nexport * from './onnx-value.js';\nexport * from './training-session.js';\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Env } from 'onnxruntime-common';\n\nimport { WebGLContext } from './backends/webgl/webgl-context';\n\nexport declare namespace Logger {\n  export interface SeverityTypeMap {\n    verbose: 'v';\n    info: 'i';\n    warning: 'w';\n    error: 'e';\n    fatal: 'f';\n  }\n\n  export type Severity = keyof SeverityTypeMap;\n\n  export type Provider = 'none' | 'console';\n\n  /**\n   * Logging config that used to control the behavior of logger\n   */\n  export interface Config {\n    /**\n     * Specify the logging provider. 'console' by default\n     */\n    provider?: Provider;\n    /**\n     * Specify the minimal logger serverity. 'warning' by default\n     */\n    minimalSeverity?: Logger.Severity;\n    /**\n     * Whether to output date time in log. true by default\n     */\n    logDateTime?: boolean;\n    /**\n     * Whether to output source information (Not yet supported). false by default\n     */\n    logSourceLocation?: boolean;\n  }\n\n  export interface CategorizedLogger {\n    verbose(content: string): void;\n    info(content: string): void;\n    warning(content: string): void;\n    error(content: string): void;\n    fatal(content: string): void;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport interface Logger {\n  (category: string): Logger.CategorizedLogger;\n\n  verbose(content: string): void;\n  verbose(category: string, content: string): void;\n  info(content: string): void;\n  info(category: string, content: string): void;\n  warning(content: string): void;\n  warning(category: string, content: string): void;\n  error(content: string): void;\n  error(category: string, content: string): void;\n  fatal(content: string): void;\n  fatal(category: string, content: string): void;\n\n  /**\n   * Reset the logger configuration.\n   * @param config specify an optional default config\n   */\n  reset(config?: Logger.Config): void;\n  /**\n   * Set the logger's behavior on the given category\n   * @param category specify a category string. If '*' is specified, all previous configuration will be overwritten. If\n   * '' is specified, the default behavior will be updated.\n   * @param config the config object to indicate the logger's behavior\n   */\n  set(category: string, config: Logger.Config): void;\n\n  /**\n   * Set the logger's behavior from ort-common env\n   * @param env the env used to set logger. Currently only setting loglevel is supported through Env.\n   */\n  setWithEnv(env: Env): void;\n}\n\ninterface LoggerProvider {\n  log(severity: Logger.Severity, content: string, category?: string): void;\n}\nclass NoOpLoggerProvider implements LoggerProvider {\n  log(_severity: Logger.Severity, _content: string, _category?: string) {\n    // do nothing\n  }\n}\nclass ConsoleLoggerProvider implements LoggerProvider {\n  log(severity: Logger.Severity, content: string, category?: string) {\n    // eslint-disable-next-line no-console\n    console.log(`${this.color(severity)} ${category ? '\\x1b[35m' + category + '\\x1b[0m ' : ''}${content}`);\n  }\n\n  private color(severity: Logger.Severity) {\n    switch (severity) {\n      case 'verbose':\n        return '\\x1b[34;40mv\\x1b[0m';\n      case 'info':\n        return '\\x1b[32mi\\x1b[0m';\n      case 'warning':\n        return '\\x1b[30;43mw\\x1b[0m';\n      case 'error':\n        return '\\x1b[31;40me\\x1b[0m';\n      case 'fatal':\n        return '\\x1b[101mf\\x1b[0m';\n      default:\n        throw new Error(`unsupported severity: ${severity}`);\n    }\n  }\n}\n\nconst SEVERITY_VALUE = {\n  verbose: 1000,\n  info: 2000,\n  warning: 4000,\n  error: 5000,\n  fatal: 6000,\n};\n\nconst LOGGER_PROVIDER_MAP: { readonly [provider: string]: Readonly<LoggerProvider> } = {\n  ['none']: new NoOpLoggerProvider(),\n  ['console']: new ConsoleLoggerProvider(),\n};\nconst LOGGER_DEFAULT_CONFIG = {\n  provider: 'console',\n  minimalSeverity: 'warning',\n  logDateTime: true,\n  logSourceLocation: false,\n};\nlet LOGGER_CONFIG_MAP: { [category: string]: Readonly<Required<Logger.Config>> } = {\n  ['']: LOGGER_DEFAULT_CONFIG as Required<Logger.Config>,\n};\n\nfunction log(category: string): Logger.CategorizedLogger;\nfunction log(severity: Logger.Severity, content: string): void;\nfunction log(severity: Logger.Severity, category: string, content: string): void;\nfunction log(severity: Logger.Severity, arg1: string, arg2?: string): void;\nfunction log(\n  arg0: string | Logger.Severity,\n  arg1?: string,\n  arg2?: string | number,\n  arg3?: number,\n): Logger.CategorizedLogger | void {\n  if (arg1 === undefined) {\n    // log(category: string): Logger.CategorizedLogger;\n    return createCategorizedLogger(arg0);\n  } else if (arg2 === undefined) {\n    // log(severity, content);\n    logInternal(arg0 as Logger.Severity, arg1, 1);\n  } else if (typeof arg2 === 'number' && arg3 === undefined) {\n    // log(severity, content, stack)\n    logInternal(arg0 as Logger.Severity, arg1, arg2);\n  } else if (typeof arg2 === 'string' && arg3 === undefined) {\n    // log(severity, category, content)\n    logInternal(arg0 as Logger.Severity, arg2, 1, arg1);\n  } else if (typeof arg2 === 'string' && typeof arg3 === 'number') {\n    // log(severity, category, content, stack)\n    logInternal(arg0 as Logger.Severity, arg2, arg3, arg1);\n  } else {\n    throw new TypeError('input is valid');\n  }\n}\n\nfunction createCategorizedLogger(category: string): Logger.CategorizedLogger {\n  return {\n    verbose: log.verbose.bind(null, category),\n    info: log.info.bind(null, category),\n    warning: log.warning.bind(null, category),\n    error: log.error.bind(null, category),\n    fatal: log.fatal.bind(null, category),\n  };\n}\n\n// NOTE: argument 'category' is put the last parameter beacause typescript\n// doesn't allow optional argument put in front of required argument. This\n// order is different from a usual logging API.\nfunction logInternal(severity: Logger.Severity, content: string, _stack: number, category?: string) {\n  const config = LOGGER_CONFIG_MAP[category || ''] || LOGGER_CONFIG_MAP[''];\n  if (SEVERITY_VALUE[severity] < SEVERITY_VALUE[config.minimalSeverity]) {\n    return;\n  }\n\n  if (config.logDateTime) {\n    content = `${new Date().toISOString()}|${content}`;\n  }\n\n  if (config.logSourceLocation) {\n    // TODO: calculate source location from 'stack'\n  }\n\n  LOGGER_PROVIDER_MAP[config.provider].log(severity, content, category);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace log {\n  export function verbose(content: string): void;\n  export function verbose(category: string, content: string): void;\n  export function verbose(arg0: string, arg1?: string) {\n    log('verbose', arg0, arg1);\n  }\n  export function info(content: string): void;\n  export function info(category: string, content: string): void;\n  export function info(arg0: string, arg1?: string) {\n    log('info', arg0, arg1);\n  }\n  export function warning(content: string): void;\n  export function warning(category: string, content: string): void;\n  export function warning(arg0: string, arg1?: string) {\n    log('warning', arg0, arg1);\n  }\n  export function error(content: string): void;\n  export function error(category: string, content: string): void;\n  export function error(arg0: string, arg1?: string) {\n    log('error', arg0, arg1);\n  }\n  export function fatal(content: string): void;\n  export function fatal(category: string, content: string): void;\n  export function fatal(arg0: string, arg1?: string) {\n    log('fatal', arg0, arg1);\n  }\n\n  export function reset(config?: Logger.Config): void {\n    LOGGER_CONFIG_MAP = {};\n    set('', config || {});\n  }\n  export function set(category: string, config: Logger.Config): void {\n    if (category === '*') {\n      reset(config);\n    } else {\n      const previousConfig = LOGGER_CONFIG_MAP[category] || LOGGER_DEFAULT_CONFIG;\n      LOGGER_CONFIG_MAP[category] = {\n        provider: config.provider || previousConfig.provider,\n        minimalSeverity: config.minimalSeverity || previousConfig.minimalSeverity,\n        logDateTime: config.logDateTime === undefined ? previousConfig.logDateTime : config.logDateTime,\n        logSourceLocation:\n          config.logSourceLocation === undefined ? previousConfig.logSourceLocation : config.logSourceLocation,\n      };\n    }\n\n    // TODO: we want to support wildcard or regex?\n  }\n\n  export function setWithEnv(env: Env): void {\n    const config: Logger.Config = {};\n    if (env.logLevel) {\n      config.minimalSeverity = env.logLevel as Logger.Severity;\n    }\n    set('', config);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention\nexport const Logger: Logger = log;\n\nexport declare namespace Profiler {\n  export interface Config {\n    maxNumberEvents?: number;\n    flushBatchSize?: number;\n    flushIntervalInMilliseconds?: number;\n  }\n\n  export type EventCategory = 'session' | 'node' | 'op' | 'backend';\n\n  export interface Event {\n    end(): void | Promise<void>;\n  }\n}\n// TODO\n// class WebGLEvent implements Profiler.Event {}\n\nclass Event implements Profiler.Event {\n  constructor(\n    public category: Profiler.EventCategory,\n    public name: string,\n    public startTime: number,\n    private endCallback: (e: Event) => void | Promise<void>,\n    public timer?: WebGLQuery,\n    public ctx?: WebGLContext,\n  ) {}\n\n  async end() {\n    return this.endCallback(this);\n  }\n\n  async checkTimer(): Promise<number> {\n    if (this.ctx === undefined || this.timer === undefined) {\n      throw new Error('No webgl timer found');\n    } else {\n      this.ctx.endTimer();\n      return this.ctx.waitForQueryAndGetTime(this.timer);\n    }\n  }\n}\n\nclass EventRecord {\n  constructor(\n    public category: Profiler.EventCategory,\n    public name: string,\n    public startTime: number,\n    public endTime: number,\n  ) {}\n}\n\nexport class Profiler {\n  static create(config?: Profiler.Config): Profiler {\n    if (config === undefined) {\n      return new this();\n    }\n    return new this(config.maxNumberEvents, config.flushBatchSize, config.flushIntervalInMilliseconds);\n  }\n\n  private constructor(maxNumberEvents?: number, flushBatchSize?: number, flushIntervalInMilliseconds?: number) {\n    this._started = false;\n    this._maxNumberEvents = maxNumberEvents === undefined ? 10000 : maxNumberEvents;\n    this._flushBatchSize = flushBatchSize === undefined ? 10 : flushBatchSize;\n    this._flushIntervalInMilliseconds = flushIntervalInMilliseconds === undefined ? 5000 : flushIntervalInMilliseconds;\n  }\n\n  // start profiling\n  start() {\n    this._started = true;\n    this._timingEvents = [];\n    this._flushTime = now();\n    this._flushPointer = 0;\n  }\n\n  // stop profiling\n  stop() {\n    this._started = false;\n    for (; this._flushPointer < this._timingEvents.length; this._flushPointer++) {\n      this.logOneEvent(this._timingEvents[this._flushPointer]);\n    }\n  }\n\n  // create an event scope for the specific function\n  event<T>(category: Profiler.EventCategory, name: string, func: () => T, ctx?: WebGLContext): T;\n  event<T>(category: Profiler.EventCategory, name: string, func: () => Promise<T>, ctx?: WebGLContext): Promise<T>;\n\n  event<T>(\n    category: Profiler.EventCategory,\n    name: string,\n    func: () => T | Promise<T>,\n    ctx?: WebGLContext,\n  ): T | Promise<T> {\n    const event = this._started ? this.begin(category, name, ctx) : undefined;\n    let isPromise = false;\n\n    const res = func();\n\n    // we consider a then-able object is a promise\n    if (res && typeof (res as Promise<T>).then === 'function') {\n      isPromise = true;\n      return new Promise<T>((resolve, reject) => {\n        (res as Promise<T>).then(\n          async (value) => {\n            // fulfilled\n            if (event) {\n              await event.end();\n            }\n            resolve(value);\n          },\n          async (reason) => {\n            // rejected\n            if (event) {\n              await event.end();\n            }\n            reject(reason);\n          },\n        );\n      });\n    }\n    if (!isPromise && event) {\n      const eventRes = event.end();\n      if (eventRes && typeof eventRes.then === 'function') {\n        return new Promise<T>((resolve, reject) => {\n          eventRes.then(\n            () => {\n              // fulfilled\n              resolve(res);\n            },\n            (reason) => {\n              // rejected\n              reject(reason);\n            },\n          );\n        });\n      }\n    }\n    return res;\n  }\n\n  // begin an event\n  begin(category: Profiler.EventCategory, name: string, ctx?: WebGLContext): Event {\n    if (!this._started) {\n      throw new Error('profiler is not started yet');\n    }\n    if (ctx === undefined) {\n      const startTime = now();\n      this.flush(startTime);\n      return new Event(category, name, startTime, (e) => this.endSync(e));\n    } else {\n      const timer: WebGLQuery = ctx.beginTimer();\n      return new Event(category, name, 0, async (e) => this.end(e), timer, ctx);\n    }\n  }\n\n  // end the specific event\n  private async end(event: Event): Promise<void> {\n    const endTime: number = await event.checkTimer();\n    if (this._timingEvents.length < this._maxNumberEvents) {\n      this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));\n      this.flush(endTime);\n    }\n  }\n\n  private endSync(event: Event): void {\n    const endTime: number = now();\n    if (this._timingEvents.length < this._maxNumberEvents) {\n      this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));\n      this.flush(endTime);\n    }\n  }\n\n  private logOneEvent(event: EventRecord) {\n    Logger.verbose(\n      `Profiler.${event.category}`,\n      `${(event.endTime - event.startTime).toFixed(2)}ms on event '${event.name}' at ${event.endTime.toFixed(2)}`,\n    );\n  }\n\n  private flush(currentTime: number) {\n    if (\n      this._timingEvents.length - this._flushPointer >= this._flushBatchSize ||\n      currentTime - this._flushTime >= this._flushIntervalInMilliseconds\n    ) {\n      // should flush when either batch size accumlated or interval elepsed\n\n      for (\n        const previousPointer = this._flushPointer;\n        this._flushPointer < previousPointer + this._flushBatchSize && this._flushPointer < this._timingEvents.length;\n        this._flushPointer++\n      ) {\n        this.logOneEvent(this._timingEvents[this._flushPointer]);\n      }\n\n      this._flushTime = now();\n    }\n  }\n\n  get started() {\n    return this._started;\n  }\n  private _started = false;\n  private _timingEvents: EventRecord[];\n\n  private readonly _maxNumberEvents: number;\n\n  private readonly _flushBatchSize: number;\n  private readonly _flushIntervalInMilliseconds: number;\n\n  private _flushTime: number;\n  private _flushPointer = 0;\n}\n\n/**\n * returns a number to represent the current timestamp in a resolution as high as possible.\n */\nexport const now = typeof performance !== 'undefined' && performance.now ? () => performance.now() : Date.now;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from './graph';\nimport { OperatorImplementation, OperatorInitialization } from './operators';\n\nexport interface OpSet {\n  domain: string;\n  version: number;\n}\nexport declare namespace OpSet {\n  /**\n   * Domain of an opset, it can be an empty string(default value, represent for ai.onnx), or 'ai.onnx.ml'\n   */\n  type Domain = '' | 'ai.onnx.ml' | 'com.microsoft';\n  /**\n   * A resolve rule consists of 4 or 5 items: opType, opSetDomain, versionSelector, operatorImplementation and\n   * operatorInitialization (optional)\n   */\n  type ResolveRule =\n    | [string, Domain, string, OperatorImplementation<Graph.Node>]\n    | [string, Domain, string, OperatorImplementation<unknown>, OperatorInitialization<unknown>];\n}\n\nexport function resolveOperator(node: Graph.Node, opsets: readonly OpSet[], rules: readonly OpSet.ResolveRule[]) {\n  for (const rule of rules) {\n    const opType = rule[0];\n    const domain = rule[1];\n    const versionSelector = rule[2];\n    const opImpl = rule[3];\n    const opInit = rule[4];\n\n    if (node.opType === opType) {\n      // operator type matches\n      for (const opset of opsets) {\n        // opset '' and 'ai.onnx' are considered the same.\n        if (opset.domain === domain || (opset.domain === 'ai.onnx' && domain === '')) {\n          // opset domain found\n          if (matchSelector(opset.version, versionSelector)) {\n            return { opImpl, opInit };\n          }\n        }\n      }\n    }\n  }\n\n  throw new TypeError(\n    `cannot resolve operator '${node.opType}' with opsets: ${opsets\n      .map((set) => `${set.domain || 'ai.onnx'} v${set.version}`)\n      .join(', ')}`,\n  );\n}\n\nfunction matchSelector(version: number, selector: string): boolean {\n  if (selector.endsWith('+')) {\n    // minimum version match ('7+' expects version>=7)\n    const rangeStart = Number.parseInt(selector.substring(0, selector.length - 1), 10);\n    return !isNaN(rangeStart) && rangeStart <= version;\n  } else if (selector.split('-').length === 2) {\n    // range match ('6-8' expects 6<=version<=8)\n    const pair = selector.split('-');\n    const rangeStart = Number.parseInt(pair[0], 10);\n    const rangeEnd = Number.parseInt(pair[1], 10);\n    return !isNaN(rangeStart) && !isNaN(rangeEnd) && rangeStart <= version && version <= rangeEnd;\n  } else {\n    // exact match ('7' expects version===7)\n    return Number.parseInt(selector, 10) === version;\n  }\n}\n","\"use strict\";\r\nexports.__esModule = true;\r\nvar Guid = /** @class */ (function () {\r\n    function Guid(guid) {\r\n        if (!guid) {\r\n            throw new TypeError(\"Invalid argument; `value` has no value.\");\r\n        }\r\n        this.value = Guid.EMPTY;\r\n        if (guid && Guid.isGuid(guid)) {\r\n            this.value = guid;\r\n        }\r\n    }\r\n    Guid.isGuid = function (guid) {\r\n        var value = guid.toString();\r\n        return guid && (guid instanceof Guid || Guid.validator.test(value));\r\n    };\r\n    Guid.create = function () {\r\n        return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join(\"-\"));\r\n    };\r\n    Guid.createEmpty = function () {\r\n        return new Guid(\"emptyguid\");\r\n    };\r\n    Guid.parse = function (guid) {\r\n        return new Guid(guid);\r\n    };\r\n    Guid.raw = function () {\r\n        return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join(\"-\");\r\n    };\r\n    Guid.gen = function (count) {\r\n        var out = \"\";\r\n        for (var i = 0; i < count; i++) {\r\n            // tslint:disable-next-line:no-bitwise\r\n            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n        }\r\n        return out;\r\n    };\r\n    Guid.prototype.equals = function (other) {\r\n        // Comparing string `value` against provided `guid` will auto-call\r\n        // toString on `guid` for comparison\r\n        return Guid.isGuid(other) && this.value === other.toString();\r\n    };\r\n    Guid.prototype.isEmpty = function () {\r\n        return this.value === Guid.EMPTY;\r\n    };\r\n    Guid.prototype.toString = function () {\r\n        return this.value;\r\n    };\r\n    Guid.prototype.toJSON = function () {\r\n        return {\r\n            value: this.value\r\n        };\r\n    };\r\n    Guid.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\");\r\n    Guid.EMPTY = \"00000000-0000-0000-0000-000000000000\";\r\n    return Guid;\r\n}());\r\nexports.Guid = Guid;\r\n","/**\n * @license\n * Copyright 2009 The Closure Library Authors\n * Copyright 2020 Daniel Wirtz / The long.js Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// WebAssembly optimizations to do native i64 multiplication and divide\nvar wasm = null;\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\n  ])), {}).exports;\n} catch (e) {\n  // no wasm support :(\n}\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nfunction Long(low, high, unsigned) {\n\n  /**\n   * The low 32 bits as a signed value.\n   * @type {number}\n   */\n  this.low = low | 0;\n\n  /**\n   * The high 32 bits as a signed value.\n   * @type {number}\n   */\n  this.high = high | 0;\n\n  /**\n   * Whether unsigned or not.\n   * @type {boolean}\n   */\n  this.unsigned = !!unsigned;\n}\n\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\n\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nfunction isLong(obj) {\n  return (obj && obj[\"__isLong__\"]) === true;\n}\n\n/**\n * @function\n * @param {*} value number\n * @returns {number}\n * @inner\n */\nfunction ctz32(value) {\n  var c = Math.clz32(value & -value);\n  return value ? 31 - c : c;\n}\n\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\nLong.isLong = isLong;\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromInt(value, unsigned) {\n  var obj, cachedObj, cache;\n  if (unsigned) {\n    value >>>= 0;\n    if (cache = (0 <= value && value < 256)) {\n      cachedObj = UINT_CACHE[value];\n      if (cachedObj)\n        return cachedObj;\n    }\n    obj = fromBits(value, 0, true);\n    if (cache)\n      UINT_CACHE[value] = obj;\n    return obj;\n  } else {\n    value |= 0;\n    if (cache = (-128 <= value && value < 128)) {\n      cachedObj = INT_CACHE[value];\n      if (cachedObj)\n        return cachedObj;\n    }\n    obj = fromBits(value, value < 0 ? -1 : 0, false);\n    if (cache)\n      INT_CACHE[value] = obj;\n    return obj;\n  }\n}\n\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromInt = fromInt;\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromNumber(value, unsigned) {\n  if (isNaN(value))\n    return unsigned ? UZERO : ZERO;\n  if (unsigned) {\n    if (value < 0)\n      return UZERO;\n    if (value >= TWO_PWR_64_DBL)\n      return MAX_UNSIGNED_VALUE;\n  } else {\n    if (value <= -TWO_PWR_63_DBL)\n      return MIN_VALUE;\n    if (value + 1 >= TWO_PWR_63_DBL)\n      return MAX_VALUE;\n  }\n  if (value < 0)\n    return fromNumber(-value, unsigned).neg();\n  return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n}\n\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromNumber = fromNumber;\n\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromBits(lowBits, highBits, unsigned) {\n  return new Long(lowBits, highBits, unsigned);\n}\n\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromBits = fromBits;\n\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nfunction fromString(str, unsigned, radix) {\n  if (str.length === 0)\n    throw Error('empty string');\n  if (typeof unsigned === 'number') {\n    // For goog.math.long compatibility\n    radix = unsigned;\n    unsigned = false;\n  } else {\n    unsigned = !!unsigned;\n  }\n  if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n    return unsigned ? UZERO : ZERO;\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix)\n    throw RangeError('radix');\n\n  var p;\n  if ((p = str.indexOf('-')) > 0)\n    throw Error('interior hyphen');\n  else if (p === 0) {\n    return fromString(str.substring(1), unsigned, radix).neg();\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = fromNumber(pow_dbl(radix, 8));\n\n  var result = ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i),\n      value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = fromNumber(pow_dbl(radix, size));\n      result = result.mul(power).add(fromNumber(value));\n    } else {\n      result = result.mul(radixToPower);\n      result = result.add(fromNumber(value));\n    }\n  }\n  result.unsigned = unsigned;\n  return result;\n}\n\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\nLong.fromString = fromString;\n\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromValue(val, unsigned) {\n  if (typeof val === 'number')\n    return fromNumber(val, unsigned);\n  if (typeof val === 'string')\n    return fromString(val, unsigned);\n  // Throws for non-objects, converts non-instanceof Long:\n  return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n}\n\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\nLong.fromValue = fromValue;\n\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ZERO = fromInt(0);\n\n/**\n * Signed zero.\n * @type {!Long}\n */\nLong.ZERO = ZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UZERO = fromInt(0, true);\n\n/**\n * Unsigned zero.\n * @type {!Long}\n */\nLong.UZERO = UZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ONE = fromInt(1);\n\n/**\n * Signed one.\n * @type {!Long}\n */\nLong.ONE = ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UONE = fromInt(1, true);\n\n/**\n * Unsigned one.\n * @type {!Long}\n */\nLong.UONE = UONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar NEG_ONE = fromInt(-1);\n\n/**\n * Signed negative one.\n * @type {!Long}\n */\nLong.NEG_ONE = NEG_ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n\n/**\n * Maximum signed value.\n * @type {!Long}\n */\nLong.MAX_VALUE = MAX_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n\n/**\n * Minimum signed value.\n * @type {!Long}\n */\nLong.MIN_VALUE = MIN_VALUE;\n\n/**\n * @alias Long.prototype\n * @inner\n */\nvar LongPrototype = Long.prototype;\n\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toInt = function toInt() {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\n\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toNumber = function toNumber() {\n  if (this.unsigned)\n    return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\n  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\n\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nLongPrototype.toString = function toString(radix) {\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix)\n    throw RangeError('radix');\n  if (this.isZero())\n    return '0';\n  if (this.isNegative()) { // Unsigned Longs are never negative\n    if (this.eq(MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = fromNumber(radix),\n        div = this.div(radixLong),\n        rem1 = div.mul(radixLong).sub(this);\n      return div.toString(radix) + rem1.toInt().toString(radix);\n    } else\n      return '-' + this.neg().toString(radix);\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n    rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower),\n      intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n      digits = intval.toString(radix);\n    rem = remDiv;\n    if (rem.isZero())\n      return digits + result;\n    else {\n      while (digits.length < 6)\n        digits = '0' + digits;\n      result = '' + digits + result;\n    }\n  }\n};\n\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\nLongPrototype.getHighBits = function getHighBits() {\n  return this.high;\n};\n\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n  return this.high >>> 0;\n};\n\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\nLongPrototype.getLowBits = function getLowBits() {\n  return this.low;\n};\n\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n  return this.low >>> 0;\n};\n\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n  if (this.isNegative()) // Unsigned Longs are never negative\n    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n  var val = this.high != 0 ? this.high : this.low;\n  for (var bit = 31; bit > 0; bit--)\n    if ((val & (1 << bit)) != 0)\n      break;\n  return this.high != 0 ? bit + 33 : bit + 1;\n};\n\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isZero = function isZero() {\n  return this.high === 0 && this.low === 0;\n};\n\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\nLongPrototype.eqz = LongPrototype.isZero;\n\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isNegative = function isNegative() {\n  return !this.unsigned && this.high < 0;\n};\n\n/**\n * Tests if this Long's value is positive or zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isPositive = function isPositive() {\n  return this.unsigned || this.high >= 0;\n};\n\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isOdd = function isOdd() {\n  return (this.low & 1) === 1;\n};\n\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isEven = function isEven() {\n  return (this.low & 1) === 0;\n};\n\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.equals = function equals(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\n    return false;\n  return this.high === other.high && this.low === other.low;\n};\n\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.eq = LongPrototype.equals;\n\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.notEquals = function notEquals(other) {\n  return !this.eq(/* validates */ other);\n};\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.neq = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ne = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThan = function lessThan(other) {\n  return this.comp(/* validates */ other) < 0;\n};\n\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lt = LongPrototype.lessThan;\n\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n  return this.comp(/* validates */ other) <= 0;\n};\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.le = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThan = function greaterThan(other) {\n  return this.comp(/* validates */ other) > 0;\n};\n\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gt = LongPrototype.greaterThan;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n  return this.comp(/* validates */ other) >= 0;\n};\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\n\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.compare = function compare(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  if (this.eq(other))\n    return 0;\n  var thisNeg = this.isNegative(),\n    otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg)\n    return -1;\n  if (!thisNeg && otherNeg)\n    return 1;\n  // At this point the sign bits are the same\n  if (!this.unsigned)\n    return this.sub(other).isNegative() ? -1 : 1;\n  // Both are positive if at least one is unsigned\n  return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\n};\n\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.comp = LongPrototype.compare;\n\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\nLongPrototype.negate = function negate() {\n  if (!this.unsigned && this.eq(MIN_VALUE))\n    return MIN_VALUE;\n  return this.not().add(ONE);\n};\n\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\nLongPrototype.neg = LongPrototype.negate;\n\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} addend Addend\n * @returns {!Long} Sum\n */\nLongPrototype.add = function add(addend) {\n  if (!isLong(addend))\n    addend = fromValue(addend);\n\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 0xFFFF;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 0xFFFF;\n\n  var b48 = addend.high >>> 16;\n  var b32 = addend.high & 0xFFFF;\n  var b16 = addend.low >>> 16;\n  var b00 = addend.low & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.subtract = function subtract(subtrahend) {\n  if (!isLong(subtrahend))\n    subtrahend = fromValue(subtrahend);\n  return this.add(subtrahend.neg());\n};\n\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.sub = LongPrototype.subtract;\n\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.multiply = function multiply(multiplier) {\n  if (this.isZero())\n    return this;\n  if (!isLong(multiplier))\n    multiplier = fromValue(multiplier);\n\n  // use wasm support if present\n  if (wasm) {\n    var low = wasm[\"mul\"](this.low,\n      this.high,\n      multiplier.low,\n      multiplier.high);\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  if (multiplier.isZero())\n    return this.unsigned ? UZERO : ZERO;\n  if (this.eq(MIN_VALUE))\n    return multiplier.isOdd() ? MIN_VALUE : ZERO;\n  if (multiplier.eq(MIN_VALUE))\n    return this.isOdd() ? MIN_VALUE : ZERO;\n\n  if (this.isNegative()) {\n    if (multiplier.isNegative())\n      return this.neg().mul(multiplier.neg());\n    else\n      return this.neg().mul(multiplier).neg();\n  } else if (multiplier.isNegative())\n    return this.mul(multiplier.neg()).neg();\n\n  // If both longs are small, use float multiplication\n  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 0xFFFF;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 0xFFFF;\n\n  var b48 = multiplier.high >>> 16;\n  var b32 = multiplier.high & 0xFFFF;\n  var b16 = multiplier.low >>> 16;\n  var b00 = multiplier.low & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.mul = LongPrototype.multiply;\n\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.divide = function divide(divisor) {\n  if (!isLong(divisor))\n    divisor = fromValue(divisor);\n  if (divisor.isZero())\n    throw Error('division by zero');\n\n  // use wasm support if present\n  if (wasm) {\n    // guard against signed division overflow: the largest\n    // negative number / -1 would be 1 larger than the largest\n    // positive number, due to two's complement.\n    if (!this.unsigned &&\n      this.high === -0x80000000 &&\n      divisor.low === -1 && divisor.high === -1) {\n      // be consistent with non-wasm code path\n      return this;\n    }\n    var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(\n      this.low,\n      this.high,\n      divisor.low,\n      divisor.high\n    );\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  if (this.isZero())\n    return this.unsigned ? UZERO : ZERO;\n  var approx, rem, res;\n  if (!this.unsigned) {\n    // This section is only relevant for signed longs and is derived from the\n    // closure library as a whole.\n    if (this.eq(MIN_VALUE)) {\n      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n        return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n      else if (divisor.eq(MIN_VALUE))\n        return ONE;\n      else {\n        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n        var halfThis = this.shr(1);\n        approx = halfThis.div(divisor).shl(1);\n        if (approx.eq(ZERO)) {\n          return divisor.isNegative() ? ONE : NEG_ONE;\n        } else {\n          rem = this.sub(divisor.mul(approx));\n          res = approx.add(rem.div(divisor));\n          return res;\n        }\n      }\n    } else if (divisor.eq(MIN_VALUE))\n      return this.unsigned ? UZERO : ZERO;\n    if (this.isNegative()) {\n      if (divisor.isNegative())\n        return this.neg().div(divisor.neg());\n      return this.neg().div(divisor).neg();\n    } else if (divisor.isNegative())\n      return this.div(divisor.neg()).neg();\n    res = ZERO;\n  } else {\n    // The algorithm below has not been made for unsigned longs. It's therefore\n    // required to take special care of the MSB prior to running it.\n    if (!divisor.unsigned)\n      divisor = divisor.toUnsigned();\n    if (divisor.gt(this))\n      return UZERO;\n    if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n      return UONE;\n    res = UZERO;\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  rem = this;\n  while (rem.gte(divisor)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n      delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\n\n      // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      approxRes = fromNumber(approx),\n      approxRem = approxRes.mul(divisor);\n    while (approxRem.isNegative() || approxRem.gt(rem)) {\n      approx -= delta;\n      approxRes = fromNumber(approx, this.unsigned);\n      approxRem = approxRes.mul(divisor);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero())\n      approxRes = ONE;\n\n    res = res.add(approxRes);\n    rem = rem.sub(approxRem);\n  }\n  return res;\n};\n\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.div = LongPrototype.divide;\n\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.modulo = function modulo(divisor) {\n  if (!isLong(divisor))\n    divisor = fromValue(divisor);\n\n  // use wasm support if present\n  if (wasm) {\n    var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(\n      this.low,\n      this.high,\n      divisor.low,\n      divisor.high\n    );\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  return this.sub(this.div(divisor).mul(divisor));\n};\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.mod = LongPrototype.modulo;\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.rem = LongPrototype.modulo;\n\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\nLongPrototype.not = function not() {\n  return fromBits(~this.low, ~this.high, this.unsigned);\n};\n\n/**\n * Returns count leading zeros of this Long.\n * @this {!Long}\n * @returns {!number}\n */\nLongPrototype.countLeadingZeros = function countLeadingZeros() {\n  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n};\n\n/**\n * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n * @function\n * @param {!Long}\n * @returns {!number}\n */\nLongPrototype.clz = LongPrototype.countLeadingZeros;\n\n/**\n * Returns count trailing zeros of this Long.\n * @this {!Long}\n * @returns {!number}\n */\nLongPrototype.countTrailingZeros = function countTrailingZeros() {\n  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n};\n\n/**\n * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n * @function\n * @param {!Long}\n * @returns {!number}\n */\nLongPrototype.ctz = LongPrototype.countTrailingZeros;\n\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.and = function and(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.or = function or(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.xor = function xor(other) {\n  if (!isLong(other))\n    other = fromValue(other);\n  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  if ((numBits &= 63) === 0)\n    return this;\n  else if (numBits < 32)\n    return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\n  else\n    return fromBits(0, this.low << (numBits - 32), this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shl = LongPrototype.shiftLeft;\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRight = function shiftRight(numBits) {\n  if (isLong(numBits))\n    numBits = numBits.toInt();\n  if ((numBits &= 63) === 0)\n    return this;\n  else if (numBits < 32)\n    return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\n  else\n    return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\n};\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr = LongPrototype.shiftRight;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits < 32) return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >>> numBits, this.unsigned);\n  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n  return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);\n};\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateLeft = function rotateLeft(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  if (numBits < 32) {\n    b = (32 - numBits);\n    return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);\n  }\n  numBits -= 32;\n  b = (32 - numBits);\n  return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);\n}\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotl = LongPrototype.rotateLeft;\n\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateRight = function rotateRight(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  if (numBits < 32) {\n    b = (32 - numBits);\n    return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);\n  }\n  numBits -= 32;\n  b = (32 - numBits);\n  return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);\n}\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotr = LongPrototype.rotateRight;\n\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\nLongPrototype.toSigned = function toSigned() {\n  if (!this.unsigned)\n    return this;\n  return fromBits(this.low, this.high, false);\n};\n\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\nLongPrototype.toUnsigned = function toUnsigned() {\n  if (this.unsigned)\n    return this;\n  return fromBits(this.low, this.high, true);\n};\n\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\nLongPrototype.toBytes = function toBytes(le) {\n  return le ? this.toBytesLE() : this.toBytesBE();\n};\n\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\nLongPrototype.toBytesLE = function toBytesLE() {\n  var hi = this.high,\n    lo = this.low;\n  return [\n    lo & 0xff,\n    lo >>> 8 & 0xff,\n    lo >>> 16 & 0xff,\n    lo >>> 24,\n    hi & 0xff,\n    hi >>> 8 & 0xff,\n    hi >>> 16 & 0xff,\n    hi >>> 24\n  ];\n};\n\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\nLongPrototype.toBytesBE = function toBytesBE() {\n  var hi = this.high,\n    lo = this.low;\n  return [\n    hi >>> 24,\n    hi >>> 16 & 0xff,\n    hi >>> 8 & 0xff,\n    hi & 0xff,\n    lo >>> 24,\n    lo >>> 16 & 0xff,\n    lo >>> 8 & 0xff,\n    lo & 0xff\n  ];\n};\n\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\n  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n};\n\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n  return new Long(\n    bytes[0] |\n    bytes[1] << 8 |\n    bytes[2] << 16 |\n    bytes[3] << 24,\n    bytes[4] |\n    bytes[5] << 8 |\n    bytes[6] << 16 |\n    bytes[7] << 24,\n    unsigned\n  );\n};\n\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n  return new Long(\n    bytes[4] << 24 |\n    bytes[5] << 16 |\n    bytes[6] << 8 |\n    bytes[7],\n    bytes[0] << 24 |\n    bytes[1] << 16 |\n    bytes[2] << 8 |\n    bytes[3],\n    unsigned\n  );\n};\n\nexport default Long;\n","/// @file\n/// @addtogroup flatbuffers_javascript_api\n/// @{\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @fileoverview\n *\n * Need to suppress 'global this' error so the Node.js export line doesn't cause\n * closure compile to error out.\n * @suppress {globalThis}\n */\n\n/**\n * @const\n * @namespace\n */\nvar flatbuffers = {};\n\n/**\n * @typedef {number}\n */\nflatbuffers.Offset;\n\n/**\n * @typedef {{\n *   bb: flatbuffers.ByteBuffer,\n *   bb_pos: number\n * }}\n */\nflatbuffers.Table;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_SHORT = 2;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_INT = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.FILE_IDENTIFIER_LENGTH = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZE_PREFIX_LENGTH = 4;\n\n/**\n * @enum {number}\n */\nflatbuffers.Encoding = {\n  UTF8_BYTES: 1,\n  UTF16_STRING: 2\n};\n\n/**\n * @type {Int32Array}\n * @const\n */\nflatbuffers.int32 = new Int32Array(2);\n\n/**\n * @type {Float32Array}\n * @const\n */\nflatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);\n\n/**\n * @type {Float64Array}\n * @const\n */\nflatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);\n\n/**\n * @type {boolean}\n * @const\n */\nflatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @constructor\n * @param {number} low\n * @param {number} high\n */\nflatbuffers.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @const\n   */\n  this.low = low | 0;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  this.high = high | 0;\n};\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Long.create = function(low, high) {\n  // Special-case zero to avoid GC overhead for default values\n  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);\n};\n\n/**\n * @returns {number}\n */\nflatbuffers.Long.prototype.toFloat64 = function() {\n  return (this.low >>> 0) + this.high * 0x100000000;\n};\n\n/**\n * @param {flatbuffers.Long} other\n * @returns {boolean}\n */\nflatbuffers.Long.prototype.equals = function(other) {\n  return this.low == other.low && this.high == other.high;\n};\n\n/**\n * @type {!flatbuffers.Long}\n * @const\n */\nflatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);\n\n/// @endcond\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a FlatBufferBuilder.\n *\n * @constructor\n * @param {number=} opt_initial_size\n */\nflatbuffers.Builder = function(opt_initial_size) {\n  if (!opt_initial_size) {\n    var initial_size = 1024;\n  } else {\n    var initial_size = opt_initial_size;\n  }\n\n  /**\n   * @type {flatbuffers.ByteBuffer}\n   * @private\n   */\n  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);\n\n  /**\n   * Remaining space in the ByteBuffer.\n   *\n   * @type {number}\n   * @private\n   */\n  this.space = initial_size;\n\n  /**\n   * Minimum alignment encountered so far.\n   *\n   * @type {number}\n   * @private\n   */\n  this.minalign = 1;\n\n  /**\n   * The vtable for the current table.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtable = null;\n\n  /**\n   * The amount of fields we're actually using.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vtable_in_use = 0;\n\n  /**\n   * Whether we are currently serializing a table.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.isNested = false;\n\n  /**\n   * Starting offset of the current struct/table.\n   *\n   * @type {number}\n   * @private\n   */\n  this.object_start = 0;\n\n  /**\n   * List of offsets of all vtables.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtables = [];\n\n  /**\n   * For the current vector being built.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vector_num_elems = 0;\n\n  /**\n   * False omits default values from the serialized data\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.force_defaults = false;\n};\n\nflatbuffers.Builder.prototype.clear = function() {\n  this.bb.clear();\n  this.space = this.bb.capacity();\n  this.minalign = 1;\n  this.vtable = null;\n  this.vtable_in_use = 0;\n  this.isNested = false;\n  this.object_start = 0;\n  this.vtables = [];\n  this.vector_num_elems = 0;\n  this.force_defaults = false;\n};\n\n/**\n * In order to save space, fields that are set to their default value\n * don't get serialized into the buffer. Forcing defaults provides a\n * way to manually disable this optimization.\n *\n * @param {boolean} forceDefaults true always serializes default values\n */\nflatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {\n  this.force_defaults = forceDefaults;\n};\n\n/**\n * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n * called finish(). The actual data starts at the ByteBuffer's current position,\n * not necessarily at 0.\n *\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.Builder.prototype.dataBuffer = function() {\n  return this.bb;\n};\n\n/**\n * Get the bytes representing the FlatBuffer. Only call this after you've\n * called finish().\n *\n * @returns {!Uint8Array}\n */\nflatbuffers.Builder.prototype.asUint8Array = function() {\n  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Prepare to write an element of `size` after `additional_bytes` have been\n * written, e.g. if you write a string, you need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * you need to do is alignment, `additional_bytes` will be 0.\n *\n * @param {number} size This is the of the new element to write\n * @param {number} additional_bytes The padding size\n */\nflatbuffers.Builder.prototype.prep = function(size, additional_bytes) {\n  // Track the biggest thing we've ever aligned to.\n  if (size > this.minalign) {\n    this.minalign = size;\n  }\n\n  // Find the amount of alignment needed such that `size` is properly\n  // aligned after `additional_bytes`\n  var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n\n  // Reallocate the buffer if needed.\n  while (this.space < align_size + size + additional_bytes) {\n    var old_buf_size = this.bb.capacity();\n    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);\n    this.space += this.bb.capacity() - old_buf_size;\n  }\n\n  this.pad(align_size);\n};\n\n/**\n * @param {number} byte_size\n */\nflatbuffers.Builder.prototype.pad = function(byte_size) {\n  for (var i = 0; i < byte_size; i++) {\n    this.bb.writeInt8(--this.space, 0);\n  }\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt8 = function(value) {\n  this.bb.writeInt8(this.space -= 1, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt16 = function(value) {\n  this.bb.writeInt16(this.space -= 2, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt32 = function(value) {\n  this.bb.writeInt32(this.space -= 4, value);\n};\n\n/**\n * @param {flatbuffers.Long} value\n */\nflatbuffers.Builder.prototype.writeInt64 = function(value) {\n  this.bb.writeInt64(this.space -= 8, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat32 = function(value) {\n  this.bb.writeFloat32(this.space -= 4, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat64 = function(value) {\n  this.bb.writeFloat64(this.space -= 8, value);\n};\n/// @endcond\n\n/**\n * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int8` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt8 = function(value) {\n  this.prep(1, 0);\n  this.writeInt8(value);\n};\n\n/**\n * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int16` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt16 = function(value) {\n  this.prep(2, 0);\n  this.writeInt16(value);\n};\n\n/**\n * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt32 = function(value) {\n  this.prep(4, 0);\n  this.writeInt32(value);\n};\n\n/**\n * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {flatbuffers.Long} value The `int64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt64 = function(value) {\n  this.prep(8, 0);\n  this.writeInt64(value);\n};\n\n/**\n * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat32 = function(value) {\n  this.prep(4, 0);\n  this.writeFloat32(value);\n};\n\n/**\n * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat64 = function(value) {\n  this.prep(8, 0);\n  this.writeFloat64(value);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt8(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt16(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Long} value\n * @param {flatbuffers.Long} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || !value.equals(defaultValue)) {\n    this.addInt64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addOffset(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n *\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {\n  if (value != defaultValue) {\n    this.nested(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structures are always stored inline, they need to be created right\n * where they're used.  You'll get this assertion failure if you\n * created it elsewhere.\n *\n * @param {flatbuffers.Offset} obj The offset of the created object\n */\nflatbuffers.Builder.prototype.nested = function(obj) {\n  if (obj != this.offset()) {\n    throw new Error('FlatBuffers: struct must be serialized inline.');\n  }\n};\n\n/**\n * Should not be creating any other object, string or vector\n * while an object is being constructed\n */\nflatbuffers.Builder.prototype.notNested = function() {\n  if (this.isNested) {\n    throw new Error('FlatBuffers: object serialization must not be nested.');\n  }\n};\n\n/**\n * Set the current vtable at `voffset` to the current location in the buffer.\n *\n * @param {number} voffset\n */\nflatbuffers.Builder.prototype.slot = function(voffset) {\n  this.vtable[voffset] = this.offset();\n};\n\n/**\n * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n */\nflatbuffers.Builder.prototype.offset = function() {\n  return this.bb.capacity() - this.space;\n};\n\n/**\n * Doubles the size of the backing ByteBuffer and copies the old data towards\n * the end of the new buffer (since we build the buffer backwards).\n *\n * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n * @returns {!flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n * to it. The data is located at the end of the buffer.\n *\n * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n * it a uint8Array we need to suppress the type check:\n * @suppress {checkTypes}\n */\nflatbuffers.Builder.growByteBuffer = function(bb) {\n  var old_buf_size = bb.capacity();\n\n  // Ensure we don't grow beyond what fits in an int.\n  if (old_buf_size & 0xC0000000) {\n    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n  }\n\n  var new_buf_size = old_buf_size << 1;\n  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);\n  nbb.setPosition(new_buf_size - old_buf_size);\n  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n  return nbb;\n};\n/// @endcond\n\n/**\n * Adds on offset, relative to where it will be written.\n *\n * @param {flatbuffers.Offset} offset The offset to add.\n */\nflatbuffers.Builder.prototype.addOffset = function(offset) {\n  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.\n  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Start encoding a new object in the buffer.  Users will not usually need to\n * call this directly. The FlatBuffers compiler will generate helper methods\n * that call this method internally.\n *\n * @param {number} numfields\n */\nflatbuffers.Builder.prototype.startObject = function(numfields) {\n  this.notNested();\n  if (this.vtable == null) {\n    this.vtable = [];\n  }\n  this.vtable_in_use = numfields;\n  for (var i = 0; i < numfields; i++) {\n    this.vtable[i] = 0; // This will push additional elements as needed\n  }\n  this.isNested = true;\n  this.object_start = this.offset();\n};\n\n/**\n * Finish off writing the object that is under construction.\n *\n * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n */\nflatbuffers.Builder.prototype.endObject = function() {\n  if (this.vtable == null || !this.isNested) {\n    throw new Error('FlatBuffers: endObject called without startObject');\n  }\n\n  this.addInt32(0);\n  var vtableloc = this.offset();\n\n  // Trim trailing zeroes.\n  var i = this.vtable_in_use - 1;\n  for (; i >= 0 && this.vtable[i] == 0; i--) {}\n  var trimmed_size = i + 1;\n\n  // Write out the current vtable.\n  for (; i >= 0; i--) {\n    // Offset relative to the start of the table.\n    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n  }\n\n  var standard_fields = 2; // The fields below:\n  this.addInt16(vtableloc - this.object_start);\n  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;\n  this.addInt16(len);\n\n  // Search for an existing vtable that matches the current one.\n  var existing_vtable = 0;\n  var vt1 = this.space;\nouter_loop:\n  for (i = 0; i < this.vtables.length; i++) {\n    var vt2 = this.bb.capacity() - this.vtables[i];\n    if (len == this.bb.readInt16(vt2)) {\n      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {\n        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n          continue outer_loop;\n        }\n      }\n      existing_vtable = this.vtables[i];\n      break;\n    }\n  }\n\n  if (existing_vtable) {\n    // Found a match:\n    // Remove the current vtable.\n    this.space = this.bb.capacity() - vtableloc;\n\n    // Point table to existing vtable.\n    this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n  } else {\n    // No match:\n    // Add the location of the current vtable to the list of vtables.\n    this.vtables.push(this.offset());\n\n    // Point table to current vtable.\n    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n  }\n\n  this.isNested = false;\n  return vtableloc;\n};\n/// @endcond\n\n/**\n * Finalize a buffer, poiting to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n * @param {boolean=} opt_size_prefix\n */\nflatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {\n  var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;\n  if (opt_file_identifier) {\n    var file_identifier = opt_file_identifier;\n    this.prep(this.minalign, flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);\n    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' +\n        flatbuffers.FILE_IDENTIFIER_LENGTH);\n    }\n    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n      this.writeInt8(file_identifier.charCodeAt(i));\n    }\n  }\n  this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);\n  this.addOffset(root_table);\n  if (size_prefix) {\n    this.addInt32(this.bb.capacity() - this.space);\n  }\n  this.bb.setPosition(this.space);\n};\n\n/**\n * Finalize a size prefixed buffer, pointing to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n */\nflatbuffers.Builder.prototype.finishSizePrefixed = function (root_table, opt_file_identifier) {\n  this.finish(root_table, opt_file_identifier, true);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * This checks a required field has been set in a given table that has\n * just been constructed.\n *\n * @param {flatbuffers.Offset} table\n * @param {number} field\n */\nflatbuffers.Builder.prototype.requiredField = function(table, field) {\n  var table_start = this.bb.capacity() - table;\n  var vtable_start = table_start - this.bb.readInt32(table_start);\n  var ok = this.bb.readInt16(vtable_start + field) != 0;\n\n  // If this fails, the caller will show what field needs to be set.\n  if (!ok) {\n    throw new Error('FlatBuffers: field ' + field + ' must be set');\n  }\n};\n\n/**\n * Start a new array/vector of objects.  Users usually will not call\n * this directly. The FlatBuffers compiler will create a start/end\n * method for vector types in generated code.\n *\n * @param {number} elem_size The size of each element in the array\n * @param {number} num_elems The number of elements in the array\n * @param {number} alignment The alignment of the array\n */\nflatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {\n  this.notNested();\n  this.vector_num_elems = num_elems;\n  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);\n  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n};\n\n/**\n * Finish off the creation of an array and all its elements. The array must be\n * created with `startVector`.\n *\n * @returns {flatbuffers.Offset} The offset at which the newly created array\n * starts.\n */\nflatbuffers.Builder.prototype.endVector = function() {\n  this.writeInt32(this.vector_num_elems);\n  return this.offset();\n};\n/// @endcond\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\nflatbuffers.Builder.prototype.createString = function(s) {\n  if (s instanceof Uint8Array) {\n    var utf8 = s;\n  } else {\n    var utf8 = [];\n    var i = 0;\n\n    while (i < s.length) {\n      var codePoint;\n\n      // Decode UTF-16\n      var a = s.charCodeAt(i++);\n      if (a < 0xD800 || a >= 0xDC00) {\n        codePoint = a;\n      } else {\n        var b = s.charCodeAt(i++);\n        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\n      }\n\n      // Encode UTF-8\n      if (codePoint < 0x80) {\n        utf8.push(codePoint);\n      } else {\n        if (codePoint < 0x800) {\n          utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);\n        } else {\n          if (codePoint < 0x10000) {\n            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);\n          } else {\n            utf8.push(\n              ((codePoint >> 18) & 0x07) | 0xF0,\n              ((codePoint >> 12) & 0x3F) | 0x80);\n          }\n          utf8.push(((codePoint >> 6) & 0x3F) | 0x80);\n        }\n        utf8.push((codePoint & 0x3F) | 0x80);\n      }\n    }\n  }\n\n  this.addInt8(0);\n  this.startVector(1, utf8.length, 1);\n  this.bb.setPosition(this.space -= utf8.length);\n  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n    bytes[offset++] = utf8[i];\n  }\n  return this.endVector();\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Builder.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n////////////////////////////////////////////////////////////////////////////////\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).\n *\n * @constructor\n * @param {Uint8Array} bytes\n */\nflatbuffers.ByteBuffer = function(bytes) {\n  /**\n   * @type {Uint8Array}\n   * @private\n   */\n  this.bytes_ = bytes;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * Create and allocate a new ByteBuffer with a given size.\n *\n * @param {number} byte_size\n * @returns {!flatbuffers.ByteBuffer}\n */\nflatbuffers.ByteBuffer.allocate = function(byte_size) {\n  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));\n};\n\nflatbuffers.ByteBuffer.prototype.clear = function() {\n  this.position_ = 0;\n};\n\n/**\n * Get the underlying `Uint8Array`.\n *\n * @returns {Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.bytes = function() {\n  return this.bytes_;\n};\n\n/**\n * Get the buffer's position.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.position = function() {\n  return this.position_;\n};\n\n/**\n * Set the buffer's position.\n *\n * @param {number} position\n */\nflatbuffers.ByteBuffer.prototype.setPosition = function(position) {\n  this.position_ = position;\n};\n\n/**\n * Get the buffer's capacity.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.capacity = function() {\n  return this.bytes_.length;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {\n  return this.readUint8(offset) << 24 >> 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {\n  return this.bytes_[offset];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {\n  return this.readUint16(offset) << 16 >> 16;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {\n  return this.readInt32(offset) >>> 0;\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {\n  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {\n  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {\n  flatbuffers.int32[0] = this.readInt32(offset);\n  return flatbuffers.float32[0];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n  return flatbuffers.float64[0];\n};\n\n/**\n * @param {number} offset\n * @param {number|boolean} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {\n  this.bytes_[offset] = /** @type {number} */(value);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {\n  this.bytes_[offset] = value;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {\n  this.writeInt32(offset, value.low);\n  this.writeInt32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {\n    this.writeUint32(offset, value.low);\n    this.writeUint32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {\n  flatbuffers.float32[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[0]);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {\n  flatbuffers.float64[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);\n  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);\n};\n\n/**\n * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n * schema does not include a file_identifier (likely points at padding or the\n * start of a the root vtable).\n * @returns {string}\n */\nflatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {\n  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error(\n        'FlatBuffers: ByteBuffer is too short to contain an identifier.');\n  }\n  var result = \"\";\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    result += String.fromCharCode(\n        this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));\n  }\n  return result;\n};\n\n/**\n * Look up a field in the vtable, return an offset into the object, or 0 if the\n * field is not present.\n *\n * @param {number} bb_pos\n * @param {number} vtable_offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {\n  var vtable = bb_pos - this.readInt32(bb_pos);\n  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n};\n\n/**\n * Initialize any Table-derived type to point to the union at the given offset.\n *\n * @param {flatbuffers.Table} t\n * @param {number} offset\n * @returns {flatbuffers.Table}\n */\nflatbuffers.ByteBuffer.prototype.__union = function(t, offset) {\n  t.bb_pos = offset + this.readInt32(offset);\n  t.bb = this;\n  return t;\n};\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n *\n * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n * and from UTF-16 when the data will just be packaged back up in another\n * FlatBuffer later on.\n *\n * @param {number} offset\n * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING\n * @returns {string|!Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {\n  offset += this.readInt32(offset);\n\n  var length = this.readInt32(offset);\n  var result = '';\n  var i = 0;\n\n  offset += flatbuffers.SIZEOF_INT;\n\n  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {\n    return this.bytes_.subarray(offset, offset + length);\n  }\n\n  while (i < length) {\n    var codePoint;\n\n    // Decode UTF-8\n    var a = this.readUint8(offset + i++);\n    if (a < 0xC0) {\n      codePoint = a;\n    } else {\n      var b = this.readUint8(offset + i++);\n      if (a < 0xE0) {\n        codePoint =\n          ((a & 0x1F) << 6) |\n          (b & 0x3F);\n      } else {\n        var c = this.readUint8(offset + i++);\n        if (a < 0xF0) {\n          codePoint =\n            ((a & 0x0F) << 12) |\n            ((b & 0x3F) << 6) |\n            (c & 0x3F);\n        } else {\n          var d = this.readUint8(offset + i++);\n          codePoint =\n            ((a & 0x07) << 18) |\n            ((b & 0x3F) << 12) |\n            ((c & 0x3F) << 6) |\n            (d & 0x3F);\n        }\n      }\n    }\n\n    // Encode UTF-16\n    if (codePoint < 0x10000) {\n      result += String.fromCharCode(codePoint);\n    } else {\n      codePoint -= 0x10000;\n      result += String.fromCharCode(\n        (codePoint >> 10) + 0xD800,\n        (codePoint & ((1 << 10) - 1)) + 0xDC00);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Retrieve the relative offset stored at \"offset\"\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__indirect = function(offset) {\n  return offset + this.readInt32(offset);\n};\n\n/**\n * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector = function(offset) {\n  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length\n};\n\n/**\n * Get the length of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {\n  return this.readInt32(offset + this.readInt32(offset));\n};\n\n/**\n * @param {string} ident\n * @returns {boolean}\n */\nflatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {\n  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: file identifier must be length ' +\n                    flatbuffers.FILE_IDENTIFIER_LENGTH);\n  }\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n// Exports for Node.js and RequireJS\nexport { flatbuffers };\n\n/// @endcond\n/// @}\n","// automatically generated by the FlatBuffers compiler, do not modify\n/* eslint-disable */\n\nimport { flatbuffers } from 'flatbuffers';\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum AttributeType {\n    UNDEFINED = 0,\n    FLOAT = 1,\n    INT = 2,\n    STRING = 3,\n    TENSOR = 4,\n    GRAPH = 5,\n    FLOATS = 6,\n    INTS = 7,\n    STRINGS = 8,\n    TENSORS = 9,\n    GRAPHS = 10,\n    SPARSE_TENSOR = 11,\n    SPARSE_TENSORS = 12,\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum DimensionValueType {\n    UNKNOWN = 0,\n    VALUE = 1,\n    PARAM = 2,\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum TensorDataType {\n    UNDEFINED = 0,\n    FLOAT = 1,\n    UINT8 = 2,\n    INT8 = 3,\n    UINT16 = 4,\n    INT16 = 5,\n    INT32 = 6,\n    INT64 = 7,\n    STRING = 8,\n    BOOL = 9,\n    FLOAT16 = 10,\n    DOUBLE = 11,\n    UINT32 = 12,\n    UINT64 = 13,\n    COMPLEX64 = 14,\n    COMPLEX128 = 15,\n    BFLOAT16 = 16,\n    FLOAT8E4M3FN = 17,\n    FLOAT8E4M3FNUZ = 18,\n    FLOAT8E5M2 = 19,\n    FLOAT8E5M2FNUZ = 20,\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum NodeType {\n    Primitive = 0,\n    Fused = 1,\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum TypeInfoValue {\n    NONE = 0,\n    tensor_type = 1,\n    sequence_type = 2,\n    map_type = 3,\n  }\n}\n\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Shape {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Shape\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Shape {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Shape= obj\n     * @returns Shape\n     */\n    static getRootAsShape(bb: flatbuffers.ByteBuffer, obj?: Shape): Shape {\n      return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Shape= obj\n     * @returns Shape\n     */\n    static getSizePrefixedRootAsShape(bb: flatbuffers.ByteBuffer, obj?: Shape): Shape {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Dimension= obj\n     * @returns onnxruntime.experimental.fbs.Dimension\n     */\n    dim(index: number, obj?: onnxruntime.experimental.fbs.Dimension): onnxruntime.experimental.fbs.Dimension | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Dimension()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    dimLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startShape(builder: flatbuffers.Builder) {\n      builder.startObject(1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimOffset\n     */\n    static addDim(builder: flatbuffers.Builder, dimOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, dimOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endShape(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createShape(builder: flatbuffers.Builder, dimOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Shape.startShape(builder);\n      Shape.addDim(builder, dimOffset);\n      return Shape.endShape(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Dimension {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Dimension\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Dimension {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Dimension= obj\n     * @returns Dimension\n     */\n    static getRootAsDimension(bb: flatbuffers.ByteBuffer, obj?: Dimension): Dimension {\n      return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Dimension= obj\n     * @returns Dimension\n     */\n    static getSizePrefixedRootAsDimension(bb: flatbuffers.ByteBuffer, obj?: Dimension): Dimension {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.DimensionValue= obj\n     * @returns onnxruntime.experimental.fbs.DimensionValue|null\n     */\n    value(obj?: onnxruntime.experimental.fbs.DimensionValue): onnxruntime.experimental.fbs.DimensionValue | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.DimensionValue()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    denotation(): string | null;\n    denotation(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    denotation(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startDimension(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueOffset\n     */\n    static addValue(builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, valueOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset denotationOffset\n     */\n    static addDenotation(builder: flatbuffers.Builder, denotationOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, denotationOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endDimension(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createDimension(\n      builder: flatbuffers.Builder,\n      valueOffset: flatbuffers.Offset,\n      denotationOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Dimension.startDimension(builder);\n      Dimension.addValue(builder, valueOffset);\n      Dimension.addDenotation(builder, denotationOffset);\n      return Dimension.endDimension(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class DimensionValue {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns DimensionValue\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): DimensionValue {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param DimensionValue= obj\n     * @returns DimensionValue\n     */\n    static getRootAsDimensionValue(bb: flatbuffers.ByteBuffer, obj?: DimensionValue): DimensionValue {\n      return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param DimensionValue= obj\n     * @returns DimensionValue\n     */\n    static getSizePrefixedRootAsDimensionValue(bb: flatbuffers.ByteBuffer, obj?: DimensionValue): DimensionValue {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.DimensionValueType\n     */\n    dimType(): onnxruntime.experimental.fbs.DimensionValueType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? /**  */ this.bb!.readInt8(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    dimValue(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    dimParam(): string | null;\n    dimParam(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    dimParam(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startDimensionValue(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.DimensionValueType dimType\n     */\n    static addDimType(builder: flatbuffers.Builder, dimType: onnxruntime.experimental.fbs.DimensionValueType) {\n      builder.addFieldInt8(0, dimType, onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long dimValue\n     */\n    static addDimValue(builder: flatbuffers.Builder, dimValue: flatbuffers.Long) {\n      builder.addFieldInt64(1, dimValue, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimParamOffset\n     */\n    static addDimParam(builder: flatbuffers.Builder, dimParamOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimParamOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endDimensionValue(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createDimensionValue(\n      builder: flatbuffers.Builder,\n      dimType: onnxruntime.experimental.fbs.DimensionValueType,\n      dimValue: flatbuffers.Long,\n      dimParamOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      DimensionValue.startDimensionValue(builder);\n      DimensionValue.addDimType(builder, dimType);\n      DimensionValue.addDimValue(builder, dimValue);\n      DimensionValue.addDimParam(builder, dimParamOffset);\n      return DimensionValue.endDimensionValue(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class TensorTypeAndShape {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns TensorTypeAndShape\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): TensorTypeAndShape {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TensorTypeAndShape= obj\n     * @returns TensorTypeAndShape\n     */\n    static getRootAsTensorTypeAndShape(bb: flatbuffers.ByteBuffer, obj?: TensorTypeAndShape): TensorTypeAndShape {\n      return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TensorTypeAndShape= obj\n     * @returns TensorTypeAndShape\n     */\n    static getSizePrefixedRootAsTensorTypeAndShape(\n      bb: flatbuffers.ByteBuffer,\n      obj?: TensorTypeAndShape,\n    ): TensorTypeAndShape {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    elemType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? /**  */ this.bb!.readInt32(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Shape= obj\n     * @returns onnxruntime.experimental.fbs.Shape|null\n     */\n    shape(obj?: onnxruntime.experimental.fbs.Shape): onnxruntime.experimental.fbs.Shape | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Shape()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTensorTypeAndShape(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType elemType\n     */\n    static addElemType(builder: flatbuffers.Builder, elemType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(0, elemType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset shapeOffset\n     */\n    static addShape(builder: flatbuffers.Builder, shapeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, shapeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTensorTypeAndShape(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTensorTypeAndShape(\n      builder: flatbuffers.Builder,\n      elemType: onnxruntime.experimental.fbs.TensorDataType,\n      shapeOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      TensorTypeAndShape.startTensorTypeAndShape(builder);\n      TensorTypeAndShape.addElemType(builder, elemType);\n      TensorTypeAndShape.addShape(builder, shapeOffset);\n      return TensorTypeAndShape.endTensorTypeAndShape(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class MapType {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns MapType\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): MapType {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param MapType= obj\n     * @returns MapType\n     */\n    static getRootAsMapType(bb: flatbuffers.ByteBuffer, obj?: MapType): MapType {\n      return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param MapType= obj\n     * @returns MapType\n     */\n    static getSizePrefixedRootAsMapType(bb: flatbuffers.ByteBuffer, obj?: MapType): MapType {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    keyType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? /**  */ this.bb!.readInt32(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    valueType(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.TypeInfo()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startMapType(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType keyType\n     */\n    static addKeyType(builder: flatbuffers.Builder, keyType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(0, keyType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueTypeOffset\n     */\n    static addValueType(builder: flatbuffers.Builder, valueTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, valueTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endMapType(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createMapType(\n      builder: flatbuffers.Builder,\n      keyType: onnxruntime.experimental.fbs.TensorDataType,\n      valueTypeOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      MapType.startMapType(builder);\n      MapType.addKeyType(builder, keyType);\n      MapType.addValueType(builder, valueTypeOffset);\n      return MapType.endMapType(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SequenceType {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SequenceType\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SequenceType {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SequenceType= obj\n     * @returns SequenceType\n     */\n    static getRootAsSequenceType(bb: flatbuffers.ByteBuffer, obj?: SequenceType): SequenceType {\n      return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SequenceType= obj\n     * @returns SequenceType\n     */\n    static getSizePrefixedRootAsSequenceType(bb: flatbuffers.ByteBuffer, obj?: SequenceType): SequenceType {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    elemType(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.TypeInfo()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSequenceType(builder: flatbuffers.Builder) {\n      builder.startObject(1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset elemTypeOffset\n     */\n    static addElemType(builder: flatbuffers.Builder, elemTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, elemTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSequenceType(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSequenceType(builder: flatbuffers.Builder, elemTypeOffset: flatbuffers.Offset): flatbuffers.Offset {\n      SequenceType.startSequenceType(builder);\n      SequenceType.addElemType(builder, elemTypeOffset);\n      return SequenceType.endSequenceType(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class EdgeEnd {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns EdgeEnd\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): EdgeEnd {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndex(): number {\n      return this.bb!.readUint32(this.bb_pos);\n    }\n\n    /**\n     * @returns number\n     */\n    srcArgIndex(): number {\n      return this.bb!.readInt32(this.bb_pos + 4);\n    }\n\n    /**\n     * @returns number\n     */\n    dstArgIndex(): number {\n      return this.bb!.readInt32(this.bb_pos + 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number node_index\n     * @param number src_arg_index\n     * @param number dst_arg_index\n     * @returns flatbuffers.Offset\n     */\n    static createEdgeEnd(\n      builder: flatbuffers.Builder,\n      node_index: number,\n      src_arg_index: number,\n      dst_arg_index: number,\n    ): flatbuffers.Offset {\n      builder.prep(4, 12);\n      builder.writeInt32(dst_arg_index);\n      builder.writeInt32(src_arg_index);\n      builder.writeInt32(node_index);\n      return builder.offset();\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class NodeEdge {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns NodeEdge\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): NodeEdge {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param NodeEdge= obj\n     * @returns NodeEdge\n     */\n    static getRootAsNodeEdge(bb: flatbuffers.ByteBuffer, obj?: NodeEdge): NodeEdge {\n      return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param NodeEdge= obj\n     * @returns NodeEdge\n     */\n    static getSizePrefixedRootAsNodeEdge(bb: flatbuffers.ByteBuffer, obj?: NodeEdge): NodeEdge {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndex(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.EdgeEnd= obj\n     * @returns onnxruntime.experimental.fbs.EdgeEnd\n     */\n    inputEdges(index: number, obj?: onnxruntime.experimental.fbs.EdgeEnd): onnxruntime.experimental.fbs.EdgeEnd | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.EdgeEnd()).__init(\n            this.bb!.__vector(this.bb_pos + offset) + index * 12,\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.EdgeEnd= obj\n     * @returns onnxruntime.experimental.fbs.EdgeEnd\n     */\n    outputEdges(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.EdgeEnd,\n    ): onnxruntime.experimental.fbs.EdgeEnd | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.EdgeEnd()).__init(\n            this.bb!.__vector(this.bb_pos + offset) + index * 12,\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startNodeEdge(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number nodeIndex\n     */\n    static addNodeIndex(builder: flatbuffers.Builder, nodeIndex: number) {\n      builder.addFieldInt32(0, nodeIndex, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputEdgesOffset\n     */\n    static addInputEdges(builder: flatbuffers.Builder, inputEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, inputEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(12, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputEdgesOffset\n     */\n    static addOutputEdges(builder: flatbuffers.Builder, outputEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, outputEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(12, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endNodeEdge(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createNodeEdge(\n      builder: flatbuffers.Builder,\n      nodeIndex: number,\n      inputEdgesOffset: flatbuffers.Offset,\n      outputEdgesOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      NodeEdge.startNodeEdge(builder);\n      NodeEdge.addNodeIndex(builder, nodeIndex);\n      NodeEdge.addInputEdges(builder, inputEdgesOffset);\n      NodeEdge.addOutputEdges(builder, outputEdgesOffset);\n      return NodeEdge.endNodeEdge(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Node {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Node\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Node {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Node= obj\n     * @returns Node\n     */\n    static getRootAsNode(bb: flatbuffers.ByteBuffer, obj?: Node): Node {\n      return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Node= obj\n     * @returns Node\n     */\n    static getSizePrefixedRootAsNode(bb: flatbuffers.ByteBuffer, obj?: Node): Node {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string | null;\n    name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    name(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string | null;\n    docString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    docString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string | null;\n    domain(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    domain(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    sinceVersion(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    index(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    opType(): string | null;\n    opType(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    opType(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.NodeType\n     */\n    type(): onnxruntime.experimental.fbs.NodeType {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset\n        ? /**  */ this.bb!.readInt32(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.NodeType.Primitive;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    executionProviderType(): string | null;\n    executionProviderType(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    executionProviderType(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    inputs(index: number): string;\n    inputs(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    inputs(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    outputs(index: number): string;\n    outputs(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    outputs(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Attribute= obj\n     * @returns onnxruntime.experimental.fbs.Attribute\n     */\n    attributes(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.Attribute,\n    ): onnxruntime.experimental.fbs.Attribute | null {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Attribute()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    attributesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    inputArgCounts(index: number): number | null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    inputArgCountsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Int32Array\n     */\n    inputArgCountsArray(): Int32Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset\n        ? new Int32Array(\n            this.bb!.bytes().buffer,\n            this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n            this.bb!.__vector_len(this.bb_pos + offset),\n          )\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    implicitInputs(index: number): string;\n    implicitInputs(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    implicitInputs(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    implicitInputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startNode(builder: flatbuffers.Builder) {\n      builder.startObject(13);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number sinceVersion\n     */\n    static addSinceVersion(builder: flatbuffers.Builder, sinceVersion: number) {\n      builder.addFieldInt32(3, sinceVersion, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number index\n     */\n    static addIndex(builder: flatbuffers.Builder, index: number) {\n      builder.addFieldInt32(4, index, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset opTypeOffset\n     */\n    static addOpType(builder: flatbuffers.Builder, opTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, opTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.NodeType type\n     */\n    static addType(builder: flatbuffers.Builder, type: onnxruntime.experimental.fbs.NodeType) {\n      builder.addFieldInt32(6, type, onnxruntime.experimental.fbs.NodeType.Primitive);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset executionProviderTypeOffset\n     */\n    static addExecutionProviderType(builder: flatbuffers.Builder, executionProviderTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, executionProviderTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputsOffset\n     */\n    static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, inputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputsOffset\n     */\n    static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(9, outputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOutputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset attributesOffset\n     */\n    static addAttributes(builder: flatbuffers.Builder, attributesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(10, attributesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createAttributesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startAttributesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputArgCountsOffset\n     */\n    static addInputArgCounts(builder: flatbuffers.Builder, inputArgCountsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(11, inputArgCountsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputArgCountsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputArgCountsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset implicitInputsOffset\n     */\n    static addImplicitInputs(builder: flatbuffers.Builder, implicitInputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(12, implicitInputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createImplicitInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startImplicitInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endNode(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createNode(\n      builder: flatbuffers.Builder,\n      nameOffset: flatbuffers.Offset,\n      docStringOffset: flatbuffers.Offset,\n      domainOffset: flatbuffers.Offset,\n      sinceVersion: number,\n      index: number,\n      opTypeOffset: flatbuffers.Offset,\n      type: onnxruntime.experimental.fbs.NodeType,\n      executionProviderTypeOffset: flatbuffers.Offset,\n      inputsOffset: flatbuffers.Offset,\n      outputsOffset: flatbuffers.Offset,\n      attributesOffset: flatbuffers.Offset,\n      inputArgCountsOffset: flatbuffers.Offset,\n      implicitInputsOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Node.startNode(builder);\n      Node.addName(builder, nameOffset);\n      Node.addDocString(builder, docStringOffset);\n      Node.addDomain(builder, domainOffset);\n      Node.addSinceVersion(builder, sinceVersion);\n      Node.addIndex(builder, index);\n      Node.addOpType(builder, opTypeOffset);\n      Node.addType(builder, type);\n      Node.addExecutionProviderType(builder, executionProviderTypeOffset);\n      Node.addInputs(builder, inputsOffset);\n      Node.addOutputs(builder, outputsOffset);\n      Node.addAttributes(builder, attributesOffset);\n      Node.addInputArgCounts(builder, inputArgCountsOffset);\n      Node.addImplicitInputs(builder, implicitInputsOffset);\n      return Node.endNode(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class ValueInfo {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns ValueInfo\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): ValueInfo {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param ValueInfo= obj\n     * @returns ValueInfo\n     */\n    static getRootAsValueInfo(bb: flatbuffers.ByteBuffer, obj?: ValueInfo): ValueInfo {\n      return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param ValueInfo= obj\n     * @returns ValueInfo\n     */\n    static getSizePrefixedRootAsValueInfo(bb: flatbuffers.ByteBuffer, obj?: ValueInfo): ValueInfo {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string | null;\n    name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    name(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string | null;\n    docString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    docString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    type(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.TypeInfo()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startValueInfo(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset typeOffset\n     */\n    static addType(builder: flatbuffers.Builder, typeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, typeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endValueInfo(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createValueInfo(\n      builder: flatbuffers.Builder,\n      nameOffset: flatbuffers.Offset,\n      docStringOffset: flatbuffers.Offset,\n      typeOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      ValueInfo.startValueInfo(builder);\n      ValueInfo.addName(builder, nameOffset);\n      ValueInfo.addDocString(builder, docStringOffset);\n      ValueInfo.addType(builder, typeOffset);\n      return ValueInfo.endValueInfo(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class TypeInfo {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns TypeInfo\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): TypeInfo {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TypeInfo= obj\n     * @returns TypeInfo\n     */\n    static getRootAsTypeInfo(bb: flatbuffers.ByteBuffer, obj?: TypeInfo): TypeInfo {\n      return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TypeInfo= obj\n     * @returns TypeInfo\n     */\n    static getSizePrefixedRootAsTypeInfo(bb: flatbuffers.ByteBuffer, obj?: TypeInfo): TypeInfo {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    denotation(): string | null;\n    denotation(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    denotation(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TypeInfoValue\n     */\n    valueType(): onnxruntime.experimental.fbs.TypeInfoValue {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? /**  */ this.bb!.readUint8(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.TypeInfoValue.NONE;\n    }\n\n    /**\n     * @param flatbuffers.Table obj\n     * @returns ?flatbuffers.Table\n     */\n    value<T extends flatbuffers.Table>(obj: T): T | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTypeInfo(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset denotationOffset\n     */\n    static addDenotation(builder: flatbuffers.Builder, denotationOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, denotationOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TypeInfoValue valueType\n     */\n    static addValueType(builder: flatbuffers.Builder, valueType: onnxruntime.experimental.fbs.TypeInfoValue) {\n      builder.addFieldInt8(1, valueType, onnxruntime.experimental.fbs.TypeInfoValue.NONE);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueOffset\n     */\n    static addValue(builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, valueOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTypeInfo(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTypeInfo(\n      builder: flatbuffers.Builder,\n      denotationOffset: flatbuffers.Offset,\n      valueType: onnxruntime.experimental.fbs.TypeInfoValue,\n      valueOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      TypeInfo.startTypeInfo(builder);\n      TypeInfo.addDenotation(builder, denotationOffset);\n      TypeInfo.addValueType(builder, valueType);\n      TypeInfo.addValue(builder, valueOffset);\n      return TypeInfo.endTypeInfo(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class OperatorSetId {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns OperatorSetId\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): OperatorSetId {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param OperatorSetId= obj\n     * @returns OperatorSetId\n     */\n    static getRootAsOperatorSetId(bb: flatbuffers.ByteBuffer, obj?: OperatorSetId): OperatorSetId {\n      return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param OperatorSetId= obj\n     * @returns OperatorSetId\n     */\n    static getSizePrefixedRootAsOperatorSetId(bb: flatbuffers.ByteBuffer, obj?: OperatorSetId): OperatorSetId {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string | null;\n    domain(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    domain(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    version(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startOperatorSetId(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long version\n     */\n    static addVersion(builder: flatbuffers.Builder, version: flatbuffers.Long) {\n      builder.addFieldInt64(1, version, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endOperatorSetId(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createOperatorSetId(\n      builder: flatbuffers.Builder,\n      domainOffset: flatbuffers.Offset,\n      version: flatbuffers.Long,\n    ): flatbuffers.Offset {\n      OperatorSetId.startOperatorSetId(builder);\n      OperatorSetId.addDomain(builder, domainOffset);\n      OperatorSetId.addVersion(builder, version);\n      return OperatorSetId.endOperatorSetId(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Tensor {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Tensor\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Tensor {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Tensor= obj\n     * @returns Tensor\n     */\n    static getRootAsTensor(bb: flatbuffers.ByteBuffer, obj?: Tensor): Tensor {\n      return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Tensor= obj\n     * @returns Tensor\n     */\n    static getSizePrefixedRootAsTensor(bb: flatbuffers.ByteBuffer, obj?: Tensor): Tensor {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string | null;\n    name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    name(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string | null;\n    docString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    docString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    dims(index: number): flatbuffers.Long | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8)\n        : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    dimsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    dataType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset\n        ? /**  */ this.bb!.readInt32(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    rawData(index: number): number | null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    rawDataLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Uint8Array\n     */\n    rawDataArray(): Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset\n        ? new Uint8Array(\n            this.bb!.bytes().buffer,\n            this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n            this.bb!.__vector_len(this.bb_pos + offset),\n          )\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    stringData(index: number): string;\n    stringData(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    stringData(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    stringDataLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTensor(builder: flatbuffers.Builder) {\n      builder.startObject(6);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimsOffset\n     */\n    static addDims(builder: flatbuffers.Builder, dimsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType dataType\n     */\n    static addDataType(builder: flatbuffers.Builder, dataType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(3, dataType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset rawDataOffset\n     */\n    static addRawData(builder: flatbuffers.Builder, rawDataOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, rawDataOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createRawDataVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset {\n      builder.startVector(1, data.length, 1);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt8(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startRawDataVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(1, numElems, 1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset stringDataOffset\n     */\n    static addStringData(builder: flatbuffers.Builder, stringDataOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, stringDataOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createStringDataVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startStringDataVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTensor(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTensor(\n      builder: flatbuffers.Builder,\n      nameOffset: flatbuffers.Offset,\n      docStringOffset: flatbuffers.Offset,\n      dimsOffset: flatbuffers.Offset,\n      dataType: onnxruntime.experimental.fbs.TensorDataType,\n      rawDataOffset: flatbuffers.Offset,\n      stringDataOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Tensor.startTensor(builder);\n      Tensor.addName(builder, nameOffset);\n      Tensor.addDocString(builder, docStringOffset);\n      Tensor.addDims(builder, dimsOffset);\n      Tensor.addDataType(builder, dataType);\n      Tensor.addRawData(builder, rawDataOffset);\n      Tensor.addStringData(builder, stringDataOffset);\n      return Tensor.endTensor(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SparseTensor {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SparseTensor\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SparseTensor {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SparseTensor= obj\n     * @returns SparseTensor\n     */\n    static getRootAsSparseTensor(bb: flatbuffers.ByteBuffer, obj?: SparseTensor): SparseTensor {\n      return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SparseTensor= obj\n     * @returns SparseTensor\n     */\n    static getSizePrefixedRootAsSparseTensor(bb: flatbuffers.ByteBuffer, obj?: SparseTensor): SparseTensor {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    values(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Tensor()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    indices(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Tensor()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    dims(index: number): flatbuffers.Long | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8)\n        : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    dimsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSparseTensor(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valuesOffset\n     */\n    static addValues(builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, valuesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset indicesOffset\n     */\n    static addIndices(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, indicesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimsOffset\n     */\n    static addDims(builder: flatbuffers.Builder, dimsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSparseTensor(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSparseTensor(\n      builder: flatbuffers.Builder,\n      valuesOffset: flatbuffers.Offset,\n      indicesOffset: flatbuffers.Offset,\n      dimsOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      SparseTensor.startSparseTensor(builder);\n      SparseTensor.addValues(builder, valuesOffset);\n      SparseTensor.addIndices(builder, indicesOffset);\n      SparseTensor.addDims(builder, dimsOffset);\n      return SparseTensor.endSparseTensor(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Attribute {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Attribute\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Attribute {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Attribute= obj\n     * @returns Attribute\n     */\n    static getRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute {\n      return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Attribute= obj\n     * @returns Attribute\n     */\n    static getSizePrefixedRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string | null;\n    name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    name(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string | null;\n    docString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    docString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.AttributeType\n     */\n    type(): onnxruntime.experimental.fbs.AttributeType {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? /**  */ this.bb!.readInt32(this.bb_pos + offset)\n        : onnxruntime.experimental.fbs.AttributeType.UNDEFINED;\n    }\n\n    /**\n     * @returns number\n     */\n    f(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    i(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    s(): string | null;\n    s(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    s(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    t(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Tensor()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph|null\n     */\n    g(obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph | null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Graph()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    floats(index: number): number | null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    floatsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Float32Array\n     */\n    floatsArray(): Float32Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset\n        ? new Float32Array(\n            this.bb!.bytes().buffer,\n            this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n            this.bb!.__vector_len(this.bb_pos + offset),\n          )\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    ints(index: number): flatbuffers.Long | null {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset\n        ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8)\n        : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    intsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    strings(index: number): string;\n    strings(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    strings(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    stringsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor\n     */\n    tensors(index: number, obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Tensor()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    tensorsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph\n     */\n    graphs(index: number, obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph | null {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Graph()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    graphsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startAttribute(builder: flatbuffers.Builder) {\n      builder.startObject(13);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.AttributeType type\n     */\n    static addType(builder: flatbuffers.Builder, type: onnxruntime.experimental.fbs.AttributeType) {\n      builder.addFieldInt32(2, type, onnxruntime.experimental.fbs.AttributeType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number f\n     */\n    static addF(builder: flatbuffers.Builder, f: number) {\n      builder.addFieldFloat32(3, f, 0.0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long i\n     */\n    static addI(builder: flatbuffers.Builder, i: flatbuffers.Long) {\n      builder.addFieldInt64(4, i, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sOffset\n     */\n    static addS(builder: flatbuffers.Builder, sOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, sOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset tOffset\n     */\n    static addT(builder: flatbuffers.Builder, tOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, tOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset gOffset\n     */\n    static addG(builder: flatbuffers.Builder, gOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, gOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset floatsOffset\n     */\n    static addFloats(builder: flatbuffers.Builder, floatsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, floatsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createFloatsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addFloat32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startFloatsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset intsOffset\n     */\n    static addInts(builder: flatbuffers.Builder, intsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(9, intsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createIntsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startIntsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset stringsOffset\n     */\n    static addStrings(builder: flatbuffers.Builder, stringsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(10, stringsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createStringsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startStringsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset tensorsOffset\n     */\n    static addTensors(builder: flatbuffers.Builder, tensorsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(11, tensorsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createTensorsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startTensorsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphsOffset\n     */\n    static addGraphs(builder: flatbuffers.Builder, graphsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(12, graphsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createGraphsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startGraphsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endAttribute(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createAttribute(\n      builder: flatbuffers.Builder,\n      nameOffset: flatbuffers.Offset,\n      docStringOffset: flatbuffers.Offset,\n      type: onnxruntime.experimental.fbs.AttributeType,\n      f: number,\n      i: flatbuffers.Long,\n      sOffset: flatbuffers.Offset,\n      tOffset: flatbuffers.Offset,\n      gOffset: flatbuffers.Offset,\n      floatsOffset: flatbuffers.Offset,\n      intsOffset: flatbuffers.Offset,\n      stringsOffset: flatbuffers.Offset,\n      tensorsOffset: flatbuffers.Offset,\n      graphsOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Attribute.startAttribute(builder);\n      Attribute.addName(builder, nameOffset);\n      Attribute.addDocString(builder, docStringOffset);\n      Attribute.addType(builder, type);\n      Attribute.addF(builder, f);\n      Attribute.addI(builder, i);\n      Attribute.addS(builder, sOffset);\n      Attribute.addT(builder, tOffset);\n      Attribute.addG(builder, gOffset);\n      Attribute.addFloats(builder, floatsOffset);\n      Attribute.addInts(builder, intsOffset);\n      Attribute.addStrings(builder, stringsOffset);\n      Attribute.addTensors(builder, tensorsOffset);\n      Attribute.addGraphs(builder, graphsOffset);\n      return Attribute.endAttribute(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Graph {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Graph\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Graph {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Graph= obj\n     * @returns Graph\n     */\n    static getRootAsGraph(bb: flatbuffers.ByteBuffer, obj?: Graph): Graph {\n      return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Graph= obj\n     * @returns Graph\n     */\n    static getSizePrefixedRootAsGraph(bb: flatbuffers.ByteBuffer, obj?: Graph): Graph {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor\n     */\n    initializers(index: number, obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Tensor()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    initializersLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.ValueInfo= obj\n     * @returns onnxruntime.experimental.fbs.ValueInfo\n     */\n    nodeArgs(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.ValueInfo,\n    ): onnxruntime.experimental.fbs.ValueInfo | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.ValueInfo()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeArgsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Node= obj\n     * @returns onnxruntime.experimental.fbs.Node\n     */\n    nodes(index: number, obj?: onnxruntime.experimental.fbs.Node): onnxruntime.experimental.fbs.Node | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Node()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    maxNodeIndex(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.NodeEdge= obj\n     * @returns onnxruntime.experimental.fbs.NodeEdge\n     */\n    nodeEdges(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.NodeEdge,\n    ): onnxruntime.experimental.fbs.NodeEdge | null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.NodeEdge()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    inputs(index: number): string;\n    inputs(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    inputs(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    outputs(index: number): string;\n    outputs(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;\n    outputs(index: number, optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.SparseTensor= obj\n     * @returns onnxruntime.experimental.fbs.SparseTensor\n     */\n    sparseInitializers(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.SparseTensor,\n    ): onnxruntime.experimental.fbs.SparseTensor | null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.SparseTensor()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    sparseInitializersLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startGraph(builder: flatbuffers.Builder) {\n      builder.startObject(8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset initializersOffset\n     */\n    static addInitializers(builder: flatbuffers.Builder, initializersOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, initializersOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInitializersVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInitializersVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeArgsOffset\n     */\n    static addNodeArgs(builder: flatbuffers.Builder, nodeArgsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, nodeArgsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeArgsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeArgsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodesOffset\n     */\n    static addNodes(builder: flatbuffers.Builder, nodesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, nodesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number maxNodeIndex\n     */\n    static addMaxNodeIndex(builder: flatbuffers.Builder, maxNodeIndex: number) {\n      builder.addFieldInt32(3, maxNodeIndex, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeEdgesOffset\n     */\n    static addNodeEdges(builder: flatbuffers.Builder, nodeEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, nodeEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeEdgesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputsOffset\n     */\n    static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, inputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputsOffset\n     */\n    static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, outputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOutputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sparseInitializersOffset\n     */\n    static addSparseInitializers(builder: flatbuffers.Builder, sparseInitializersOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, sparseInitializersOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createSparseInitializersVector(\n      builder: flatbuffers.Builder,\n      data: flatbuffers.Offset[],\n    ): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startSparseInitializersVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endGraph(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createGraph(\n      builder: flatbuffers.Builder,\n      initializersOffset: flatbuffers.Offset,\n      nodeArgsOffset: flatbuffers.Offset,\n      nodesOffset: flatbuffers.Offset,\n      maxNodeIndex: number,\n      nodeEdgesOffset: flatbuffers.Offset,\n      inputsOffset: flatbuffers.Offset,\n      outputsOffset: flatbuffers.Offset,\n      sparseInitializersOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Graph.startGraph(builder);\n      Graph.addInitializers(builder, initializersOffset);\n      Graph.addNodeArgs(builder, nodeArgsOffset);\n      Graph.addNodes(builder, nodesOffset);\n      Graph.addMaxNodeIndex(builder, maxNodeIndex);\n      Graph.addNodeEdges(builder, nodeEdgesOffset);\n      Graph.addInputs(builder, inputsOffset);\n      Graph.addOutputs(builder, outputsOffset);\n      Graph.addSparseInitializers(builder, sparseInitializersOffset);\n      return Graph.endGraph(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Model {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Model\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Model {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Model= obj\n     * @returns Model\n     */\n    static getRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model {\n      return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Model= obj\n     * @returns Model\n     */\n    static getSizePrefixedRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    irVersion(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.OperatorSetId= obj\n     * @returns onnxruntime.experimental.fbs.OperatorSetId\n     */\n    opsetImport(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.OperatorSetId,\n    ): onnxruntime.experimental.fbs.OperatorSetId | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.OperatorSetId()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    opsetImportLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    producerName(): string | null;\n    producerName(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    producerName(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    producerVersion(): string | null;\n    producerVersion(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    producerVersion(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string | null;\n    domain(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    domain(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    modelVersion(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string | null;\n    docString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    docString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph|null\n     */\n    graph(obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph | null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Graph()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    graphDocString(): string | null;\n    graphDocString(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    graphDocString(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startModel(builder: flatbuffers.Builder) {\n      builder.startObject(9);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long irVersion\n     */\n    static addIrVersion(builder: flatbuffers.Builder, irVersion: flatbuffers.Long) {\n      builder.addFieldInt64(0, irVersion, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset opsetImportOffset\n     */\n    static addOpsetImport(builder: flatbuffers.Builder, opsetImportOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, opsetImportOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOpsetImportVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOpsetImportVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset producerNameOffset\n     */\n    static addProducerName(builder: flatbuffers.Builder, producerNameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, producerNameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset producerVersionOffset\n     */\n    static addProducerVersion(builder: flatbuffers.Builder, producerVersionOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(3, producerVersionOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long modelVersion\n     */\n    static addModelVersion(builder: flatbuffers.Builder, modelVersion: flatbuffers.Long) {\n      builder.addFieldInt64(5, modelVersion, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphOffset\n     */\n    static addGraph(builder: flatbuffers.Builder, graphOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, graphOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphDocStringOffset\n     */\n    static addGraphDocString(builder: flatbuffers.Builder, graphDocStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, graphDocStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endModel(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createModel(\n      builder: flatbuffers.Builder,\n      irVersion: flatbuffers.Long,\n      opsetImportOffset: flatbuffers.Offset,\n      producerNameOffset: flatbuffers.Offset,\n      producerVersionOffset: flatbuffers.Offset,\n      domainOffset: flatbuffers.Offset,\n      modelVersion: flatbuffers.Long,\n      docStringOffset: flatbuffers.Offset,\n      graphOffset: flatbuffers.Offset,\n      graphDocStringOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      Model.startModel(builder);\n      Model.addIrVersion(builder, irVersion);\n      Model.addOpsetImport(builder, opsetImportOffset);\n      Model.addProducerName(builder, producerNameOffset);\n      Model.addProducerVersion(builder, producerVersionOffset);\n      Model.addDomain(builder, domainOffset);\n      Model.addModelVersion(builder, modelVersion);\n      Model.addDocString(builder, docStringOffset);\n      Model.addGraph(builder, graphOffset);\n      Model.addGraphDocString(builder, graphDocStringOffset);\n      return Model.endModel(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class KernelCreateInfos {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns KernelCreateInfos\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): KernelCreateInfos {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param KernelCreateInfos= obj\n     * @returns KernelCreateInfos\n     */\n    static getRootAsKernelCreateInfos(bb: flatbuffers.ByteBuffer, obj?: KernelCreateInfos): KernelCreateInfos {\n      return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param KernelCreateInfos= obj\n     * @returns KernelCreateInfos\n     */\n    static getSizePrefixedRootAsKernelCreateInfos(\n      bb: flatbuffers.ByteBuffer,\n      obj?: KernelCreateInfos,\n    ): KernelCreateInfos {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    nodeIndices(index: number): number | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndicesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Uint32Array\n     */\n    nodeIndicesArray(): Uint32Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? new Uint32Array(\n            this.bb!.bytes().buffer,\n            this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n            this.bb!.__vector_len(this.bb_pos + offset),\n          )\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    kernelDefHashes(index: number): flatbuffers.Long | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? this.bb!.readUint64(this.bb!.__vector(this.bb_pos + offset) + index * 8)\n        : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    kernelDefHashesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startKernelCreateInfos(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeIndicesOffset\n     */\n    static addNodeIndices(builder: flatbuffers.Builder, nodeIndicesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nodeIndicesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeIndicesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset kernelDefHashesOffset\n     */\n    static addKernelDefHashes(builder: flatbuffers.Builder, kernelDefHashesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, kernelDefHashesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createKernelDefHashesVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startKernelDefHashesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endKernelCreateInfos(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createKernelCreateInfos(\n      builder: flatbuffers.Builder,\n      nodeIndicesOffset: flatbuffers.Offset,\n      kernelDefHashesOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      KernelCreateInfos.startKernelCreateInfos(builder);\n      KernelCreateInfos.addNodeIndices(builder, nodeIndicesOffset);\n      KernelCreateInfos.addKernelDefHashes(builder, kernelDefHashesOffset);\n      return KernelCreateInfos.endKernelCreateInfos(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SubGraphSessionState {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SubGraphSessionState\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SubGraphSessionState {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SubGraphSessionState= obj\n     * @returns SubGraphSessionState\n     */\n    static getRootAsSubGraphSessionState(bb: flatbuffers.ByteBuffer, obj?: SubGraphSessionState): SubGraphSessionState {\n      return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SubGraphSessionState= obj\n     * @returns SubGraphSessionState\n     */\n    static getSizePrefixedRootAsSubGraphSessionState(\n      bb: flatbuffers.ByteBuffer,\n      obj?: SubGraphSessionState,\n    ): SubGraphSessionState {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    graphId(): string | null;\n    graphId(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    graphId(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.SessionState= obj\n     * @returns onnxruntime.experimental.fbs.SessionState|null\n     */\n    sessionState(obj?: onnxruntime.experimental.fbs.SessionState): onnxruntime.experimental.fbs.SessionState | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.SessionState()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSubGraphSessionState(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphIdOffset\n     */\n    static addGraphId(builder: flatbuffers.Builder, graphIdOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, graphIdOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sessionStateOffset\n     */\n    static addSessionState(builder: flatbuffers.Builder, sessionStateOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, sessionStateOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSubGraphSessionState(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      builder.requiredField(offset, 4); // graph_id\n      return offset;\n    }\n\n    static createSubGraphSessionState(\n      builder: flatbuffers.Builder,\n      graphIdOffset: flatbuffers.Offset,\n      sessionStateOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      SubGraphSessionState.startSubGraphSessionState(builder);\n      SubGraphSessionState.addGraphId(builder, graphIdOffset);\n      SubGraphSessionState.addSessionState(builder, sessionStateOffset);\n      return SubGraphSessionState.endSubGraphSessionState(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SessionState {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SessionState\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SessionState {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SessionState= obj\n     * @returns SessionState\n     */\n    static getRootAsSessionState(bb: flatbuffers.ByteBuffer, obj?: SessionState): SessionState {\n      return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SessionState= obj\n     * @returns SessionState\n     */\n    static getSizePrefixedRootAsSessionState(bb: flatbuffers.ByteBuffer, obj?: SessionState): SessionState {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.KernelCreateInfos= obj\n     * @returns onnxruntime.experimental.fbs.KernelCreateInfos|null\n     */\n    kernels(\n      obj?: onnxruntime.experimental.fbs.KernelCreateInfos,\n    ): onnxruntime.experimental.fbs.KernelCreateInfos | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.KernelCreateInfos()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.SubGraphSessionState= obj\n     * @returns onnxruntime.experimental.fbs.SubGraphSessionState\n     */\n    subGraphSessionStates(\n      index: number,\n      obj?: onnxruntime.experimental.fbs.SubGraphSessionState,\n    ): onnxruntime.experimental.fbs.SubGraphSessionState | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.SubGraphSessionState()).__init(\n            this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @returns number\n     */\n    subGraphSessionStatesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSessionState(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset kernelsOffset\n     */\n    static addKernels(builder: flatbuffers.Builder, kernelsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, kernelsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset subGraphSessionStatesOffset\n     */\n    static addSubGraphSessionStates(builder: flatbuffers.Builder, subGraphSessionStatesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, subGraphSessionStatesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createSubGraphSessionStatesVector(\n      builder: flatbuffers.Builder,\n      data: flatbuffers.Offset[],\n    ): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startSubGraphSessionStatesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSessionState(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSessionState(\n      builder: flatbuffers.Builder,\n      kernelsOffset: flatbuffers.Offset,\n      subGraphSessionStatesOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      SessionState.startSessionState(builder);\n      SessionState.addKernels(builder, kernelsOffset);\n      SessionState.addSubGraphSessionStates(builder, subGraphSessionStatesOffset);\n      return SessionState.endSessionState(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class InferenceSession {\n    bb: flatbuffers.ByteBuffer | null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns InferenceSession\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): InferenceSession {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param InferenceSession= obj\n     * @returns InferenceSession\n     */\n    static getRootAsInferenceSession(bb: flatbuffers.ByteBuffer, obj?: InferenceSession): InferenceSession {\n      return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param InferenceSession= obj\n     * @returns InferenceSession\n     */\n    static getSizePrefixedRootAsInferenceSession(bb: flatbuffers.ByteBuffer, obj?: InferenceSession): InferenceSession {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @returns boolean\n     */\n    static bufferHasIdentifier(bb: flatbuffers.ByteBuffer): boolean {\n      return bb.__has_identifier('ORTM');\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    ortVersion(): string | null;\n    ortVersion(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;\n    ortVersion(optionalEncoding?: any): string | Uint8Array | null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Model= obj\n     * @returns onnxruntime.experimental.fbs.Model|null\n     */\n    model(obj?: onnxruntime.experimental.fbs.Model): onnxruntime.experimental.fbs.Model | null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.Model()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!)\n        : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.SessionState= obj\n     * @returns onnxruntime.experimental.fbs.SessionState|null\n     */\n    sessionState(obj?: onnxruntime.experimental.fbs.SessionState): onnxruntime.experimental.fbs.SessionState | null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset\n        ? (obj || new onnxruntime.experimental.fbs.SessionState()).__init(\n            this.bb!.__indirect(this.bb_pos + offset),\n            this.bb!,\n          )\n        : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startInferenceSession(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset ortVersionOffset\n     */\n    static addOrtVersion(builder: flatbuffers.Builder, ortVersionOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, ortVersionOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset modelOffset\n     */\n    static addModel(builder: flatbuffers.Builder, modelOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, modelOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sessionStateOffset\n     */\n    static addSessionState(builder: flatbuffers.Builder, sessionStateOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, sessionStateOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endInferenceSession(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset offset\n     */\n    static finishInferenceSessionBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {\n      builder.finish(offset, 'ORTM');\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset offset\n     */\n    static finishSizePrefixedInferenceSessionBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {\n      builder.finish(offset, 'ORTM', true);\n    }\n\n    static createInferenceSession(\n      builder: flatbuffers.Builder,\n      ortVersionOffset: flatbuffers.Offset,\n      modelOffset: flatbuffers.Offset,\n      sessionStateOffset: flatbuffers.Offset,\n    ): flatbuffers.Offset {\n      InferenceSession.startInferenceSession(builder);\n      InferenceSession.addOrtVersion(builder, ortVersionOffset);\n      InferenceSession.addModel(builder, modelOffset);\n      InferenceSession.addSessionState(builder, sessionStateOffset);\n      return InferenceSession.endInferenceSession(builder);\n    }\n  }\n}\n","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n'use strict';\n\nvar $protobuf = require('protobufjs/minimal');\n\n// Common aliases\nvar $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots['default'] || ($protobuf.roots['default'] = {});\n\n$root.onnx = (function () {\n  /**\n   * Namespace onnx.\n   * @exports onnx\n   * @namespace\n   */\n  var onnx = {};\n\n  /**\n   * Version enum.\n   * @name onnx.Version\n   * @enum {number}\n   * @property {number} _START_VERSION=0 _START_VERSION value\n   * @property {number} IR_VERSION_2017_10_10=1 IR_VERSION_2017_10_10 value\n   * @property {number} IR_VERSION_2017_10_30=2 IR_VERSION_2017_10_30 value\n   * @property {number} IR_VERSION_2017_11_3=3 IR_VERSION_2017_11_3 value\n   * @property {number} IR_VERSION_2019_1_22=4 IR_VERSION_2019_1_22 value\n   * @property {number} IR_VERSION_2019_3_18=5 IR_VERSION_2019_3_18 value\n   * @property {number} IR_VERSION_2019_9_19=6 IR_VERSION_2019_9_19 value\n   * @property {number} IR_VERSION_2020_5_8=7 IR_VERSION_2020_5_8 value\n   * @property {number} IR_VERSION_2021_7_30=8 IR_VERSION_2021_7_30 value\n   * @property {number} IR_VERSION=9 IR_VERSION value\n   */\n  onnx.Version = (function () {\n    var valuesById = {},\n      values = Object.create(valuesById);\n    values[(valuesById[0] = '_START_VERSION')] = 0;\n    values[(valuesById[1] = 'IR_VERSION_2017_10_10')] = 1;\n    values[(valuesById[2] = 'IR_VERSION_2017_10_30')] = 2;\n    values[(valuesById[3] = 'IR_VERSION_2017_11_3')] = 3;\n    values[(valuesById[4] = 'IR_VERSION_2019_1_22')] = 4;\n    values[(valuesById[5] = 'IR_VERSION_2019_3_18')] = 5;\n    values[(valuesById[6] = 'IR_VERSION_2019_9_19')] = 6;\n    values[(valuesById[7] = 'IR_VERSION_2020_5_8')] = 7;\n    values[(valuesById[8] = 'IR_VERSION_2021_7_30')] = 8;\n    values[(valuesById[9] = 'IR_VERSION')] = 9;\n    return values;\n  })();\n\n  onnx.AttributeProto = (function () {\n    /**\n     * Properties of an AttributeProto.\n     * @memberof onnx\n     * @interface IAttributeProto\n     * @property {string|null} [name] AttributeProto name\n     * @property {string|null} [refAttrName] AttributeProto refAttrName\n     * @property {string|null} [docString] AttributeProto docString\n     * @property {onnx.AttributeProto.AttributeType|null} [type] AttributeProto type\n     * @property {number|null} [f] AttributeProto f\n     * @property {number|Long|null} [i] AttributeProto i\n     * @property {Uint8Array|null} [s] AttributeProto s\n     * @property {onnx.ITensorProto|null} [t] AttributeProto t\n     * @property {onnx.IGraphProto|null} [g] AttributeProto g\n     * @property {onnx.ISparseTensorProto|null} [sparseTensor] AttributeProto sparseTensor\n     * @property {onnx.ITypeProto|null} [tp] AttributeProto tp\n     * @property {Array.<number>|null} [floats] AttributeProto floats\n     * @property {Array.<number|Long>|null} [ints] AttributeProto ints\n     * @property {Array.<Uint8Array>|null} [strings] AttributeProto strings\n     * @property {Array.<onnx.ITensorProto>|null} [tensors] AttributeProto tensors\n     * @property {Array.<onnx.IGraphProto>|null} [graphs] AttributeProto graphs\n     * @property {Array.<onnx.ISparseTensorProto>|null} [sparseTensors] AttributeProto sparseTensors\n     * @property {Array.<onnx.ITypeProto>|null} [typeProtos] AttributeProto typeProtos\n     */\n\n    /**\n     * Constructs a new AttributeProto.\n     * @memberof onnx\n     * @classdesc Represents an AttributeProto.\n     * @implements IAttributeProto\n     * @constructor\n     * @param {onnx.IAttributeProto=} [properties] Properties to set\n     */\n    function AttributeProto(properties) {\n      this.floats = [];\n      this.ints = [];\n      this.strings = [];\n      this.tensors = [];\n      this.graphs = [];\n      this.sparseTensors = [];\n      this.typeProtos = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * AttributeProto name.\n     * @member {string} name\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.name = '';\n\n    /**\n     * AttributeProto refAttrName.\n     * @member {string} refAttrName\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.refAttrName = '';\n\n    /**\n     * AttributeProto docString.\n     * @member {string} docString\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.docString = '';\n\n    /**\n     * AttributeProto type.\n     * @member {onnx.AttributeProto.AttributeType} type\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.type = 0;\n\n    /**\n     * AttributeProto f.\n     * @member {number} f\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.f = 0;\n\n    /**\n     * AttributeProto i.\n     * @member {number|Long} i\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.i = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n    /**\n     * AttributeProto s.\n     * @member {Uint8Array} s\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.s = $util.newBuffer([]);\n\n    /**\n     * AttributeProto t.\n     * @member {onnx.ITensorProto|null|undefined} t\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.t = null;\n\n    /**\n     * AttributeProto g.\n     * @member {onnx.IGraphProto|null|undefined} g\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.g = null;\n\n    /**\n     * AttributeProto sparseTensor.\n     * @member {onnx.ISparseTensorProto|null|undefined} sparseTensor\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.sparseTensor = null;\n\n    /**\n     * AttributeProto tp.\n     * @member {onnx.ITypeProto|null|undefined} tp\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.tp = null;\n\n    /**\n     * AttributeProto floats.\n     * @member {Array.<number>} floats\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.floats = $util.emptyArray;\n\n    /**\n     * AttributeProto ints.\n     * @member {Array.<number|Long>} ints\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.ints = $util.emptyArray;\n\n    /**\n     * AttributeProto strings.\n     * @member {Array.<Uint8Array>} strings\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.strings = $util.emptyArray;\n\n    /**\n     * AttributeProto tensors.\n     * @member {Array.<onnx.ITensorProto>} tensors\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.tensors = $util.emptyArray;\n\n    /**\n     * AttributeProto graphs.\n     * @member {Array.<onnx.IGraphProto>} graphs\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.graphs = $util.emptyArray;\n\n    /**\n     * AttributeProto sparseTensors.\n     * @member {Array.<onnx.ISparseTensorProto>} sparseTensors\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.sparseTensors = $util.emptyArray;\n\n    /**\n     * AttributeProto typeProtos.\n     * @member {Array.<onnx.ITypeProto>} typeProtos\n     * @memberof onnx.AttributeProto\n     * @instance\n     */\n    AttributeProto.prototype.typeProtos = $util.emptyArray;\n\n    /**\n     * Creates a new AttributeProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {onnx.IAttributeProto=} [properties] Properties to set\n     * @returns {onnx.AttributeProto} AttributeProto instance\n     */\n    AttributeProto.create = function create(properties) {\n      return new AttributeProto(properties);\n    };\n\n    /**\n     * Encodes the specified AttributeProto message. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    AttributeProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);\n      if (message.f != null && Object.hasOwnProperty.call(message, 'f'))\n        writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.f);\n      if (message.i != null && Object.hasOwnProperty.call(message, 'i'))\n        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.i);\n      if (message.s != null && Object.hasOwnProperty.call(message, 's'))\n        writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.s);\n      if (message.t != null && Object.hasOwnProperty.call(message, 't'))\n        $root.onnx.TensorProto.encode(message.t, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();\n      if (message.g != null && Object.hasOwnProperty.call(message, 'g'))\n        $root.onnx.GraphProto.encode(message.g, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();\n      if (message.floats != null && message.floats.length) {\n        writer.uint32(/* id 7, wireType 2 =*/ 58).fork();\n        for (var i = 0; i < message.floats.length; ++i) writer.float(message.floats[i]);\n        writer.ldelim();\n      }\n      if (message.ints != null && message.ints.length) {\n        writer.uint32(/* id 8, wireType 2 =*/ 66).fork();\n        for (var i = 0; i < message.ints.length; ++i) writer.int64(message.ints[i]);\n        writer.ldelim();\n      }\n      if (message.strings != null && message.strings.length)\n        for (var i = 0; i < message.strings.length; ++i)\n          writer.uint32(/* id 9, wireType 2 =*/ 74).bytes(message.strings[i]);\n      if (message.tensors != null && message.tensors.length)\n        for (var i = 0; i < message.tensors.length; ++i)\n          $root.onnx.TensorProto.encode(message.tensors[i], writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();\n      if (message.graphs != null && message.graphs.length)\n        for (var i = 0; i < message.graphs.length; ++i)\n          $root.onnx.GraphProto.encode(message.graphs[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 13, wireType 2 =*/ 106).string(message.docString);\n      if (message.tp != null && Object.hasOwnProperty.call(message, 'tp'))\n        $root.onnx.TypeProto.encode(message.tp, writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();\n      if (message.typeProtos != null && message.typeProtos.length)\n        for (var i = 0; i < message.typeProtos.length; ++i)\n          $root.onnx.TypeProto.encode(\n            message.typeProtos[i],\n            writer.uint32(/* id 15, wireType 2 =*/ 122).fork(),\n          ).ldelim();\n      if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n        writer.uint32(/* id 20, wireType 0 =*/ 160).int32(message.type);\n      if (message.refAttrName != null && Object.hasOwnProperty.call(message, 'refAttrName'))\n        writer.uint32(/* id 21, wireType 2 =*/ 170).string(message.refAttrName);\n      if (message.sparseTensor != null && Object.hasOwnProperty.call(message, 'sparseTensor'))\n        $root.onnx.SparseTensorProto.encode(\n          message.sparseTensor,\n          writer.uint32(/* id 22, wireType 2 =*/ 178).fork(),\n        ).ldelim();\n      if (message.sparseTensors != null && message.sparseTensors.length)\n        for (var i = 0; i < message.sparseTensors.length; ++i)\n          $root.onnx.SparseTensorProto.encode(\n            message.sparseTensors[i],\n            writer.uint32(/* id 23, wireType 2 =*/ 186).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified AttributeProto message, length delimited. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    AttributeProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an AttributeProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.AttributeProto} AttributeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    AttributeProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.AttributeProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.name = reader.string();\n            break;\n          }\n          case 21: {\n            message.refAttrName = reader.string();\n            break;\n          }\n          case 13: {\n            message.docString = reader.string();\n            break;\n          }\n          case 20: {\n            message.type = reader.int32();\n            break;\n          }\n          case 2: {\n            message.f = reader.float();\n            break;\n          }\n          case 3: {\n            message.i = reader.int64();\n            break;\n          }\n          case 4: {\n            message.s = reader.bytes();\n            break;\n          }\n          case 5: {\n            message.t = $root.onnx.TensorProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 6: {\n            message.g = $root.onnx.GraphProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 22: {\n            message.sparseTensor = $root.onnx.SparseTensorProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 14: {\n            message.tp = $root.onnx.TypeProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 7: {\n            if (!(message.floats && message.floats.length)) message.floats = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.floats.push(reader.float());\n            } else message.floats.push(reader.float());\n            break;\n          }\n          case 8: {\n            if (!(message.ints && message.ints.length)) message.ints = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.ints.push(reader.int64());\n            } else message.ints.push(reader.int64());\n            break;\n          }\n          case 9: {\n            if (!(message.strings && message.strings.length)) message.strings = [];\n            message.strings.push(reader.bytes());\n            break;\n          }\n          case 10: {\n            if (!(message.tensors && message.tensors.length)) message.tensors = [];\n            message.tensors.push($root.onnx.TensorProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 11: {\n            if (!(message.graphs && message.graphs.length)) message.graphs = [];\n            message.graphs.push($root.onnx.GraphProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 23: {\n            if (!(message.sparseTensors && message.sparseTensors.length)) message.sparseTensors = [];\n            message.sparseTensors.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 15: {\n            if (!(message.typeProtos && message.typeProtos.length)) message.typeProtos = [];\n            message.typeProtos.push($root.onnx.TypeProto.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes an AttributeProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.AttributeProto} AttributeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    AttributeProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an AttributeProto message.\n     * @function verify\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    AttributeProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.refAttrName != null && message.hasOwnProperty('refAttrName'))\n        if (!$util.isString(message.refAttrName)) return 'refAttrName: string expected';\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      if (message.type != null && message.hasOwnProperty('type'))\n        switch (message.type) {\n          default:\n            return 'type: enum value expected';\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 11:\n          case 13:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 12:\n          case 14:\n            break;\n        }\n      if (message.f != null && message.hasOwnProperty('f'))\n        if (typeof message.f !== 'number') return 'f: number expected';\n      if (message.i != null && message.hasOwnProperty('i'))\n        if (\n          !$util.isInteger(message.i) &&\n          !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high))\n        )\n          return 'i: integer|Long expected';\n      if (message.s != null && message.hasOwnProperty('s'))\n        if (!((message.s && typeof message.s.length === 'number') || $util.isString(message.s)))\n          return 's: buffer expected';\n      if (message.t != null && message.hasOwnProperty('t')) {\n        var error = $root.onnx.TensorProto.verify(message.t);\n        if (error) return 't.' + error;\n      }\n      if (message.g != null && message.hasOwnProperty('g')) {\n        var error = $root.onnx.GraphProto.verify(message.g);\n        if (error) return 'g.' + error;\n      }\n      if (message.sparseTensor != null && message.hasOwnProperty('sparseTensor')) {\n        var error = $root.onnx.SparseTensorProto.verify(message.sparseTensor);\n        if (error) return 'sparseTensor.' + error;\n      }\n      if (message.tp != null && message.hasOwnProperty('tp')) {\n        var error = $root.onnx.TypeProto.verify(message.tp);\n        if (error) return 'tp.' + error;\n      }\n      if (message.floats != null && message.hasOwnProperty('floats')) {\n        if (!Array.isArray(message.floats)) return 'floats: array expected';\n        for (var i = 0; i < message.floats.length; ++i)\n          if (typeof message.floats[i] !== 'number') return 'floats: number[] expected';\n      }\n      if (message.ints != null && message.hasOwnProperty('ints')) {\n        if (!Array.isArray(message.ints)) return 'ints: array expected';\n        for (var i = 0; i < message.ints.length; ++i)\n          if (\n            !$util.isInteger(message.ints[i]) &&\n            !(message.ints[i] && $util.isInteger(message.ints[i].low) && $util.isInteger(message.ints[i].high))\n          )\n            return 'ints: integer|Long[] expected';\n      }\n      if (message.strings != null && message.hasOwnProperty('strings')) {\n        if (!Array.isArray(message.strings)) return 'strings: array expected';\n        for (var i = 0; i < message.strings.length; ++i)\n          if (\n            !(\n              (message.strings[i] && typeof message.strings[i].length === 'number') ||\n              $util.isString(message.strings[i])\n            )\n          )\n            return 'strings: buffer[] expected';\n      }\n      if (message.tensors != null && message.hasOwnProperty('tensors')) {\n        if (!Array.isArray(message.tensors)) return 'tensors: array expected';\n        for (var i = 0; i < message.tensors.length; ++i) {\n          var error = $root.onnx.TensorProto.verify(message.tensors[i]);\n          if (error) return 'tensors.' + error;\n        }\n      }\n      if (message.graphs != null && message.hasOwnProperty('graphs')) {\n        if (!Array.isArray(message.graphs)) return 'graphs: array expected';\n        for (var i = 0; i < message.graphs.length; ++i) {\n          var error = $root.onnx.GraphProto.verify(message.graphs[i]);\n          if (error) return 'graphs.' + error;\n        }\n      }\n      if (message.sparseTensors != null && message.hasOwnProperty('sparseTensors')) {\n        if (!Array.isArray(message.sparseTensors)) return 'sparseTensors: array expected';\n        for (var i = 0; i < message.sparseTensors.length; ++i) {\n          var error = $root.onnx.SparseTensorProto.verify(message.sparseTensors[i]);\n          if (error) return 'sparseTensors.' + error;\n        }\n      }\n      if (message.typeProtos != null && message.hasOwnProperty('typeProtos')) {\n        if (!Array.isArray(message.typeProtos)) return 'typeProtos: array expected';\n        for (var i = 0; i < message.typeProtos.length; ++i) {\n          var error = $root.onnx.TypeProto.verify(message.typeProtos[i]);\n          if (error) return 'typeProtos.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates an AttributeProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.AttributeProto} AttributeProto\n     */\n    AttributeProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.AttributeProto) return object;\n      var message = new $root.onnx.AttributeProto();\n      if (object.name != null) message.name = String(object.name);\n      if (object.refAttrName != null) message.refAttrName = String(object.refAttrName);\n      if (object.docString != null) message.docString = String(object.docString);\n      switch (object.type) {\n        default:\n          if (typeof object.type === 'number') {\n            message.type = object.type;\n            break;\n          }\n          break;\n        case 'UNDEFINED':\n        case 0:\n          message.type = 0;\n          break;\n        case 'FLOAT':\n        case 1:\n          message.type = 1;\n          break;\n        case 'INT':\n        case 2:\n          message.type = 2;\n          break;\n        case 'STRING':\n        case 3:\n          message.type = 3;\n          break;\n        case 'TENSOR':\n        case 4:\n          message.type = 4;\n          break;\n        case 'GRAPH':\n        case 5:\n          message.type = 5;\n          break;\n        case 'SPARSE_TENSOR':\n        case 11:\n          message.type = 11;\n          break;\n        case 'TYPE_PROTO':\n        case 13:\n          message.type = 13;\n          break;\n        case 'FLOATS':\n        case 6:\n          message.type = 6;\n          break;\n        case 'INTS':\n        case 7:\n          message.type = 7;\n          break;\n        case 'STRINGS':\n        case 8:\n          message.type = 8;\n          break;\n        case 'TENSORS':\n        case 9:\n          message.type = 9;\n          break;\n        case 'GRAPHS':\n        case 10:\n          message.type = 10;\n          break;\n        case 'SPARSE_TENSORS':\n        case 12:\n          message.type = 12;\n          break;\n        case 'TYPE_PROTOS':\n        case 14:\n          message.type = 14;\n          break;\n      }\n      if (object.f != null) message.f = Number(object.f);\n      if (object.i != null)\n        if ($util.Long) (message.i = $util.Long.fromValue(object.i)).unsigned = false;\n        else if (typeof object.i === 'string') message.i = parseInt(object.i, 10);\n        else if (typeof object.i === 'number') message.i = object.i;\n        else if (typeof object.i === 'object')\n          message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();\n      if (object.s != null)\n        if (typeof object.s === 'string')\n          $util.base64.decode(object.s, (message.s = $util.newBuffer($util.base64.length(object.s))), 0);\n        else if (object.s.length >= 0) message.s = object.s;\n      if (object.t != null) {\n        if (typeof object.t !== 'object') throw TypeError('.onnx.AttributeProto.t: object expected');\n        message.t = $root.onnx.TensorProto.fromObject(object.t);\n      }\n      if (object.g != null) {\n        if (typeof object.g !== 'object') throw TypeError('.onnx.AttributeProto.g: object expected');\n        message.g = $root.onnx.GraphProto.fromObject(object.g);\n      }\n      if (object.sparseTensor != null) {\n        if (typeof object.sparseTensor !== 'object')\n          throw TypeError('.onnx.AttributeProto.sparseTensor: object expected');\n        message.sparseTensor = $root.onnx.SparseTensorProto.fromObject(object.sparseTensor);\n      }\n      if (object.tp != null) {\n        if (typeof object.tp !== 'object') throw TypeError('.onnx.AttributeProto.tp: object expected');\n        message.tp = $root.onnx.TypeProto.fromObject(object.tp);\n      }\n      if (object.floats) {\n        if (!Array.isArray(object.floats)) throw TypeError('.onnx.AttributeProto.floats: array expected');\n        message.floats = [];\n        for (var i = 0; i < object.floats.length; ++i) message.floats[i] = Number(object.floats[i]);\n      }\n      if (object.ints) {\n        if (!Array.isArray(object.ints)) throw TypeError('.onnx.AttributeProto.ints: array expected');\n        message.ints = [];\n        for (var i = 0; i < object.ints.length; ++i)\n          if ($util.Long) (message.ints[i] = $util.Long.fromValue(object.ints[i])).unsigned = false;\n          else if (typeof object.ints[i] === 'string') message.ints[i] = parseInt(object.ints[i], 10);\n          else if (typeof object.ints[i] === 'number') message.ints[i] = object.ints[i];\n          else if (typeof object.ints[i] === 'object')\n            message.ints[i] = new $util.LongBits(object.ints[i].low >>> 0, object.ints[i].high >>> 0).toNumber();\n      }\n      if (object.strings) {\n        if (!Array.isArray(object.strings)) throw TypeError('.onnx.AttributeProto.strings: array expected');\n        message.strings = [];\n        for (var i = 0; i < object.strings.length; ++i)\n          if (typeof object.strings[i] === 'string')\n            $util.base64.decode(\n              object.strings[i],\n              (message.strings[i] = $util.newBuffer($util.base64.length(object.strings[i]))),\n              0,\n            );\n          else if (object.strings[i].length >= 0) message.strings[i] = object.strings[i];\n      }\n      if (object.tensors) {\n        if (!Array.isArray(object.tensors)) throw TypeError('.onnx.AttributeProto.tensors: array expected');\n        message.tensors = [];\n        for (var i = 0; i < object.tensors.length; ++i) {\n          if (typeof object.tensors[i] !== 'object') throw TypeError('.onnx.AttributeProto.tensors: object expected');\n          message.tensors[i] = $root.onnx.TensorProto.fromObject(object.tensors[i]);\n        }\n      }\n      if (object.graphs) {\n        if (!Array.isArray(object.graphs)) throw TypeError('.onnx.AttributeProto.graphs: array expected');\n        message.graphs = [];\n        for (var i = 0; i < object.graphs.length; ++i) {\n          if (typeof object.graphs[i] !== 'object') throw TypeError('.onnx.AttributeProto.graphs: object expected');\n          message.graphs[i] = $root.onnx.GraphProto.fromObject(object.graphs[i]);\n        }\n      }\n      if (object.sparseTensors) {\n        if (!Array.isArray(object.sparseTensors)) throw TypeError('.onnx.AttributeProto.sparseTensors: array expected');\n        message.sparseTensors = [];\n        for (var i = 0; i < object.sparseTensors.length; ++i) {\n          if (typeof object.sparseTensors[i] !== 'object')\n            throw TypeError('.onnx.AttributeProto.sparseTensors: object expected');\n          message.sparseTensors[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseTensors[i]);\n        }\n      }\n      if (object.typeProtos) {\n        if (!Array.isArray(object.typeProtos)) throw TypeError('.onnx.AttributeProto.typeProtos: array expected');\n        message.typeProtos = [];\n        for (var i = 0; i < object.typeProtos.length; ++i) {\n          if (typeof object.typeProtos[i] !== 'object')\n            throw TypeError('.onnx.AttributeProto.typeProtos: object expected');\n          message.typeProtos[i] = $root.onnx.TypeProto.fromObject(object.typeProtos[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from an AttributeProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {onnx.AttributeProto} message AttributeProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    AttributeProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.floats = [];\n        object.ints = [];\n        object.strings = [];\n        object.tensors = [];\n        object.graphs = [];\n        object.typeProtos = [];\n        object.sparseTensors = [];\n      }\n      if (options.defaults) {\n        object.name = '';\n        object.f = 0;\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, false);\n          object.i = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.i = options.longs === String ? '0' : 0;\n        if (options.bytes === String) object.s = '';\n        else {\n          object.s = [];\n          if (options.bytes !== Array) object.s = $util.newBuffer(object.s);\n        }\n        object.t = null;\n        object.g = null;\n        object.docString = '';\n        object.tp = null;\n        object.type = options.enums === String ? 'UNDEFINED' : 0;\n        object.refAttrName = '';\n        object.sparseTensor = null;\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.f != null && message.hasOwnProperty('f'))\n        object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;\n      if (message.i != null && message.hasOwnProperty('i'))\n        if (typeof message.i === 'number') object.i = options.longs === String ? String(message.i) : message.i;\n        else\n          object.i =\n            options.longs === String\n              ? $util.Long.prototype.toString.call(message.i)\n              : options.longs === Number\n                ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber()\n                : message.i;\n      if (message.s != null && message.hasOwnProperty('s'))\n        object.s =\n          options.bytes === String\n            ? $util.base64.encode(message.s, 0, message.s.length)\n            : options.bytes === Array\n              ? Array.prototype.slice.call(message.s)\n              : message.s;\n      if (message.t != null && message.hasOwnProperty('t'))\n        object.t = $root.onnx.TensorProto.toObject(message.t, options);\n      if (message.g != null && message.hasOwnProperty('g'))\n        object.g = $root.onnx.GraphProto.toObject(message.g, options);\n      if (message.floats && message.floats.length) {\n        object.floats = [];\n        for (var j = 0; j < message.floats.length; ++j)\n          object.floats[j] =\n            options.json && !isFinite(message.floats[j]) ? String(message.floats[j]) : message.floats[j];\n      }\n      if (message.ints && message.ints.length) {\n        object.ints = [];\n        for (var j = 0; j < message.ints.length; ++j)\n          if (typeof message.ints[j] === 'number')\n            object.ints[j] = options.longs === String ? String(message.ints[j]) : message.ints[j];\n          else\n            object.ints[j] =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.ints[j])\n                : options.longs === Number\n                  ? new $util.LongBits(message.ints[j].low >>> 0, message.ints[j].high >>> 0).toNumber()\n                  : message.ints[j];\n      }\n      if (message.strings && message.strings.length) {\n        object.strings = [];\n        for (var j = 0; j < message.strings.length; ++j)\n          object.strings[j] =\n            options.bytes === String\n              ? $util.base64.encode(message.strings[j], 0, message.strings[j].length)\n              : options.bytes === Array\n                ? Array.prototype.slice.call(message.strings[j])\n                : message.strings[j];\n      }\n      if (message.tensors && message.tensors.length) {\n        object.tensors = [];\n        for (var j = 0; j < message.tensors.length; ++j)\n          object.tensors[j] = $root.onnx.TensorProto.toObject(message.tensors[j], options);\n      }\n      if (message.graphs && message.graphs.length) {\n        object.graphs = [];\n        for (var j = 0; j < message.graphs.length; ++j)\n          object.graphs[j] = $root.onnx.GraphProto.toObject(message.graphs[j], options);\n      }\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.tp != null && message.hasOwnProperty('tp'))\n        object.tp = $root.onnx.TypeProto.toObject(message.tp, options);\n      if (message.typeProtos && message.typeProtos.length) {\n        object.typeProtos = [];\n        for (var j = 0; j < message.typeProtos.length; ++j)\n          object.typeProtos[j] = $root.onnx.TypeProto.toObject(message.typeProtos[j], options);\n      }\n      if (message.type != null && message.hasOwnProperty('type'))\n        object.type =\n          options.enums === String\n            ? $root.onnx.AttributeProto.AttributeType[message.type] === undefined\n              ? message.type\n              : $root.onnx.AttributeProto.AttributeType[message.type]\n            : message.type;\n      if (message.refAttrName != null && message.hasOwnProperty('refAttrName'))\n        object.refAttrName = message.refAttrName;\n      if (message.sparseTensor != null && message.hasOwnProperty('sparseTensor'))\n        object.sparseTensor = $root.onnx.SparseTensorProto.toObject(message.sparseTensor, options);\n      if (message.sparseTensors && message.sparseTensors.length) {\n        object.sparseTensors = [];\n        for (var j = 0; j < message.sparseTensors.length; ++j)\n          object.sparseTensors[j] = $root.onnx.SparseTensorProto.toObject(message.sparseTensors[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this AttributeProto to JSON.\n     * @function toJSON\n     * @memberof onnx.AttributeProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    AttributeProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for AttributeProto\n     * @function getTypeUrl\n     * @memberof onnx.AttributeProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    AttributeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.AttributeProto';\n    };\n\n    /**\n     * AttributeType enum.\n     * @name onnx.AttributeProto.AttributeType\n     * @enum {number}\n     * @property {number} UNDEFINED=0 UNDEFINED value\n     * @property {number} FLOAT=1 FLOAT value\n     * @property {number} INT=2 INT value\n     * @property {number} STRING=3 STRING value\n     * @property {number} TENSOR=4 TENSOR value\n     * @property {number} GRAPH=5 GRAPH value\n     * @property {number} SPARSE_TENSOR=11 SPARSE_TENSOR value\n     * @property {number} TYPE_PROTO=13 TYPE_PROTO value\n     * @property {number} FLOATS=6 FLOATS value\n     * @property {number} INTS=7 INTS value\n     * @property {number} STRINGS=8 STRINGS value\n     * @property {number} TENSORS=9 TENSORS value\n     * @property {number} GRAPHS=10 GRAPHS value\n     * @property {number} SPARSE_TENSORS=12 SPARSE_TENSORS value\n     * @property {number} TYPE_PROTOS=14 TYPE_PROTOS value\n     */\n    AttributeProto.AttributeType = (function () {\n      var valuesById = {},\n        values = Object.create(valuesById);\n      values[(valuesById[0] = 'UNDEFINED')] = 0;\n      values[(valuesById[1] = 'FLOAT')] = 1;\n      values[(valuesById[2] = 'INT')] = 2;\n      values[(valuesById[3] = 'STRING')] = 3;\n      values[(valuesById[4] = 'TENSOR')] = 4;\n      values[(valuesById[5] = 'GRAPH')] = 5;\n      values[(valuesById[11] = 'SPARSE_TENSOR')] = 11;\n      values[(valuesById[13] = 'TYPE_PROTO')] = 13;\n      values[(valuesById[6] = 'FLOATS')] = 6;\n      values[(valuesById[7] = 'INTS')] = 7;\n      values[(valuesById[8] = 'STRINGS')] = 8;\n      values[(valuesById[9] = 'TENSORS')] = 9;\n      values[(valuesById[10] = 'GRAPHS')] = 10;\n      values[(valuesById[12] = 'SPARSE_TENSORS')] = 12;\n      values[(valuesById[14] = 'TYPE_PROTOS')] = 14;\n      return values;\n    })();\n\n    return AttributeProto;\n  })();\n\n  onnx.ValueInfoProto = (function () {\n    /**\n     * Properties of a ValueInfoProto.\n     * @memberof onnx\n     * @interface IValueInfoProto\n     * @property {string|null} [name] ValueInfoProto name\n     * @property {onnx.ITypeProto|null} [type] ValueInfoProto type\n     * @property {string|null} [docString] ValueInfoProto docString\n     */\n\n    /**\n     * Constructs a new ValueInfoProto.\n     * @memberof onnx\n     * @classdesc Represents a ValueInfoProto.\n     * @implements IValueInfoProto\n     * @constructor\n     * @param {onnx.IValueInfoProto=} [properties] Properties to set\n     */\n    function ValueInfoProto(properties) {\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ValueInfoProto name.\n     * @member {string} name\n     * @memberof onnx.ValueInfoProto\n     * @instance\n     */\n    ValueInfoProto.prototype.name = '';\n\n    /**\n     * ValueInfoProto type.\n     * @member {onnx.ITypeProto|null|undefined} type\n     * @memberof onnx.ValueInfoProto\n     * @instance\n     */\n    ValueInfoProto.prototype.type = null;\n\n    /**\n     * ValueInfoProto docString.\n     * @member {string} docString\n     * @memberof onnx.ValueInfoProto\n     * @instance\n     */\n    ValueInfoProto.prototype.docString = '';\n\n    /**\n     * Creates a new ValueInfoProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {onnx.IValueInfoProto=} [properties] Properties to set\n     * @returns {onnx.ValueInfoProto} ValueInfoProto instance\n     */\n    ValueInfoProto.create = function create(properties) {\n      return new ValueInfoProto(properties);\n    };\n\n    /**\n     * Encodes the specified ValueInfoProto message. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ValueInfoProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);\n      if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n        $root.onnx.TypeProto.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.docString);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified ValueInfoProto message, length delimited. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ValueInfoProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ValueInfoProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.ValueInfoProto} ValueInfoProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ValueInfoProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.ValueInfoProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.name = reader.string();\n            break;\n          }\n          case 2: {\n            message.type = $root.onnx.TypeProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 3: {\n            message.docString = reader.string();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a ValueInfoProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.ValueInfoProto} ValueInfoProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ValueInfoProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ValueInfoProto message.\n     * @function verify\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ValueInfoProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.type != null && message.hasOwnProperty('type')) {\n        var error = $root.onnx.TypeProto.verify(message.type);\n        if (error) return 'type.' + error;\n      }\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      return null;\n    };\n\n    /**\n     * Creates a ValueInfoProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.ValueInfoProto} ValueInfoProto\n     */\n    ValueInfoProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.ValueInfoProto) return object;\n      var message = new $root.onnx.ValueInfoProto();\n      if (object.name != null) message.name = String(object.name);\n      if (object.type != null) {\n        if (typeof object.type !== 'object') throw TypeError('.onnx.ValueInfoProto.type: object expected');\n        message.type = $root.onnx.TypeProto.fromObject(object.type);\n      }\n      if (object.docString != null) message.docString = String(object.docString);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a ValueInfoProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {onnx.ValueInfoProto} message ValueInfoProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ValueInfoProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        object.name = '';\n        object.type = null;\n        object.docString = '';\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.type != null && message.hasOwnProperty('type'))\n        object.type = $root.onnx.TypeProto.toObject(message.type, options);\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      return object;\n    };\n\n    /**\n     * Converts this ValueInfoProto to JSON.\n     * @function toJSON\n     * @memberof onnx.ValueInfoProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ValueInfoProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for ValueInfoProto\n     * @function getTypeUrl\n     * @memberof onnx.ValueInfoProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    ValueInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.ValueInfoProto';\n    };\n\n    return ValueInfoProto;\n  })();\n\n  onnx.NodeProto = (function () {\n    /**\n     * Properties of a NodeProto.\n     * @memberof onnx\n     * @interface INodeProto\n     * @property {Array.<string>|null} [input] NodeProto input\n     * @property {Array.<string>|null} [output] NodeProto output\n     * @property {string|null} [name] NodeProto name\n     * @property {string|null} [opType] NodeProto opType\n     * @property {string|null} [domain] NodeProto domain\n     * @property {Array.<onnx.IAttributeProto>|null} [attribute] NodeProto attribute\n     * @property {string|null} [docString] NodeProto docString\n     */\n\n    /**\n     * Constructs a new NodeProto.\n     * @memberof onnx\n     * @classdesc Represents a NodeProto.\n     * @implements INodeProto\n     * @constructor\n     * @param {onnx.INodeProto=} [properties] Properties to set\n     */\n    function NodeProto(properties) {\n      this.input = [];\n      this.output = [];\n      this.attribute = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * NodeProto input.\n     * @member {Array.<string>} input\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.input = $util.emptyArray;\n\n    /**\n     * NodeProto output.\n     * @member {Array.<string>} output\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.output = $util.emptyArray;\n\n    /**\n     * NodeProto name.\n     * @member {string} name\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.name = '';\n\n    /**\n     * NodeProto opType.\n     * @member {string} opType\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.opType = '';\n\n    /**\n     * NodeProto domain.\n     * @member {string} domain\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.domain = '';\n\n    /**\n     * NodeProto attribute.\n     * @member {Array.<onnx.IAttributeProto>} attribute\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.attribute = $util.emptyArray;\n\n    /**\n     * NodeProto docString.\n     * @member {string} docString\n     * @memberof onnx.NodeProto\n     * @instance\n     */\n    NodeProto.prototype.docString = '';\n\n    /**\n     * Creates a new NodeProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {onnx.INodeProto=} [properties] Properties to set\n     * @returns {onnx.NodeProto} NodeProto instance\n     */\n    NodeProto.create = function create(properties) {\n      return new NodeProto(properties);\n    };\n\n    /**\n     * Encodes the specified NodeProto message. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {onnx.INodeProto} message NodeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    NodeProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.input != null && message.input.length)\n        for (var i = 0; i < message.input.length; ++i)\n          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.input[i]);\n      if (message.output != null && message.output.length)\n        for (var i = 0; i < message.output.length; ++i)\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.output[i]);\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.name);\n      if (message.opType != null && Object.hasOwnProperty.call(message, 'opType'))\n        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.opType);\n      if (message.attribute != null && message.attribute.length)\n        for (var i = 0; i < message.attribute.length; ++i)\n          $root.onnx.AttributeProto.encode(\n            message.attribute[i],\n            writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),\n          ).ldelim();\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.docString);\n      if (message.domain != null && Object.hasOwnProperty.call(message, 'domain'))\n        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.domain);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified NodeProto message, length delimited. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {onnx.INodeProto} message NodeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    NodeProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a NodeProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.NodeProto} NodeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    NodeProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.NodeProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            if (!(message.input && message.input.length)) message.input = [];\n            message.input.push(reader.string());\n            break;\n          }\n          case 2: {\n            if (!(message.output && message.output.length)) message.output = [];\n            message.output.push(reader.string());\n            break;\n          }\n          case 3: {\n            message.name = reader.string();\n            break;\n          }\n          case 4: {\n            message.opType = reader.string();\n            break;\n          }\n          case 7: {\n            message.domain = reader.string();\n            break;\n          }\n          case 5: {\n            if (!(message.attribute && message.attribute.length)) message.attribute = [];\n            message.attribute.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 6: {\n            message.docString = reader.string();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a NodeProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.NodeProto} NodeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    NodeProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a NodeProto message.\n     * @function verify\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    NodeProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.input != null && message.hasOwnProperty('input')) {\n        if (!Array.isArray(message.input)) return 'input: array expected';\n        for (var i = 0; i < message.input.length; ++i)\n          if (!$util.isString(message.input[i])) return 'input: string[] expected';\n      }\n      if (message.output != null && message.hasOwnProperty('output')) {\n        if (!Array.isArray(message.output)) return 'output: array expected';\n        for (var i = 0; i < message.output.length; ++i)\n          if (!$util.isString(message.output[i])) return 'output: string[] expected';\n      }\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.opType != null && message.hasOwnProperty('opType'))\n        if (!$util.isString(message.opType)) return 'opType: string expected';\n      if (message.domain != null && message.hasOwnProperty('domain'))\n        if (!$util.isString(message.domain)) return 'domain: string expected';\n      if (message.attribute != null && message.hasOwnProperty('attribute')) {\n        if (!Array.isArray(message.attribute)) return 'attribute: array expected';\n        for (var i = 0; i < message.attribute.length; ++i) {\n          var error = $root.onnx.AttributeProto.verify(message.attribute[i]);\n          if (error) return 'attribute.' + error;\n        }\n      }\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      return null;\n    };\n\n    /**\n     * Creates a NodeProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.NodeProto} NodeProto\n     */\n    NodeProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.NodeProto) return object;\n      var message = new $root.onnx.NodeProto();\n      if (object.input) {\n        if (!Array.isArray(object.input)) throw TypeError('.onnx.NodeProto.input: array expected');\n        message.input = [];\n        for (var i = 0; i < object.input.length; ++i) message.input[i] = String(object.input[i]);\n      }\n      if (object.output) {\n        if (!Array.isArray(object.output)) throw TypeError('.onnx.NodeProto.output: array expected');\n        message.output = [];\n        for (var i = 0; i < object.output.length; ++i) message.output[i] = String(object.output[i]);\n      }\n      if (object.name != null) message.name = String(object.name);\n      if (object.opType != null) message.opType = String(object.opType);\n      if (object.domain != null) message.domain = String(object.domain);\n      if (object.attribute) {\n        if (!Array.isArray(object.attribute)) throw TypeError('.onnx.NodeProto.attribute: array expected');\n        message.attribute = [];\n        for (var i = 0; i < object.attribute.length; ++i) {\n          if (typeof object.attribute[i] !== 'object') throw TypeError('.onnx.NodeProto.attribute: object expected');\n          message.attribute[i] = $root.onnx.AttributeProto.fromObject(object.attribute[i]);\n        }\n      }\n      if (object.docString != null) message.docString = String(object.docString);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a NodeProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {onnx.NodeProto} message NodeProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    NodeProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.input = [];\n        object.output = [];\n        object.attribute = [];\n      }\n      if (options.defaults) {\n        object.name = '';\n        object.opType = '';\n        object.docString = '';\n        object.domain = '';\n      }\n      if (message.input && message.input.length) {\n        object.input = [];\n        for (var j = 0; j < message.input.length; ++j) object.input[j] = message.input[j];\n      }\n      if (message.output && message.output.length) {\n        object.output = [];\n        for (var j = 0; j < message.output.length; ++j) object.output[j] = message.output[j];\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.opType != null && message.hasOwnProperty('opType')) object.opType = message.opType;\n      if (message.attribute && message.attribute.length) {\n        object.attribute = [];\n        for (var j = 0; j < message.attribute.length; ++j)\n          object.attribute[j] = $root.onnx.AttributeProto.toObject(message.attribute[j], options);\n      }\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.domain != null && message.hasOwnProperty('domain')) object.domain = message.domain;\n      return object;\n    };\n\n    /**\n     * Converts this NodeProto to JSON.\n     * @function toJSON\n     * @memberof onnx.NodeProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    NodeProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for NodeProto\n     * @function getTypeUrl\n     * @memberof onnx.NodeProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    NodeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.NodeProto';\n    };\n\n    return NodeProto;\n  })();\n\n  onnx.TrainingInfoProto = (function () {\n    /**\n     * Properties of a TrainingInfoProto.\n     * @memberof onnx\n     * @interface ITrainingInfoProto\n     * @property {onnx.IGraphProto|null} [initialization] TrainingInfoProto initialization\n     * @property {onnx.IGraphProto|null} [algorithm] TrainingInfoProto algorithm\n     * @property {Array.<onnx.IStringStringEntryProto>|null} [initializationBinding] TrainingInfoProto initializationBinding\n     * @property {Array.<onnx.IStringStringEntryProto>|null} [updateBinding] TrainingInfoProto updateBinding\n     */\n\n    /**\n     * Constructs a new TrainingInfoProto.\n     * @memberof onnx\n     * @classdesc Represents a TrainingInfoProto.\n     * @implements ITrainingInfoProto\n     * @constructor\n     * @param {onnx.ITrainingInfoProto=} [properties] Properties to set\n     */\n    function TrainingInfoProto(properties) {\n      this.initializationBinding = [];\n      this.updateBinding = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TrainingInfoProto initialization.\n     * @member {onnx.IGraphProto|null|undefined} initialization\n     * @memberof onnx.TrainingInfoProto\n     * @instance\n     */\n    TrainingInfoProto.prototype.initialization = null;\n\n    /**\n     * TrainingInfoProto algorithm.\n     * @member {onnx.IGraphProto|null|undefined} algorithm\n     * @memberof onnx.TrainingInfoProto\n     * @instance\n     */\n    TrainingInfoProto.prototype.algorithm = null;\n\n    /**\n     * TrainingInfoProto initializationBinding.\n     * @member {Array.<onnx.IStringStringEntryProto>} initializationBinding\n     * @memberof onnx.TrainingInfoProto\n     * @instance\n     */\n    TrainingInfoProto.prototype.initializationBinding = $util.emptyArray;\n\n    /**\n     * TrainingInfoProto updateBinding.\n     * @member {Array.<onnx.IStringStringEntryProto>} updateBinding\n     * @memberof onnx.TrainingInfoProto\n     * @instance\n     */\n    TrainingInfoProto.prototype.updateBinding = $util.emptyArray;\n\n    /**\n     * Creates a new TrainingInfoProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {onnx.ITrainingInfoProto=} [properties] Properties to set\n     * @returns {onnx.TrainingInfoProto} TrainingInfoProto instance\n     */\n    TrainingInfoProto.create = function create(properties) {\n      return new TrainingInfoProto(properties);\n    };\n\n    /**\n     * Encodes the specified TrainingInfoProto message. Does not implicitly {@link onnx.TrainingInfoProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {onnx.ITrainingInfoProto} message TrainingInfoProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TrainingInfoProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.initialization != null && Object.hasOwnProperty.call(message, 'initialization'))\n        $root.onnx.GraphProto.encode(message.initialization, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n      if (message.algorithm != null && Object.hasOwnProperty.call(message, 'algorithm'))\n        $root.onnx.GraphProto.encode(message.algorithm, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n      if (message.initializationBinding != null && message.initializationBinding.length)\n        for (var i = 0; i < message.initializationBinding.length; ++i)\n          $root.onnx.StringStringEntryProto.encode(\n            message.initializationBinding[i],\n            writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n          ).ldelim();\n      if (message.updateBinding != null && message.updateBinding.length)\n        for (var i = 0; i < message.updateBinding.length; ++i)\n          $root.onnx.StringStringEntryProto.encode(\n            message.updateBinding[i],\n            writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified TrainingInfoProto message, length delimited. Does not implicitly {@link onnx.TrainingInfoProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {onnx.ITrainingInfoProto} message TrainingInfoProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TrainingInfoProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TrainingInfoProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.TrainingInfoProto} TrainingInfoProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TrainingInfoProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.TrainingInfoProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.initialization = $root.onnx.GraphProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 2: {\n            message.algorithm = $root.onnx.GraphProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 3: {\n            if (!(message.initializationBinding && message.initializationBinding.length))\n              message.initializationBinding = [];\n            message.initializationBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 4: {\n            if (!(message.updateBinding && message.updateBinding.length)) message.updateBinding = [];\n            message.updateBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a TrainingInfoProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.TrainingInfoProto} TrainingInfoProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TrainingInfoProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TrainingInfoProto message.\n     * @function verify\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TrainingInfoProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.initialization != null && message.hasOwnProperty('initialization')) {\n        var error = $root.onnx.GraphProto.verify(message.initialization);\n        if (error) return 'initialization.' + error;\n      }\n      if (message.algorithm != null && message.hasOwnProperty('algorithm')) {\n        var error = $root.onnx.GraphProto.verify(message.algorithm);\n        if (error) return 'algorithm.' + error;\n      }\n      if (message.initializationBinding != null && message.hasOwnProperty('initializationBinding')) {\n        if (!Array.isArray(message.initializationBinding)) return 'initializationBinding: array expected';\n        for (var i = 0; i < message.initializationBinding.length; ++i) {\n          var error = $root.onnx.StringStringEntryProto.verify(message.initializationBinding[i]);\n          if (error) return 'initializationBinding.' + error;\n        }\n      }\n      if (message.updateBinding != null && message.hasOwnProperty('updateBinding')) {\n        if (!Array.isArray(message.updateBinding)) return 'updateBinding: array expected';\n        for (var i = 0; i < message.updateBinding.length; ++i) {\n          var error = $root.onnx.StringStringEntryProto.verify(message.updateBinding[i]);\n          if (error) return 'updateBinding.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a TrainingInfoProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.TrainingInfoProto} TrainingInfoProto\n     */\n    TrainingInfoProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.TrainingInfoProto) return object;\n      var message = new $root.onnx.TrainingInfoProto();\n      if (object.initialization != null) {\n        if (typeof object.initialization !== 'object')\n          throw TypeError('.onnx.TrainingInfoProto.initialization: object expected');\n        message.initialization = $root.onnx.GraphProto.fromObject(object.initialization);\n      }\n      if (object.algorithm != null) {\n        if (typeof object.algorithm !== 'object') throw TypeError('.onnx.TrainingInfoProto.algorithm: object expected');\n        message.algorithm = $root.onnx.GraphProto.fromObject(object.algorithm);\n      }\n      if (object.initializationBinding) {\n        if (!Array.isArray(object.initializationBinding))\n          throw TypeError('.onnx.TrainingInfoProto.initializationBinding: array expected');\n        message.initializationBinding = [];\n        for (var i = 0; i < object.initializationBinding.length; ++i) {\n          if (typeof object.initializationBinding[i] !== 'object')\n            throw TypeError('.onnx.TrainingInfoProto.initializationBinding: object expected');\n          message.initializationBinding[i] = $root.onnx.StringStringEntryProto.fromObject(\n            object.initializationBinding[i],\n          );\n        }\n      }\n      if (object.updateBinding) {\n        if (!Array.isArray(object.updateBinding))\n          throw TypeError('.onnx.TrainingInfoProto.updateBinding: array expected');\n        message.updateBinding = [];\n        for (var i = 0; i < object.updateBinding.length; ++i) {\n          if (typeof object.updateBinding[i] !== 'object')\n            throw TypeError('.onnx.TrainingInfoProto.updateBinding: object expected');\n          message.updateBinding[i] = $root.onnx.StringStringEntryProto.fromObject(object.updateBinding[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a TrainingInfoProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {onnx.TrainingInfoProto} message TrainingInfoProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TrainingInfoProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.initializationBinding = [];\n        object.updateBinding = [];\n      }\n      if (options.defaults) {\n        object.initialization = null;\n        object.algorithm = null;\n      }\n      if (message.initialization != null && message.hasOwnProperty('initialization'))\n        object.initialization = $root.onnx.GraphProto.toObject(message.initialization, options);\n      if (message.algorithm != null && message.hasOwnProperty('algorithm'))\n        object.algorithm = $root.onnx.GraphProto.toObject(message.algorithm, options);\n      if (message.initializationBinding && message.initializationBinding.length) {\n        object.initializationBinding = [];\n        for (var j = 0; j < message.initializationBinding.length; ++j)\n          object.initializationBinding[j] = $root.onnx.StringStringEntryProto.toObject(\n            message.initializationBinding[j],\n            options,\n          );\n      }\n      if (message.updateBinding && message.updateBinding.length) {\n        object.updateBinding = [];\n        for (var j = 0; j < message.updateBinding.length; ++j)\n          object.updateBinding[j] = $root.onnx.StringStringEntryProto.toObject(message.updateBinding[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this TrainingInfoProto to JSON.\n     * @function toJSON\n     * @memberof onnx.TrainingInfoProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TrainingInfoProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TrainingInfoProto\n     * @function getTypeUrl\n     * @memberof onnx.TrainingInfoProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TrainingInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.TrainingInfoProto';\n    };\n\n    return TrainingInfoProto;\n  })();\n\n  onnx.ModelProto = (function () {\n    /**\n     * Properties of a ModelProto.\n     * @memberof onnx\n     * @interface IModelProto\n     * @property {number|Long|null} [irVersion] ModelProto irVersion\n     * @property {Array.<onnx.IOperatorSetIdProto>|null} [opsetImport] ModelProto opsetImport\n     * @property {string|null} [producerName] ModelProto producerName\n     * @property {string|null} [producerVersion] ModelProto producerVersion\n     * @property {string|null} [domain] ModelProto domain\n     * @property {number|Long|null} [modelVersion] ModelProto modelVersion\n     * @property {string|null} [docString] ModelProto docString\n     * @property {onnx.IGraphProto|null} [graph] ModelProto graph\n     * @property {Array.<onnx.IStringStringEntryProto>|null} [metadataProps] ModelProto metadataProps\n     * @property {Array.<onnx.ITrainingInfoProto>|null} [trainingInfo] ModelProto trainingInfo\n     * @property {Array.<onnx.IFunctionProto>|null} [functions] ModelProto functions\n     */\n\n    /**\n     * Constructs a new ModelProto.\n     * @memberof onnx\n     * @classdesc Represents a ModelProto.\n     * @implements IModelProto\n     * @constructor\n     * @param {onnx.IModelProto=} [properties] Properties to set\n     */\n    function ModelProto(properties) {\n      this.opsetImport = [];\n      this.metadataProps = [];\n      this.trainingInfo = [];\n      this.functions = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ModelProto irVersion.\n     * @member {number|Long} irVersion\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.irVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n    /**\n     * ModelProto opsetImport.\n     * @member {Array.<onnx.IOperatorSetIdProto>} opsetImport\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.opsetImport = $util.emptyArray;\n\n    /**\n     * ModelProto producerName.\n     * @member {string} producerName\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.producerName = '';\n\n    /**\n     * ModelProto producerVersion.\n     * @member {string} producerVersion\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.producerVersion = '';\n\n    /**\n     * ModelProto domain.\n     * @member {string} domain\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.domain = '';\n\n    /**\n     * ModelProto modelVersion.\n     * @member {number|Long} modelVersion\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.modelVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n    /**\n     * ModelProto docString.\n     * @member {string} docString\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.docString = '';\n\n    /**\n     * ModelProto graph.\n     * @member {onnx.IGraphProto|null|undefined} graph\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.graph = null;\n\n    /**\n     * ModelProto metadataProps.\n     * @member {Array.<onnx.IStringStringEntryProto>} metadataProps\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.metadataProps = $util.emptyArray;\n\n    /**\n     * ModelProto trainingInfo.\n     * @member {Array.<onnx.ITrainingInfoProto>} trainingInfo\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.trainingInfo = $util.emptyArray;\n\n    /**\n     * ModelProto functions.\n     * @member {Array.<onnx.IFunctionProto>} functions\n     * @memberof onnx.ModelProto\n     * @instance\n     */\n    ModelProto.prototype.functions = $util.emptyArray;\n\n    /**\n     * Creates a new ModelProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {onnx.IModelProto=} [properties] Properties to set\n     * @returns {onnx.ModelProto} ModelProto instance\n     */\n    ModelProto.create = function create(properties) {\n      return new ModelProto(properties);\n    };\n\n    /**\n     * Encodes the specified ModelProto message. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {onnx.IModelProto} message ModelProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ModelProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.irVersion != null && Object.hasOwnProperty.call(message, 'irVersion'))\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.irVersion);\n      if (message.producerName != null && Object.hasOwnProperty.call(message, 'producerName'))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.producerName);\n      if (message.producerVersion != null && Object.hasOwnProperty.call(message, 'producerVersion'))\n        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.producerVersion);\n      if (message.domain != null && Object.hasOwnProperty.call(message, 'domain'))\n        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.domain);\n      if (message.modelVersion != null && Object.hasOwnProperty.call(message, 'modelVersion'))\n        writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.modelVersion);\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.docString);\n      if (message.graph != null && Object.hasOwnProperty.call(message, 'graph'))\n        $root.onnx.GraphProto.encode(message.graph, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();\n      if (message.opsetImport != null && message.opsetImport.length)\n        for (var i = 0; i < message.opsetImport.length; ++i)\n          $root.onnx.OperatorSetIdProto.encode(\n            message.opsetImport[i],\n            writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),\n          ).ldelim();\n      if (message.metadataProps != null && message.metadataProps.length)\n        for (var i = 0; i < message.metadataProps.length; ++i)\n          $root.onnx.StringStringEntryProto.encode(\n            message.metadataProps[i],\n            writer.uint32(/* id 14, wireType 2 =*/ 114).fork(),\n          ).ldelim();\n      if (message.trainingInfo != null && message.trainingInfo.length)\n        for (var i = 0; i < message.trainingInfo.length; ++i)\n          $root.onnx.TrainingInfoProto.encode(\n            message.trainingInfo[i],\n            writer.uint32(/* id 20, wireType 2 =*/ 162).fork(),\n          ).ldelim();\n      if (message.functions != null && message.functions.length)\n        for (var i = 0; i < message.functions.length; ++i)\n          $root.onnx.FunctionProto.encode(\n            message.functions[i],\n            writer.uint32(/* id 25, wireType 2 =*/ 202).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified ModelProto message, length delimited. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {onnx.IModelProto} message ModelProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ModelProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ModelProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.ModelProto} ModelProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ModelProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.ModelProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.irVersion = reader.int64();\n            break;\n          }\n          case 8: {\n            if (!(message.opsetImport && message.opsetImport.length)) message.opsetImport = [];\n            message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 2: {\n            message.producerName = reader.string();\n            break;\n          }\n          case 3: {\n            message.producerVersion = reader.string();\n            break;\n          }\n          case 4: {\n            message.domain = reader.string();\n            break;\n          }\n          case 5: {\n            message.modelVersion = reader.int64();\n            break;\n          }\n          case 6: {\n            message.docString = reader.string();\n            break;\n          }\n          case 7: {\n            message.graph = $root.onnx.GraphProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 14: {\n            if (!(message.metadataProps && message.metadataProps.length)) message.metadataProps = [];\n            message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 20: {\n            if (!(message.trainingInfo && message.trainingInfo.length)) message.trainingInfo = [];\n            message.trainingInfo.push($root.onnx.TrainingInfoProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 25: {\n            if (!(message.functions && message.functions.length)) message.functions = [];\n            message.functions.push($root.onnx.FunctionProto.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a ModelProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.ModelProto} ModelProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ModelProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ModelProto message.\n     * @function verify\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ModelProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.irVersion != null && message.hasOwnProperty('irVersion'))\n        if (\n          !$util.isInteger(message.irVersion) &&\n          !(message.irVersion && $util.isInteger(message.irVersion.low) && $util.isInteger(message.irVersion.high))\n        )\n          return 'irVersion: integer|Long expected';\n      if (message.opsetImport != null && message.hasOwnProperty('opsetImport')) {\n        if (!Array.isArray(message.opsetImport)) return 'opsetImport: array expected';\n        for (var i = 0; i < message.opsetImport.length; ++i) {\n          var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);\n          if (error) return 'opsetImport.' + error;\n        }\n      }\n      if (message.producerName != null && message.hasOwnProperty('producerName'))\n        if (!$util.isString(message.producerName)) return 'producerName: string expected';\n      if (message.producerVersion != null && message.hasOwnProperty('producerVersion'))\n        if (!$util.isString(message.producerVersion)) return 'producerVersion: string expected';\n      if (message.domain != null && message.hasOwnProperty('domain'))\n        if (!$util.isString(message.domain)) return 'domain: string expected';\n      if (message.modelVersion != null && message.hasOwnProperty('modelVersion'))\n        if (\n          !$util.isInteger(message.modelVersion) &&\n          !(\n            message.modelVersion &&\n            $util.isInteger(message.modelVersion.low) &&\n            $util.isInteger(message.modelVersion.high)\n          )\n        )\n          return 'modelVersion: integer|Long expected';\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      if (message.graph != null && message.hasOwnProperty('graph')) {\n        var error = $root.onnx.GraphProto.verify(message.graph);\n        if (error) return 'graph.' + error;\n      }\n      if (message.metadataProps != null && message.hasOwnProperty('metadataProps')) {\n        if (!Array.isArray(message.metadataProps)) return 'metadataProps: array expected';\n        for (var i = 0; i < message.metadataProps.length; ++i) {\n          var error = $root.onnx.StringStringEntryProto.verify(message.metadataProps[i]);\n          if (error) return 'metadataProps.' + error;\n        }\n      }\n      if (message.trainingInfo != null && message.hasOwnProperty('trainingInfo')) {\n        if (!Array.isArray(message.trainingInfo)) return 'trainingInfo: array expected';\n        for (var i = 0; i < message.trainingInfo.length; ++i) {\n          var error = $root.onnx.TrainingInfoProto.verify(message.trainingInfo[i]);\n          if (error) return 'trainingInfo.' + error;\n        }\n      }\n      if (message.functions != null && message.hasOwnProperty('functions')) {\n        if (!Array.isArray(message.functions)) return 'functions: array expected';\n        for (var i = 0; i < message.functions.length; ++i) {\n          var error = $root.onnx.FunctionProto.verify(message.functions[i]);\n          if (error) return 'functions.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a ModelProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.ModelProto} ModelProto\n     */\n    ModelProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.ModelProto) return object;\n      var message = new $root.onnx.ModelProto();\n      if (object.irVersion != null)\n        if ($util.Long) (message.irVersion = $util.Long.fromValue(object.irVersion)).unsigned = false;\n        else if (typeof object.irVersion === 'string') message.irVersion = parseInt(object.irVersion, 10);\n        else if (typeof object.irVersion === 'number') message.irVersion = object.irVersion;\n        else if (typeof object.irVersion === 'object')\n          message.irVersion = new $util.LongBits(object.irVersion.low >>> 0, object.irVersion.high >>> 0).toNumber();\n      if (object.opsetImport) {\n        if (!Array.isArray(object.opsetImport)) throw TypeError('.onnx.ModelProto.opsetImport: array expected');\n        message.opsetImport = [];\n        for (var i = 0; i < object.opsetImport.length; ++i) {\n          if (typeof object.opsetImport[i] !== 'object')\n            throw TypeError('.onnx.ModelProto.opsetImport: object expected');\n          message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);\n        }\n      }\n      if (object.producerName != null) message.producerName = String(object.producerName);\n      if (object.producerVersion != null) message.producerVersion = String(object.producerVersion);\n      if (object.domain != null) message.domain = String(object.domain);\n      if (object.modelVersion != null)\n        if ($util.Long) (message.modelVersion = $util.Long.fromValue(object.modelVersion)).unsigned = false;\n        else if (typeof object.modelVersion === 'string') message.modelVersion = parseInt(object.modelVersion, 10);\n        else if (typeof object.modelVersion === 'number') message.modelVersion = object.modelVersion;\n        else if (typeof object.modelVersion === 'object')\n          message.modelVersion = new $util.LongBits(\n            object.modelVersion.low >>> 0,\n            object.modelVersion.high >>> 0,\n          ).toNumber();\n      if (object.docString != null) message.docString = String(object.docString);\n      if (object.graph != null) {\n        if (typeof object.graph !== 'object') throw TypeError('.onnx.ModelProto.graph: object expected');\n        message.graph = $root.onnx.GraphProto.fromObject(object.graph);\n      }\n      if (object.metadataProps) {\n        if (!Array.isArray(object.metadataProps)) throw TypeError('.onnx.ModelProto.metadataProps: array expected');\n        message.metadataProps = [];\n        for (var i = 0; i < object.metadataProps.length; ++i) {\n          if (typeof object.metadataProps[i] !== 'object')\n            throw TypeError('.onnx.ModelProto.metadataProps: object expected');\n          message.metadataProps[i] = $root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i]);\n        }\n      }\n      if (object.trainingInfo) {\n        if (!Array.isArray(object.trainingInfo)) throw TypeError('.onnx.ModelProto.trainingInfo: array expected');\n        message.trainingInfo = [];\n        for (var i = 0; i < object.trainingInfo.length; ++i) {\n          if (typeof object.trainingInfo[i] !== 'object')\n            throw TypeError('.onnx.ModelProto.trainingInfo: object expected');\n          message.trainingInfo[i] = $root.onnx.TrainingInfoProto.fromObject(object.trainingInfo[i]);\n        }\n      }\n      if (object.functions) {\n        if (!Array.isArray(object.functions)) throw TypeError('.onnx.ModelProto.functions: array expected');\n        message.functions = [];\n        for (var i = 0; i < object.functions.length; ++i) {\n          if (typeof object.functions[i] !== 'object') throw TypeError('.onnx.ModelProto.functions: object expected');\n          message.functions[i] = $root.onnx.FunctionProto.fromObject(object.functions[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a ModelProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {onnx.ModelProto} message ModelProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ModelProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.opsetImport = [];\n        object.metadataProps = [];\n        object.trainingInfo = [];\n        object.functions = [];\n      }\n      if (options.defaults) {\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, false);\n          object.irVersion =\n            options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.irVersion = options.longs === String ? '0' : 0;\n        object.producerName = '';\n        object.producerVersion = '';\n        object.domain = '';\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, false);\n          object.modelVersion =\n            options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.modelVersion = options.longs === String ? '0' : 0;\n        object.docString = '';\n        object.graph = null;\n      }\n      if (message.irVersion != null && message.hasOwnProperty('irVersion'))\n        if (typeof message.irVersion === 'number')\n          object.irVersion = options.longs === String ? String(message.irVersion) : message.irVersion;\n        else\n          object.irVersion =\n            options.longs === String\n              ? $util.Long.prototype.toString.call(message.irVersion)\n              : options.longs === Number\n                ? new $util.LongBits(message.irVersion.low >>> 0, message.irVersion.high >>> 0).toNumber()\n                : message.irVersion;\n      if (message.producerName != null && message.hasOwnProperty('producerName'))\n        object.producerName = message.producerName;\n      if (message.producerVersion != null && message.hasOwnProperty('producerVersion'))\n        object.producerVersion = message.producerVersion;\n      if (message.domain != null && message.hasOwnProperty('domain')) object.domain = message.domain;\n      if (message.modelVersion != null && message.hasOwnProperty('modelVersion'))\n        if (typeof message.modelVersion === 'number')\n          object.modelVersion = options.longs === String ? String(message.modelVersion) : message.modelVersion;\n        else\n          object.modelVersion =\n            options.longs === String\n              ? $util.Long.prototype.toString.call(message.modelVersion)\n              : options.longs === Number\n                ? new $util.LongBits(message.modelVersion.low >>> 0, message.modelVersion.high >>> 0).toNumber()\n                : message.modelVersion;\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.graph != null && message.hasOwnProperty('graph'))\n        object.graph = $root.onnx.GraphProto.toObject(message.graph, options);\n      if (message.opsetImport && message.opsetImport.length) {\n        object.opsetImport = [];\n        for (var j = 0; j < message.opsetImport.length; ++j)\n          object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);\n      }\n      if (message.metadataProps && message.metadataProps.length) {\n        object.metadataProps = [];\n        for (var j = 0; j < message.metadataProps.length; ++j)\n          object.metadataProps[j] = $root.onnx.StringStringEntryProto.toObject(message.metadataProps[j], options);\n      }\n      if (message.trainingInfo && message.trainingInfo.length) {\n        object.trainingInfo = [];\n        for (var j = 0; j < message.trainingInfo.length; ++j)\n          object.trainingInfo[j] = $root.onnx.TrainingInfoProto.toObject(message.trainingInfo[j], options);\n      }\n      if (message.functions && message.functions.length) {\n        object.functions = [];\n        for (var j = 0; j < message.functions.length; ++j)\n          object.functions[j] = $root.onnx.FunctionProto.toObject(message.functions[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this ModelProto to JSON.\n     * @function toJSON\n     * @memberof onnx.ModelProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ModelProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for ModelProto\n     * @function getTypeUrl\n     * @memberof onnx.ModelProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    ModelProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.ModelProto';\n    };\n\n    return ModelProto;\n  })();\n\n  onnx.StringStringEntryProto = (function () {\n    /**\n     * Properties of a StringStringEntryProto.\n     * @memberof onnx\n     * @interface IStringStringEntryProto\n     * @property {string|null} [key] StringStringEntryProto key\n     * @property {string|null} [value] StringStringEntryProto value\n     */\n\n    /**\n     * Constructs a new StringStringEntryProto.\n     * @memberof onnx\n     * @classdesc Represents a StringStringEntryProto.\n     * @implements IStringStringEntryProto\n     * @constructor\n     * @param {onnx.IStringStringEntryProto=} [properties] Properties to set\n     */\n    function StringStringEntryProto(properties) {\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * StringStringEntryProto key.\n     * @member {string} key\n     * @memberof onnx.StringStringEntryProto\n     * @instance\n     */\n    StringStringEntryProto.prototype.key = '';\n\n    /**\n     * StringStringEntryProto value.\n     * @member {string} value\n     * @memberof onnx.StringStringEntryProto\n     * @instance\n     */\n    StringStringEntryProto.prototype.value = '';\n\n    /**\n     * Creates a new StringStringEntryProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {onnx.IStringStringEntryProto=} [properties] Properties to set\n     * @returns {onnx.StringStringEntryProto} StringStringEntryProto instance\n     */\n    StringStringEntryProto.create = function create(properties) {\n      return new StringStringEntryProto(properties);\n    };\n\n    /**\n     * Encodes the specified StringStringEntryProto message. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StringStringEntryProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.key != null && Object.hasOwnProperty.call(message, 'key'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);\n      if (message.value != null && Object.hasOwnProperty.call(message, 'value'))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified StringStringEntryProto message, length delimited. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StringStringEntryProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a StringStringEntryProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StringStringEntryProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.StringStringEntryProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.key = reader.string();\n            break;\n          }\n          case 2: {\n            message.value = reader.string();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a StringStringEntryProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StringStringEntryProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a StringStringEntryProto message.\n     * @function verify\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    StringStringEntryProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.key != null && message.hasOwnProperty('key'))\n        if (!$util.isString(message.key)) return 'key: string expected';\n      if (message.value != null && message.hasOwnProperty('value'))\n        if (!$util.isString(message.value)) return 'value: string expected';\n      return null;\n    };\n\n    /**\n     * Creates a StringStringEntryProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n     */\n    StringStringEntryProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.StringStringEntryProto) return object;\n      var message = new $root.onnx.StringStringEntryProto();\n      if (object.key != null) message.key = String(object.key);\n      if (object.value != null) message.value = String(object.value);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a StringStringEntryProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {onnx.StringStringEntryProto} message StringStringEntryProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    StringStringEntryProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        object.key = '';\n        object.value = '';\n      }\n      if (message.key != null && message.hasOwnProperty('key')) object.key = message.key;\n      if (message.value != null && message.hasOwnProperty('value')) object.value = message.value;\n      return object;\n    };\n\n    /**\n     * Converts this StringStringEntryProto to JSON.\n     * @function toJSON\n     * @memberof onnx.StringStringEntryProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    StringStringEntryProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for StringStringEntryProto\n     * @function getTypeUrl\n     * @memberof onnx.StringStringEntryProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    StringStringEntryProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.StringStringEntryProto';\n    };\n\n    return StringStringEntryProto;\n  })();\n\n  onnx.TensorAnnotation = (function () {\n    /**\n     * Properties of a TensorAnnotation.\n     * @memberof onnx\n     * @interface ITensorAnnotation\n     * @property {string|null} [tensorName] TensorAnnotation tensorName\n     * @property {Array.<onnx.IStringStringEntryProto>|null} [quantParameterTensorNames] TensorAnnotation quantParameterTensorNames\n     */\n\n    /**\n     * Constructs a new TensorAnnotation.\n     * @memberof onnx\n     * @classdesc Represents a TensorAnnotation.\n     * @implements ITensorAnnotation\n     * @constructor\n     * @param {onnx.ITensorAnnotation=} [properties] Properties to set\n     */\n    function TensorAnnotation(properties) {\n      this.quantParameterTensorNames = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TensorAnnotation tensorName.\n     * @member {string} tensorName\n     * @memberof onnx.TensorAnnotation\n     * @instance\n     */\n    TensorAnnotation.prototype.tensorName = '';\n\n    /**\n     * TensorAnnotation quantParameterTensorNames.\n     * @member {Array.<onnx.IStringStringEntryProto>} quantParameterTensorNames\n     * @memberof onnx.TensorAnnotation\n     * @instance\n     */\n    TensorAnnotation.prototype.quantParameterTensorNames = $util.emptyArray;\n\n    /**\n     * Creates a new TensorAnnotation instance using the specified properties.\n     * @function create\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {onnx.ITensorAnnotation=} [properties] Properties to set\n     * @returns {onnx.TensorAnnotation} TensorAnnotation instance\n     */\n    TensorAnnotation.create = function create(properties) {\n      return new TensorAnnotation(properties);\n    };\n\n    /**\n     * Encodes the specified TensorAnnotation message. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorAnnotation.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.tensorName != null && Object.hasOwnProperty.call(message, 'tensorName'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.tensorName);\n      if (message.quantParameterTensorNames != null && message.quantParameterTensorNames.length)\n        for (var i = 0; i < message.quantParameterTensorNames.length; ++i)\n          $root.onnx.StringStringEntryProto.encode(\n            message.quantParameterTensorNames[i],\n            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified TensorAnnotation message, length delimited. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorAnnotation.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TensorAnnotation message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.TensorAnnotation} TensorAnnotation\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorAnnotation.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.TensorAnnotation();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.tensorName = reader.string();\n            break;\n          }\n          case 2: {\n            if (!(message.quantParameterTensorNames && message.quantParameterTensorNames.length))\n              message.quantParameterTensorNames = [];\n            message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a TensorAnnotation message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.TensorAnnotation} TensorAnnotation\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorAnnotation.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TensorAnnotation message.\n     * @function verify\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TensorAnnotation.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.tensorName != null && message.hasOwnProperty('tensorName'))\n        if (!$util.isString(message.tensorName)) return 'tensorName: string expected';\n      if (message.quantParameterTensorNames != null && message.hasOwnProperty('quantParameterTensorNames')) {\n        if (!Array.isArray(message.quantParameterTensorNames)) return 'quantParameterTensorNames: array expected';\n        for (var i = 0; i < message.quantParameterTensorNames.length; ++i) {\n          var error = $root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);\n          if (error) return 'quantParameterTensorNames.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a TensorAnnotation message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.TensorAnnotation} TensorAnnotation\n     */\n    TensorAnnotation.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.TensorAnnotation) return object;\n      var message = new $root.onnx.TensorAnnotation();\n      if (object.tensorName != null) message.tensorName = String(object.tensorName);\n      if (object.quantParameterTensorNames) {\n        if (!Array.isArray(object.quantParameterTensorNames))\n          throw TypeError('.onnx.TensorAnnotation.quantParameterTensorNames: array expected');\n        message.quantParameterTensorNames = [];\n        for (var i = 0; i < object.quantParameterTensorNames.length; ++i) {\n          if (typeof object.quantParameterTensorNames[i] !== 'object')\n            throw TypeError('.onnx.TensorAnnotation.quantParameterTensorNames: object expected');\n          message.quantParameterTensorNames[i] = $root.onnx.StringStringEntryProto.fromObject(\n            object.quantParameterTensorNames[i],\n          );\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a TensorAnnotation message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {onnx.TensorAnnotation} message TensorAnnotation\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TensorAnnotation.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.quantParameterTensorNames = [];\n      if (options.defaults) object.tensorName = '';\n      if (message.tensorName != null && message.hasOwnProperty('tensorName')) object.tensorName = message.tensorName;\n      if (message.quantParameterTensorNames && message.quantParameterTensorNames.length) {\n        object.quantParameterTensorNames = [];\n        for (var j = 0; j < message.quantParameterTensorNames.length; ++j)\n          object.quantParameterTensorNames[j] = $root.onnx.StringStringEntryProto.toObject(\n            message.quantParameterTensorNames[j],\n            options,\n          );\n      }\n      return object;\n    };\n\n    /**\n     * Converts this TensorAnnotation to JSON.\n     * @function toJSON\n     * @memberof onnx.TensorAnnotation\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TensorAnnotation.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TensorAnnotation\n     * @function getTypeUrl\n     * @memberof onnx.TensorAnnotation\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TensorAnnotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.TensorAnnotation';\n    };\n\n    return TensorAnnotation;\n  })();\n\n  onnx.GraphProto = (function () {\n    /**\n     * Properties of a GraphProto.\n     * @memberof onnx\n     * @interface IGraphProto\n     * @property {Array.<onnx.INodeProto>|null} [node] GraphProto node\n     * @property {string|null} [name] GraphProto name\n     * @property {Array.<onnx.ITensorProto>|null} [initializer] GraphProto initializer\n     * @property {Array.<onnx.ISparseTensorProto>|null} [sparseInitializer] GraphProto sparseInitializer\n     * @property {string|null} [docString] GraphProto docString\n     * @property {Array.<onnx.IValueInfoProto>|null} [input] GraphProto input\n     * @property {Array.<onnx.IValueInfoProto>|null} [output] GraphProto output\n     * @property {Array.<onnx.IValueInfoProto>|null} [valueInfo] GraphProto valueInfo\n     * @property {Array.<onnx.ITensorAnnotation>|null} [quantizationAnnotation] GraphProto quantizationAnnotation\n     */\n\n    /**\n     * Constructs a new GraphProto.\n     * @memberof onnx\n     * @classdesc Represents a GraphProto.\n     * @implements IGraphProto\n     * @constructor\n     * @param {onnx.IGraphProto=} [properties] Properties to set\n     */\n    function GraphProto(properties) {\n      this.node = [];\n      this.initializer = [];\n      this.sparseInitializer = [];\n      this.input = [];\n      this.output = [];\n      this.valueInfo = [];\n      this.quantizationAnnotation = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * GraphProto node.\n     * @member {Array.<onnx.INodeProto>} node\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.node = $util.emptyArray;\n\n    /**\n     * GraphProto name.\n     * @member {string} name\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.name = '';\n\n    /**\n     * GraphProto initializer.\n     * @member {Array.<onnx.ITensorProto>} initializer\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.initializer = $util.emptyArray;\n\n    /**\n     * GraphProto sparseInitializer.\n     * @member {Array.<onnx.ISparseTensorProto>} sparseInitializer\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.sparseInitializer = $util.emptyArray;\n\n    /**\n     * GraphProto docString.\n     * @member {string} docString\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.docString = '';\n\n    /**\n     * GraphProto input.\n     * @member {Array.<onnx.IValueInfoProto>} input\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.input = $util.emptyArray;\n\n    /**\n     * GraphProto output.\n     * @member {Array.<onnx.IValueInfoProto>} output\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.output = $util.emptyArray;\n\n    /**\n     * GraphProto valueInfo.\n     * @member {Array.<onnx.IValueInfoProto>} valueInfo\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.valueInfo = $util.emptyArray;\n\n    /**\n     * GraphProto quantizationAnnotation.\n     * @member {Array.<onnx.ITensorAnnotation>} quantizationAnnotation\n     * @memberof onnx.GraphProto\n     * @instance\n     */\n    GraphProto.prototype.quantizationAnnotation = $util.emptyArray;\n\n    /**\n     * Creates a new GraphProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {onnx.IGraphProto=} [properties] Properties to set\n     * @returns {onnx.GraphProto} GraphProto instance\n     */\n    GraphProto.create = function create(properties) {\n      return new GraphProto(properties);\n    };\n\n    /**\n     * Encodes the specified GraphProto message. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {onnx.IGraphProto} message GraphProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    GraphProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.node != null && message.node.length)\n        for (var i = 0; i < message.node.length; ++i)\n          $root.onnx.NodeProto.encode(message.node[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);\n      if (message.initializer != null && message.initializer.length)\n        for (var i = 0; i < message.initializer.length; ++i)\n          $root.onnx.TensorProto.encode(\n            message.initializer[i],\n            writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),\n          ).ldelim();\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.docString);\n      if (message.input != null && message.input.length)\n        for (var i = 0; i < message.input.length; ++i)\n          $root.onnx.ValueInfoProto.encode(\n            message.input[i],\n            writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),\n          ).ldelim();\n      if (message.output != null && message.output.length)\n        for (var i = 0; i < message.output.length; ++i)\n          $root.onnx.ValueInfoProto.encode(\n            message.output[i],\n            writer.uint32(/* id 12, wireType 2 =*/ 98).fork(),\n          ).ldelim();\n      if (message.valueInfo != null && message.valueInfo.length)\n        for (var i = 0; i < message.valueInfo.length; ++i)\n          $root.onnx.ValueInfoProto.encode(\n            message.valueInfo[i],\n            writer.uint32(/* id 13, wireType 2 =*/ 106).fork(),\n          ).ldelim();\n      if (message.quantizationAnnotation != null && message.quantizationAnnotation.length)\n        for (var i = 0; i < message.quantizationAnnotation.length; ++i)\n          $root.onnx.TensorAnnotation.encode(\n            message.quantizationAnnotation[i],\n            writer.uint32(/* id 14, wireType 2 =*/ 114).fork(),\n          ).ldelim();\n      if (message.sparseInitializer != null && message.sparseInitializer.length)\n        for (var i = 0; i < message.sparseInitializer.length; ++i)\n          $root.onnx.SparseTensorProto.encode(\n            message.sparseInitializer[i],\n            writer.uint32(/* id 15, wireType 2 =*/ 122).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified GraphProto message, length delimited. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {onnx.IGraphProto} message GraphProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    GraphProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a GraphProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.GraphProto} GraphProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    GraphProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.GraphProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            if (!(message.node && message.node.length)) message.node = [];\n            message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 2: {\n            message.name = reader.string();\n            break;\n          }\n          case 5: {\n            if (!(message.initializer && message.initializer.length)) message.initializer = [];\n            message.initializer.push($root.onnx.TensorProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 15: {\n            if (!(message.sparseInitializer && message.sparseInitializer.length)) message.sparseInitializer = [];\n            message.sparseInitializer.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 10: {\n            message.docString = reader.string();\n            break;\n          }\n          case 11: {\n            if (!(message.input && message.input.length)) message.input = [];\n            message.input.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 12: {\n            if (!(message.output && message.output.length)) message.output = [];\n            message.output.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 13: {\n            if (!(message.valueInfo && message.valueInfo.length)) message.valueInfo = [];\n            message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 14: {\n            if (!(message.quantizationAnnotation && message.quantizationAnnotation.length))\n              message.quantizationAnnotation = [];\n            message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a GraphProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.GraphProto} GraphProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    GraphProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a GraphProto message.\n     * @function verify\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    GraphProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.node != null && message.hasOwnProperty('node')) {\n        if (!Array.isArray(message.node)) return 'node: array expected';\n        for (var i = 0; i < message.node.length; ++i) {\n          var error = $root.onnx.NodeProto.verify(message.node[i]);\n          if (error) return 'node.' + error;\n        }\n      }\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.initializer != null && message.hasOwnProperty('initializer')) {\n        if (!Array.isArray(message.initializer)) return 'initializer: array expected';\n        for (var i = 0; i < message.initializer.length; ++i) {\n          var error = $root.onnx.TensorProto.verify(message.initializer[i]);\n          if (error) return 'initializer.' + error;\n        }\n      }\n      if (message.sparseInitializer != null && message.hasOwnProperty('sparseInitializer')) {\n        if (!Array.isArray(message.sparseInitializer)) return 'sparseInitializer: array expected';\n        for (var i = 0; i < message.sparseInitializer.length; ++i) {\n          var error = $root.onnx.SparseTensorProto.verify(message.sparseInitializer[i]);\n          if (error) return 'sparseInitializer.' + error;\n        }\n      }\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      if (message.input != null && message.hasOwnProperty('input')) {\n        if (!Array.isArray(message.input)) return 'input: array expected';\n        for (var i = 0; i < message.input.length; ++i) {\n          var error = $root.onnx.ValueInfoProto.verify(message.input[i]);\n          if (error) return 'input.' + error;\n        }\n      }\n      if (message.output != null && message.hasOwnProperty('output')) {\n        if (!Array.isArray(message.output)) return 'output: array expected';\n        for (var i = 0; i < message.output.length; ++i) {\n          var error = $root.onnx.ValueInfoProto.verify(message.output[i]);\n          if (error) return 'output.' + error;\n        }\n      }\n      if (message.valueInfo != null && message.hasOwnProperty('valueInfo')) {\n        if (!Array.isArray(message.valueInfo)) return 'valueInfo: array expected';\n        for (var i = 0; i < message.valueInfo.length; ++i) {\n          var error = $root.onnx.ValueInfoProto.verify(message.valueInfo[i]);\n          if (error) return 'valueInfo.' + error;\n        }\n      }\n      if (message.quantizationAnnotation != null && message.hasOwnProperty('quantizationAnnotation')) {\n        if (!Array.isArray(message.quantizationAnnotation)) return 'quantizationAnnotation: array expected';\n        for (var i = 0; i < message.quantizationAnnotation.length; ++i) {\n          var error = $root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]);\n          if (error) return 'quantizationAnnotation.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a GraphProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.GraphProto} GraphProto\n     */\n    GraphProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.GraphProto) return object;\n      var message = new $root.onnx.GraphProto();\n      if (object.node) {\n        if (!Array.isArray(object.node)) throw TypeError('.onnx.GraphProto.node: array expected');\n        message.node = [];\n        for (var i = 0; i < object.node.length; ++i) {\n          if (typeof object.node[i] !== 'object') throw TypeError('.onnx.GraphProto.node: object expected');\n          message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);\n        }\n      }\n      if (object.name != null) message.name = String(object.name);\n      if (object.initializer) {\n        if (!Array.isArray(object.initializer)) throw TypeError('.onnx.GraphProto.initializer: array expected');\n        message.initializer = [];\n        for (var i = 0; i < object.initializer.length; ++i) {\n          if (typeof object.initializer[i] !== 'object')\n            throw TypeError('.onnx.GraphProto.initializer: object expected');\n          message.initializer[i] = $root.onnx.TensorProto.fromObject(object.initializer[i]);\n        }\n      }\n      if (object.sparseInitializer) {\n        if (!Array.isArray(object.sparseInitializer))\n          throw TypeError('.onnx.GraphProto.sparseInitializer: array expected');\n        message.sparseInitializer = [];\n        for (var i = 0; i < object.sparseInitializer.length; ++i) {\n          if (typeof object.sparseInitializer[i] !== 'object')\n            throw TypeError('.onnx.GraphProto.sparseInitializer: object expected');\n          message.sparseInitializer[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseInitializer[i]);\n        }\n      }\n      if (object.docString != null) message.docString = String(object.docString);\n      if (object.input) {\n        if (!Array.isArray(object.input)) throw TypeError('.onnx.GraphProto.input: array expected');\n        message.input = [];\n        for (var i = 0; i < object.input.length; ++i) {\n          if (typeof object.input[i] !== 'object') throw TypeError('.onnx.GraphProto.input: object expected');\n          message.input[i] = $root.onnx.ValueInfoProto.fromObject(object.input[i]);\n        }\n      }\n      if (object.output) {\n        if (!Array.isArray(object.output)) throw TypeError('.onnx.GraphProto.output: array expected');\n        message.output = [];\n        for (var i = 0; i < object.output.length; ++i) {\n          if (typeof object.output[i] !== 'object') throw TypeError('.onnx.GraphProto.output: object expected');\n          message.output[i] = $root.onnx.ValueInfoProto.fromObject(object.output[i]);\n        }\n      }\n      if (object.valueInfo) {\n        if (!Array.isArray(object.valueInfo)) throw TypeError('.onnx.GraphProto.valueInfo: array expected');\n        message.valueInfo = [];\n        for (var i = 0; i < object.valueInfo.length; ++i) {\n          if (typeof object.valueInfo[i] !== 'object') throw TypeError('.onnx.GraphProto.valueInfo: object expected');\n          message.valueInfo[i] = $root.onnx.ValueInfoProto.fromObject(object.valueInfo[i]);\n        }\n      }\n      if (object.quantizationAnnotation) {\n        if (!Array.isArray(object.quantizationAnnotation))\n          throw TypeError('.onnx.GraphProto.quantizationAnnotation: array expected');\n        message.quantizationAnnotation = [];\n        for (var i = 0; i < object.quantizationAnnotation.length; ++i) {\n          if (typeof object.quantizationAnnotation[i] !== 'object')\n            throw TypeError('.onnx.GraphProto.quantizationAnnotation: object expected');\n          message.quantizationAnnotation[i] = $root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a GraphProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {onnx.GraphProto} message GraphProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    GraphProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.node = [];\n        object.initializer = [];\n        object.input = [];\n        object.output = [];\n        object.valueInfo = [];\n        object.quantizationAnnotation = [];\n        object.sparseInitializer = [];\n      }\n      if (options.defaults) {\n        object.name = '';\n        object.docString = '';\n      }\n      if (message.node && message.node.length) {\n        object.node = [];\n        for (var j = 0; j < message.node.length; ++j)\n          object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.initializer && message.initializer.length) {\n        object.initializer = [];\n        for (var j = 0; j < message.initializer.length; ++j)\n          object.initializer[j] = $root.onnx.TensorProto.toObject(message.initializer[j], options);\n      }\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.input && message.input.length) {\n        object.input = [];\n        for (var j = 0; j < message.input.length; ++j)\n          object.input[j] = $root.onnx.ValueInfoProto.toObject(message.input[j], options);\n      }\n      if (message.output && message.output.length) {\n        object.output = [];\n        for (var j = 0; j < message.output.length; ++j)\n          object.output[j] = $root.onnx.ValueInfoProto.toObject(message.output[j], options);\n      }\n      if (message.valueInfo && message.valueInfo.length) {\n        object.valueInfo = [];\n        for (var j = 0; j < message.valueInfo.length; ++j)\n          object.valueInfo[j] = $root.onnx.ValueInfoProto.toObject(message.valueInfo[j], options);\n      }\n      if (message.quantizationAnnotation && message.quantizationAnnotation.length) {\n        object.quantizationAnnotation = [];\n        for (var j = 0; j < message.quantizationAnnotation.length; ++j)\n          object.quantizationAnnotation[j] = $root.onnx.TensorAnnotation.toObject(\n            message.quantizationAnnotation[j],\n            options,\n          );\n      }\n      if (message.sparseInitializer && message.sparseInitializer.length) {\n        object.sparseInitializer = [];\n        for (var j = 0; j < message.sparseInitializer.length; ++j)\n          object.sparseInitializer[j] = $root.onnx.SparseTensorProto.toObject(message.sparseInitializer[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this GraphProto to JSON.\n     * @function toJSON\n     * @memberof onnx.GraphProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    GraphProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for GraphProto\n     * @function getTypeUrl\n     * @memberof onnx.GraphProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    GraphProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.GraphProto';\n    };\n\n    return GraphProto;\n  })();\n\n  onnx.TensorProto = (function () {\n    /**\n     * Properties of a TensorProto.\n     * @memberof onnx\n     * @interface ITensorProto\n     * @property {Array.<number|Long>|null} [dims] TensorProto dims\n     * @property {number|null} [dataType] TensorProto dataType\n     * @property {onnx.TensorProto.ISegment|null} [segment] TensorProto segment\n     * @property {Array.<number>|null} [floatData] TensorProto floatData\n     * @property {Array.<number>|null} [int32Data] TensorProto int32Data\n     * @property {Array.<Uint8Array>|null} [stringData] TensorProto stringData\n     * @property {Array.<number|Long>|null} [int64Data] TensorProto int64Data\n     * @property {string|null} [name] TensorProto name\n     * @property {string|null} [docString] TensorProto docString\n     * @property {Uint8Array|null} [rawData] TensorProto rawData\n     * @property {Array.<onnx.IStringStringEntryProto>|null} [externalData] TensorProto externalData\n     * @property {onnx.TensorProto.DataLocation|null} [dataLocation] TensorProto dataLocation\n     * @property {Array.<number>|null} [doubleData] TensorProto doubleData\n     * @property {Array.<number|Long>|null} [uint64Data] TensorProto uint64Data\n     */\n\n    /**\n     * Constructs a new TensorProto.\n     * @memberof onnx\n     * @classdesc Represents a TensorProto.\n     * @implements ITensorProto\n     * @constructor\n     * @param {onnx.ITensorProto=} [properties] Properties to set\n     */\n    function TensorProto(properties) {\n      this.dims = [];\n      this.floatData = [];\n      this.int32Data = [];\n      this.stringData = [];\n      this.int64Data = [];\n      this.externalData = [];\n      this.doubleData = [];\n      this.uint64Data = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TensorProto dims.\n     * @member {Array.<number|Long>} dims\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.dims = $util.emptyArray;\n\n    /**\n     * TensorProto dataType.\n     * @member {number} dataType\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.dataType = 0;\n\n    /**\n     * TensorProto segment.\n     * @member {onnx.TensorProto.ISegment|null|undefined} segment\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.segment = null;\n\n    /**\n     * TensorProto floatData.\n     * @member {Array.<number>} floatData\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.floatData = $util.emptyArray;\n\n    /**\n     * TensorProto int32Data.\n     * @member {Array.<number>} int32Data\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.int32Data = $util.emptyArray;\n\n    /**\n     * TensorProto stringData.\n     * @member {Array.<Uint8Array>} stringData\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.stringData = $util.emptyArray;\n\n    /**\n     * TensorProto int64Data.\n     * @member {Array.<number|Long>} int64Data\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.int64Data = $util.emptyArray;\n\n    /**\n     * TensorProto name.\n     * @member {string} name\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.name = '';\n\n    /**\n     * TensorProto docString.\n     * @member {string} docString\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.docString = '';\n\n    /**\n     * TensorProto rawData.\n     * @member {Uint8Array} rawData\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.rawData = $util.newBuffer([]);\n\n    /**\n     * TensorProto externalData.\n     * @member {Array.<onnx.IStringStringEntryProto>} externalData\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.externalData = $util.emptyArray;\n\n    /**\n     * TensorProto dataLocation.\n     * @member {onnx.TensorProto.DataLocation} dataLocation\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.dataLocation = 0;\n\n    /**\n     * TensorProto doubleData.\n     * @member {Array.<number>} doubleData\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.doubleData = $util.emptyArray;\n\n    /**\n     * TensorProto uint64Data.\n     * @member {Array.<number|Long>} uint64Data\n     * @memberof onnx.TensorProto\n     * @instance\n     */\n    TensorProto.prototype.uint64Data = $util.emptyArray;\n\n    /**\n     * Creates a new TensorProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {onnx.ITensorProto=} [properties] Properties to set\n     * @returns {onnx.TensorProto} TensorProto instance\n     */\n    TensorProto.create = function create(properties) {\n      return new TensorProto(properties);\n    };\n\n    /**\n     * Encodes the specified TensorProto message. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {onnx.ITensorProto} message TensorProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.dims != null && message.dims.length) {\n        writer.uint32(/* id 1, wireType 2 =*/ 10).fork();\n        for (var i = 0; i < message.dims.length; ++i) writer.int64(message.dims[i]);\n        writer.ldelim();\n      }\n      if (message.dataType != null && Object.hasOwnProperty.call(message, 'dataType'))\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.dataType);\n      if (message.segment != null && Object.hasOwnProperty.call(message, 'segment'))\n        $root.onnx.TensorProto.Segment.encode(\n          message.segment,\n          writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n        ).ldelim();\n      if (message.floatData != null && message.floatData.length) {\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork();\n        for (var i = 0; i < message.floatData.length; ++i) writer.float(message.floatData[i]);\n        writer.ldelim();\n      }\n      if (message.int32Data != null && message.int32Data.length) {\n        writer.uint32(/* id 5, wireType 2 =*/ 42).fork();\n        for (var i = 0; i < message.int32Data.length; ++i) writer.int32(message.int32Data[i]);\n        writer.ldelim();\n      }\n      if (message.stringData != null && message.stringData.length)\n        for (var i = 0; i < message.stringData.length; ++i)\n          writer.uint32(/* id 6, wireType 2 =*/ 50).bytes(message.stringData[i]);\n      if (message.int64Data != null && message.int64Data.length) {\n        writer.uint32(/* id 7, wireType 2 =*/ 58).fork();\n        for (var i = 0; i < message.int64Data.length; ++i) writer.int64(message.int64Data[i]);\n        writer.ldelim();\n      }\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.name);\n      if (message.rawData != null && Object.hasOwnProperty.call(message, 'rawData'))\n        writer.uint32(/* id 9, wireType 2 =*/ 74).bytes(message.rawData);\n      if (message.doubleData != null && message.doubleData.length) {\n        writer.uint32(/* id 10, wireType 2 =*/ 82).fork();\n        for (var i = 0; i < message.doubleData.length; ++i) writer.double(message.doubleData[i]);\n        writer.ldelim();\n      }\n      if (message.uint64Data != null && message.uint64Data.length) {\n        writer.uint32(/* id 11, wireType 2 =*/ 90).fork();\n        for (var i = 0; i < message.uint64Data.length; ++i) writer.uint64(message.uint64Data[i]);\n        writer.ldelim();\n      }\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.docString);\n      if (message.externalData != null && message.externalData.length)\n        for (var i = 0; i < message.externalData.length; ++i)\n          $root.onnx.StringStringEntryProto.encode(\n            message.externalData[i],\n            writer.uint32(/* id 13, wireType 2 =*/ 106).fork(),\n          ).ldelim();\n      if (message.dataLocation != null && Object.hasOwnProperty.call(message, 'dataLocation'))\n        writer.uint32(/* id 14, wireType 0 =*/ 112).int32(message.dataLocation);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified TensorProto message, length delimited. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {onnx.ITensorProto} message TensorProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TensorProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.TensorProto} TensorProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.TensorProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            if (!(message.dims && message.dims.length)) message.dims = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.dims.push(reader.int64());\n            } else message.dims.push(reader.int64());\n            break;\n          }\n          case 2: {\n            message.dataType = reader.int32();\n            break;\n          }\n          case 3: {\n            message.segment = $root.onnx.TensorProto.Segment.decode(reader, reader.uint32());\n            break;\n          }\n          case 4: {\n            if (!(message.floatData && message.floatData.length)) message.floatData = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.floatData.push(reader.float());\n            } else message.floatData.push(reader.float());\n            break;\n          }\n          case 5: {\n            if (!(message.int32Data && message.int32Data.length)) message.int32Data = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.int32Data.push(reader.int32());\n            } else message.int32Data.push(reader.int32());\n            break;\n          }\n          case 6: {\n            if (!(message.stringData && message.stringData.length)) message.stringData = [];\n            message.stringData.push(reader.bytes());\n            break;\n          }\n          case 7: {\n            if (!(message.int64Data && message.int64Data.length)) message.int64Data = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.int64Data.push(reader.int64());\n            } else message.int64Data.push(reader.int64());\n            break;\n          }\n          case 8: {\n            message.name = reader.string();\n            break;\n          }\n          case 12: {\n            message.docString = reader.string();\n            break;\n          }\n          case 9: {\n            message.rawData = reader.bytes();\n            break;\n          }\n          case 13: {\n            if (!(message.externalData && message.externalData.length)) message.externalData = [];\n            message.externalData.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 14: {\n            message.dataLocation = reader.int32();\n            break;\n          }\n          case 10: {\n            if (!(message.doubleData && message.doubleData.length)) message.doubleData = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.doubleData.push(reader.double());\n            } else message.doubleData.push(reader.double());\n            break;\n          }\n          case 11: {\n            if (!(message.uint64Data && message.uint64Data.length)) message.uint64Data = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.uint64Data.push(reader.uint64());\n            } else message.uint64Data.push(reader.uint64());\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a TensorProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.TensorProto} TensorProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TensorProto message.\n     * @function verify\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TensorProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.dims != null && message.hasOwnProperty('dims')) {\n        if (!Array.isArray(message.dims)) return 'dims: array expected';\n        for (var i = 0; i < message.dims.length; ++i)\n          if (\n            !$util.isInteger(message.dims[i]) &&\n            !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high))\n          )\n            return 'dims: integer|Long[] expected';\n      }\n      if (message.dataType != null && message.hasOwnProperty('dataType'))\n        if (!$util.isInteger(message.dataType)) return 'dataType: integer expected';\n      if (message.segment != null && message.hasOwnProperty('segment')) {\n        var error = $root.onnx.TensorProto.Segment.verify(message.segment);\n        if (error) return 'segment.' + error;\n      }\n      if (message.floatData != null && message.hasOwnProperty('floatData')) {\n        if (!Array.isArray(message.floatData)) return 'floatData: array expected';\n        for (var i = 0; i < message.floatData.length; ++i)\n          if (typeof message.floatData[i] !== 'number') return 'floatData: number[] expected';\n      }\n      if (message.int32Data != null && message.hasOwnProperty('int32Data')) {\n        if (!Array.isArray(message.int32Data)) return 'int32Data: array expected';\n        for (var i = 0; i < message.int32Data.length; ++i)\n          if (!$util.isInteger(message.int32Data[i])) return 'int32Data: integer[] expected';\n      }\n      if (message.stringData != null && message.hasOwnProperty('stringData')) {\n        if (!Array.isArray(message.stringData)) return 'stringData: array expected';\n        for (var i = 0; i < message.stringData.length; ++i)\n          if (\n            !(\n              (message.stringData[i] && typeof message.stringData[i].length === 'number') ||\n              $util.isString(message.stringData[i])\n            )\n          )\n            return 'stringData: buffer[] expected';\n      }\n      if (message.int64Data != null && message.hasOwnProperty('int64Data')) {\n        if (!Array.isArray(message.int64Data)) return 'int64Data: array expected';\n        for (var i = 0; i < message.int64Data.length; ++i)\n          if (\n            !$util.isInteger(message.int64Data[i]) &&\n            !(\n              message.int64Data[i] &&\n              $util.isInteger(message.int64Data[i].low) &&\n              $util.isInteger(message.int64Data[i].high)\n            )\n          )\n            return 'int64Data: integer|Long[] expected';\n      }\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      if (message.rawData != null && message.hasOwnProperty('rawData'))\n        if (!((message.rawData && typeof message.rawData.length === 'number') || $util.isString(message.rawData)))\n          return 'rawData: buffer expected';\n      if (message.externalData != null && message.hasOwnProperty('externalData')) {\n        if (!Array.isArray(message.externalData)) return 'externalData: array expected';\n        for (var i = 0; i < message.externalData.length; ++i) {\n          var error = $root.onnx.StringStringEntryProto.verify(message.externalData[i]);\n          if (error) return 'externalData.' + error;\n        }\n      }\n      if (message.dataLocation != null && message.hasOwnProperty('dataLocation'))\n        switch (message.dataLocation) {\n          default:\n            return 'dataLocation: enum value expected';\n          case 0:\n          case 1:\n            break;\n        }\n      if (message.doubleData != null && message.hasOwnProperty('doubleData')) {\n        if (!Array.isArray(message.doubleData)) return 'doubleData: array expected';\n        for (var i = 0; i < message.doubleData.length; ++i)\n          if (typeof message.doubleData[i] !== 'number') return 'doubleData: number[] expected';\n      }\n      if (message.uint64Data != null && message.hasOwnProperty('uint64Data')) {\n        if (!Array.isArray(message.uint64Data)) return 'uint64Data: array expected';\n        for (var i = 0; i < message.uint64Data.length; ++i)\n          if (\n            !$util.isInteger(message.uint64Data[i]) &&\n            !(\n              message.uint64Data[i] &&\n              $util.isInteger(message.uint64Data[i].low) &&\n              $util.isInteger(message.uint64Data[i].high)\n            )\n          )\n            return 'uint64Data: integer|Long[] expected';\n      }\n      return null;\n    };\n\n    /**\n     * Creates a TensorProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.TensorProto} TensorProto\n     */\n    TensorProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.TensorProto) return object;\n      var message = new $root.onnx.TensorProto();\n      if (object.dims) {\n        if (!Array.isArray(object.dims)) throw TypeError('.onnx.TensorProto.dims: array expected');\n        message.dims = [];\n        for (var i = 0; i < object.dims.length; ++i)\n          if ($util.Long) (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;\n          else if (typeof object.dims[i] === 'string') message.dims[i] = parseInt(object.dims[i], 10);\n          else if (typeof object.dims[i] === 'number') message.dims[i] = object.dims[i];\n          else if (typeof object.dims[i] === 'object')\n            message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();\n      }\n      if (object.dataType != null) message.dataType = object.dataType | 0;\n      if (object.segment != null) {\n        if (typeof object.segment !== 'object') throw TypeError('.onnx.TensorProto.segment: object expected');\n        message.segment = $root.onnx.TensorProto.Segment.fromObject(object.segment);\n      }\n      if (object.floatData) {\n        if (!Array.isArray(object.floatData)) throw TypeError('.onnx.TensorProto.floatData: array expected');\n        message.floatData = [];\n        for (var i = 0; i < object.floatData.length; ++i) message.floatData[i] = Number(object.floatData[i]);\n      }\n      if (object.int32Data) {\n        if (!Array.isArray(object.int32Data)) throw TypeError('.onnx.TensorProto.int32Data: array expected');\n        message.int32Data = [];\n        for (var i = 0; i < object.int32Data.length; ++i) message.int32Data[i] = object.int32Data[i] | 0;\n      }\n      if (object.stringData) {\n        if (!Array.isArray(object.stringData)) throw TypeError('.onnx.TensorProto.stringData: array expected');\n        message.stringData = [];\n        for (var i = 0; i < object.stringData.length; ++i)\n          if (typeof object.stringData[i] === 'string')\n            $util.base64.decode(\n              object.stringData[i],\n              (message.stringData[i] = $util.newBuffer($util.base64.length(object.stringData[i]))),\n              0,\n            );\n          else if (object.stringData[i].length >= 0) message.stringData[i] = object.stringData[i];\n      }\n      if (object.int64Data) {\n        if (!Array.isArray(object.int64Data)) throw TypeError('.onnx.TensorProto.int64Data: array expected');\n        message.int64Data = [];\n        for (var i = 0; i < object.int64Data.length; ++i)\n          if ($util.Long) (message.int64Data[i] = $util.Long.fromValue(object.int64Data[i])).unsigned = false;\n          else if (typeof object.int64Data[i] === 'string') message.int64Data[i] = parseInt(object.int64Data[i], 10);\n          else if (typeof object.int64Data[i] === 'number') message.int64Data[i] = object.int64Data[i];\n          else if (typeof object.int64Data[i] === 'object')\n            message.int64Data[i] = new $util.LongBits(\n              object.int64Data[i].low >>> 0,\n              object.int64Data[i].high >>> 0,\n            ).toNumber();\n      }\n      if (object.name != null) message.name = String(object.name);\n      if (object.docString != null) message.docString = String(object.docString);\n      if (object.rawData != null)\n        if (typeof object.rawData === 'string')\n          $util.base64.decode(\n            object.rawData,\n            (message.rawData = $util.newBuffer($util.base64.length(object.rawData))),\n            0,\n          );\n        else if (object.rawData.length >= 0) message.rawData = object.rawData;\n      if (object.externalData) {\n        if (!Array.isArray(object.externalData)) throw TypeError('.onnx.TensorProto.externalData: array expected');\n        message.externalData = [];\n        for (var i = 0; i < object.externalData.length; ++i) {\n          if (typeof object.externalData[i] !== 'object')\n            throw TypeError('.onnx.TensorProto.externalData: object expected');\n          message.externalData[i] = $root.onnx.StringStringEntryProto.fromObject(object.externalData[i]);\n        }\n      }\n      switch (object.dataLocation) {\n        default:\n          if (typeof object.dataLocation === 'number') {\n            message.dataLocation = object.dataLocation;\n            break;\n          }\n          break;\n        case 'DEFAULT':\n        case 0:\n          message.dataLocation = 0;\n          break;\n        case 'EXTERNAL':\n        case 1:\n          message.dataLocation = 1;\n          break;\n      }\n      if (object.doubleData) {\n        if (!Array.isArray(object.doubleData)) throw TypeError('.onnx.TensorProto.doubleData: array expected');\n        message.doubleData = [];\n        for (var i = 0; i < object.doubleData.length; ++i) message.doubleData[i] = Number(object.doubleData[i]);\n      }\n      if (object.uint64Data) {\n        if (!Array.isArray(object.uint64Data)) throw TypeError('.onnx.TensorProto.uint64Data: array expected');\n        message.uint64Data = [];\n        for (var i = 0; i < object.uint64Data.length; ++i)\n          if ($util.Long) (message.uint64Data[i] = $util.Long.fromValue(object.uint64Data[i])).unsigned = true;\n          else if (typeof object.uint64Data[i] === 'string') message.uint64Data[i] = parseInt(object.uint64Data[i], 10);\n          else if (typeof object.uint64Data[i] === 'number') message.uint64Data[i] = object.uint64Data[i];\n          else if (typeof object.uint64Data[i] === 'object')\n            message.uint64Data[i] = new $util.LongBits(\n              object.uint64Data[i].low >>> 0,\n              object.uint64Data[i].high >>> 0,\n            ).toNumber(true);\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a TensorProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {onnx.TensorProto} message TensorProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TensorProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.dims = [];\n        object.floatData = [];\n        object.int32Data = [];\n        object.stringData = [];\n        object.int64Data = [];\n        object.doubleData = [];\n        object.uint64Data = [];\n        object.externalData = [];\n      }\n      if (options.defaults) {\n        object.dataType = 0;\n        object.segment = null;\n        object.name = '';\n        if (options.bytes === String) object.rawData = '';\n        else {\n          object.rawData = [];\n          if (options.bytes !== Array) object.rawData = $util.newBuffer(object.rawData);\n        }\n        object.docString = '';\n        object.dataLocation = options.enums === String ? 'DEFAULT' : 0;\n      }\n      if (message.dims && message.dims.length) {\n        object.dims = [];\n        for (var j = 0; j < message.dims.length; ++j)\n          if (typeof message.dims[j] === 'number')\n            object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];\n          else\n            object.dims[j] =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.dims[j])\n                : options.longs === Number\n                  ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber()\n                  : message.dims[j];\n      }\n      if (message.dataType != null && message.hasOwnProperty('dataType')) object.dataType = message.dataType;\n      if (message.segment != null && message.hasOwnProperty('segment'))\n        object.segment = $root.onnx.TensorProto.Segment.toObject(message.segment, options);\n      if (message.floatData && message.floatData.length) {\n        object.floatData = [];\n        for (var j = 0; j < message.floatData.length; ++j)\n          object.floatData[j] =\n            options.json && !isFinite(message.floatData[j]) ? String(message.floatData[j]) : message.floatData[j];\n      }\n      if (message.int32Data && message.int32Data.length) {\n        object.int32Data = [];\n        for (var j = 0; j < message.int32Data.length; ++j) object.int32Data[j] = message.int32Data[j];\n      }\n      if (message.stringData && message.stringData.length) {\n        object.stringData = [];\n        for (var j = 0; j < message.stringData.length; ++j)\n          object.stringData[j] =\n            options.bytes === String\n              ? $util.base64.encode(message.stringData[j], 0, message.stringData[j].length)\n              : options.bytes === Array\n                ? Array.prototype.slice.call(message.stringData[j])\n                : message.stringData[j];\n      }\n      if (message.int64Data && message.int64Data.length) {\n        object.int64Data = [];\n        for (var j = 0; j < message.int64Data.length; ++j)\n          if (typeof message.int64Data[j] === 'number')\n            object.int64Data[j] = options.longs === String ? String(message.int64Data[j]) : message.int64Data[j];\n          else\n            object.int64Data[j] =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.int64Data[j])\n                : options.longs === Number\n                  ? new $util.LongBits(message.int64Data[j].low >>> 0, message.int64Data[j].high >>> 0).toNumber()\n                  : message.int64Data[j];\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.rawData != null && message.hasOwnProperty('rawData'))\n        object.rawData =\n          options.bytes === String\n            ? $util.base64.encode(message.rawData, 0, message.rawData.length)\n            : options.bytes === Array\n              ? Array.prototype.slice.call(message.rawData)\n              : message.rawData;\n      if (message.doubleData && message.doubleData.length) {\n        object.doubleData = [];\n        for (var j = 0; j < message.doubleData.length; ++j)\n          object.doubleData[j] =\n            options.json && !isFinite(message.doubleData[j]) ? String(message.doubleData[j]) : message.doubleData[j];\n      }\n      if (message.uint64Data && message.uint64Data.length) {\n        object.uint64Data = [];\n        for (var j = 0; j < message.uint64Data.length; ++j)\n          if (typeof message.uint64Data[j] === 'number')\n            object.uint64Data[j] = options.longs === String ? String(message.uint64Data[j]) : message.uint64Data[j];\n          else\n            object.uint64Data[j] =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.uint64Data[j])\n                : options.longs === Number\n                  ? new $util.LongBits(message.uint64Data[j].low >>> 0, message.uint64Data[j].high >>> 0).toNumber(true)\n                  : message.uint64Data[j];\n      }\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.externalData && message.externalData.length) {\n        object.externalData = [];\n        for (var j = 0; j < message.externalData.length; ++j)\n          object.externalData[j] = $root.onnx.StringStringEntryProto.toObject(message.externalData[j], options);\n      }\n      if (message.dataLocation != null && message.hasOwnProperty('dataLocation'))\n        object.dataLocation =\n          options.enums === String\n            ? $root.onnx.TensorProto.DataLocation[message.dataLocation] === undefined\n              ? message.dataLocation\n              : $root.onnx.TensorProto.DataLocation[message.dataLocation]\n            : message.dataLocation;\n      return object;\n    };\n\n    /**\n     * Converts this TensorProto to JSON.\n     * @function toJSON\n     * @memberof onnx.TensorProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TensorProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TensorProto\n     * @function getTypeUrl\n     * @memberof onnx.TensorProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.TensorProto';\n    };\n\n    /**\n     * DataType enum.\n     * @name onnx.TensorProto.DataType\n     * @enum {number}\n     * @property {number} UNDEFINED=0 UNDEFINED value\n     * @property {number} FLOAT=1 FLOAT value\n     * @property {number} UINT8=2 UINT8 value\n     * @property {number} INT8=3 INT8 value\n     * @property {number} UINT16=4 UINT16 value\n     * @property {number} INT16=5 INT16 value\n     * @property {number} INT32=6 INT32 value\n     * @property {number} INT64=7 INT64 value\n     * @property {number} STRING=8 STRING value\n     * @property {number} BOOL=9 BOOL value\n     * @property {number} FLOAT16=10 FLOAT16 value\n     * @property {number} DOUBLE=11 DOUBLE value\n     * @property {number} UINT32=12 UINT32 value\n     * @property {number} UINT64=13 UINT64 value\n     * @property {number} COMPLEX64=14 COMPLEX64 value\n     * @property {number} COMPLEX128=15 COMPLEX128 value\n     * @property {number} BFLOAT16=16 BFLOAT16 value\n     * @property {number} FLOAT8E4M3FN=17 FLOAT8E4M3FN value\n     * @property {number} FLOAT8E4M3FNUZ=18 FLOAT8E4M3FNUZ value\n     * @property {number} FLOAT8E5M2=19 FLOAT8E5M2 value\n     * @property {number} FLOAT8E5M2FNUZ=20 FLOAT8E5M2FNUZ value\n     */\n    TensorProto.DataType = (function () {\n      var valuesById = {},\n        values = Object.create(valuesById);\n      values[(valuesById[0] = 'UNDEFINED')] = 0;\n      values[(valuesById[1] = 'FLOAT')] = 1;\n      values[(valuesById[2] = 'UINT8')] = 2;\n      values[(valuesById[3] = 'INT8')] = 3;\n      values[(valuesById[4] = 'UINT16')] = 4;\n      values[(valuesById[5] = 'INT16')] = 5;\n      values[(valuesById[6] = 'INT32')] = 6;\n      values[(valuesById[7] = 'INT64')] = 7;\n      values[(valuesById[8] = 'STRING')] = 8;\n      values[(valuesById[9] = 'BOOL')] = 9;\n      values[(valuesById[10] = 'FLOAT16')] = 10;\n      values[(valuesById[11] = 'DOUBLE')] = 11;\n      values[(valuesById[12] = 'UINT32')] = 12;\n      values[(valuesById[13] = 'UINT64')] = 13;\n      values[(valuesById[14] = 'COMPLEX64')] = 14;\n      values[(valuesById[15] = 'COMPLEX128')] = 15;\n      values[(valuesById[16] = 'BFLOAT16')] = 16;\n      values[(valuesById[17] = 'FLOAT8E4M3FN')] = 17;\n      values[(valuesById[18] = 'FLOAT8E4M3FNUZ')] = 18;\n      values[(valuesById[19] = 'FLOAT8E5M2')] = 19;\n      values[(valuesById[20] = 'FLOAT8E5M2FNUZ')] = 20;\n      return values;\n    })();\n\n    TensorProto.Segment = (function () {\n      /**\n       * Properties of a Segment.\n       * @memberof onnx.TensorProto\n       * @interface ISegment\n       * @property {number|Long|null} [begin] Segment begin\n       * @property {number|Long|null} [end] Segment end\n       */\n\n      /**\n       * Constructs a new Segment.\n       * @memberof onnx.TensorProto\n       * @classdesc Represents a Segment.\n       * @implements ISegment\n       * @constructor\n       * @param {onnx.TensorProto.ISegment=} [properties] Properties to set\n       */\n      function Segment(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Segment begin.\n       * @member {number|Long} begin\n       * @memberof onnx.TensorProto.Segment\n       * @instance\n       */\n      Segment.prototype.begin = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n      /**\n       * Segment end.\n       * @member {number|Long} end\n       * @memberof onnx.TensorProto.Segment\n       * @instance\n       */\n      Segment.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n      /**\n       * Creates a new Segment instance using the specified properties.\n       * @function create\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {onnx.TensorProto.ISegment=} [properties] Properties to set\n       * @returns {onnx.TensorProto.Segment} Segment instance\n       */\n      Segment.create = function create(properties) {\n        return new Segment(properties);\n      };\n\n      /**\n       * Encodes the specified Segment message. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Segment.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.begin != null && Object.hasOwnProperty.call(message, 'begin'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.begin);\n        if (message.end != null && Object.hasOwnProperty.call(message, 'end'))\n          writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.end);\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Segment message, length delimited. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Segment.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a Segment message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TensorProto.Segment} Segment\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Segment.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TensorProto.Segment();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.begin = reader.int64();\n              break;\n            }\n            case 2: {\n              message.end = reader.int64();\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a Segment message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TensorProto.Segment} Segment\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Segment.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a Segment message.\n       * @function verify\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Segment.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.begin != null && message.hasOwnProperty('begin'))\n          if (\n            !$util.isInteger(message.begin) &&\n            !(message.begin && $util.isInteger(message.begin.low) && $util.isInteger(message.begin.high))\n          )\n            return 'begin: integer|Long expected';\n        if (message.end != null && message.hasOwnProperty('end'))\n          if (\n            !$util.isInteger(message.end) &&\n            !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high))\n          )\n            return 'end: integer|Long expected';\n        return null;\n      };\n\n      /**\n       * Creates a Segment message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TensorProto.Segment} Segment\n       */\n      Segment.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TensorProto.Segment) return object;\n        var message = new $root.onnx.TensorProto.Segment();\n        if (object.begin != null)\n          if ($util.Long) (message.begin = $util.Long.fromValue(object.begin)).unsigned = false;\n          else if (typeof object.begin === 'string') message.begin = parseInt(object.begin, 10);\n          else if (typeof object.begin === 'number') message.begin = object.begin;\n          else if (typeof object.begin === 'object')\n            message.begin = new $util.LongBits(object.begin.low >>> 0, object.begin.high >>> 0).toNumber();\n        if (object.end != null)\n          if ($util.Long) (message.end = $util.Long.fromValue(object.end)).unsigned = false;\n          else if (typeof object.end === 'string') message.end = parseInt(object.end, 10);\n          else if (typeof object.end === 'number') message.end = object.end;\n          else if (typeof object.end === 'object')\n            message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a Segment message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {onnx.TensorProto.Segment} message Segment\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Segment.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false);\n            object.begin =\n              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n          } else object.begin = options.longs === String ? '0' : 0;\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false);\n            object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n          } else object.end = options.longs === String ? '0' : 0;\n        }\n        if (message.begin != null && message.hasOwnProperty('begin'))\n          if (typeof message.begin === 'number')\n            object.begin = options.longs === String ? String(message.begin) : message.begin;\n          else\n            object.begin =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.begin)\n                : options.longs === Number\n                  ? new $util.LongBits(message.begin.low >>> 0, message.begin.high >>> 0).toNumber()\n                  : message.begin;\n        if (message.end != null && message.hasOwnProperty('end'))\n          if (typeof message.end === 'number')\n            object.end = options.longs === String ? String(message.end) : message.end;\n          else\n            object.end =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.end)\n                : options.longs === Number\n                  ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber()\n                  : message.end;\n        return object;\n      };\n\n      /**\n       * Converts this Segment to JSON.\n       * @function toJSON\n       * @memberof onnx.TensorProto.Segment\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Segment.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Segment\n       * @function getTypeUrl\n       * @memberof onnx.TensorProto.Segment\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Segment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TensorProto.Segment';\n      };\n\n      return Segment;\n    })();\n\n    /**\n     * DataLocation enum.\n     * @name onnx.TensorProto.DataLocation\n     * @enum {number}\n     * @property {number} DEFAULT=0 DEFAULT value\n     * @property {number} EXTERNAL=1 EXTERNAL value\n     */\n    TensorProto.DataLocation = (function () {\n      var valuesById = {},\n        values = Object.create(valuesById);\n      values[(valuesById[0] = 'DEFAULT')] = 0;\n      values[(valuesById[1] = 'EXTERNAL')] = 1;\n      return values;\n    })();\n\n    return TensorProto;\n  })();\n\n  onnx.SparseTensorProto = (function () {\n    /**\n     * Properties of a SparseTensorProto.\n     * @memberof onnx\n     * @interface ISparseTensorProto\n     * @property {onnx.ITensorProto|null} [values] SparseTensorProto values\n     * @property {onnx.ITensorProto|null} [indices] SparseTensorProto indices\n     * @property {Array.<number|Long>|null} [dims] SparseTensorProto dims\n     */\n\n    /**\n     * Constructs a new SparseTensorProto.\n     * @memberof onnx\n     * @classdesc Represents a SparseTensorProto.\n     * @implements ISparseTensorProto\n     * @constructor\n     * @param {onnx.ISparseTensorProto=} [properties] Properties to set\n     */\n    function SparseTensorProto(properties) {\n      this.dims = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SparseTensorProto values.\n     * @member {onnx.ITensorProto|null|undefined} values\n     * @memberof onnx.SparseTensorProto\n     * @instance\n     */\n    SparseTensorProto.prototype.values = null;\n\n    /**\n     * SparseTensorProto indices.\n     * @member {onnx.ITensorProto|null|undefined} indices\n     * @memberof onnx.SparseTensorProto\n     * @instance\n     */\n    SparseTensorProto.prototype.indices = null;\n\n    /**\n     * SparseTensorProto dims.\n     * @member {Array.<number|Long>} dims\n     * @memberof onnx.SparseTensorProto\n     * @instance\n     */\n    SparseTensorProto.prototype.dims = $util.emptyArray;\n\n    /**\n     * Creates a new SparseTensorProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {onnx.ISparseTensorProto=} [properties] Properties to set\n     * @returns {onnx.SparseTensorProto} SparseTensorProto instance\n     */\n    SparseTensorProto.create = function create(properties) {\n      return new SparseTensorProto(properties);\n    };\n\n    /**\n     * Encodes the specified SparseTensorProto message. Does not implicitly {@link onnx.SparseTensorProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {onnx.ISparseTensorProto} message SparseTensorProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SparseTensorProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.values != null && Object.hasOwnProperty.call(message, 'values'))\n        $root.onnx.TensorProto.encode(message.values, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n      if (message.indices != null && Object.hasOwnProperty.call(message, 'indices'))\n        $root.onnx.TensorProto.encode(message.indices, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n      if (message.dims != null && message.dims.length) {\n        writer.uint32(/* id 3, wireType 2 =*/ 26).fork();\n        for (var i = 0; i < message.dims.length; ++i) writer.int64(message.dims[i]);\n        writer.ldelim();\n      }\n      return writer;\n    };\n\n    /**\n     * Encodes the specified SparseTensorProto message, length delimited. Does not implicitly {@link onnx.SparseTensorProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {onnx.ISparseTensorProto} message SparseTensorProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SparseTensorProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SparseTensorProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.SparseTensorProto} SparseTensorProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SparseTensorProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.SparseTensorProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.values = $root.onnx.TensorProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 2: {\n            message.indices = $root.onnx.TensorProto.decode(reader, reader.uint32());\n            break;\n          }\n          case 3: {\n            if (!(message.dims && message.dims.length)) message.dims = [];\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n              while (reader.pos < end2) message.dims.push(reader.int64());\n            } else message.dims.push(reader.int64());\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a SparseTensorProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.SparseTensorProto} SparseTensorProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SparseTensorProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SparseTensorProto message.\n     * @function verify\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SparseTensorProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.values != null && message.hasOwnProperty('values')) {\n        var error = $root.onnx.TensorProto.verify(message.values);\n        if (error) return 'values.' + error;\n      }\n      if (message.indices != null && message.hasOwnProperty('indices')) {\n        var error = $root.onnx.TensorProto.verify(message.indices);\n        if (error) return 'indices.' + error;\n      }\n      if (message.dims != null && message.hasOwnProperty('dims')) {\n        if (!Array.isArray(message.dims)) return 'dims: array expected';\n        for (var i = 0; i < message.dims.length; ++i)\n          if (\n            !$util.isInteger(message.dims[i]) &&\n            !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high))\n          )\n            return 'dims: integer|Long[] expected';\n      }\n      return null;\n    };\n\n    /**\n     * Creates a SparseTensorProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.SparseTensorProto} SparseTensorProto\n     */\n    SparseTensorProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.SparseTensorProto) return object;\n      var message = new $root.onnx.SparseTensorProto();\n      if (object.values != null) {\n        if (typeof object.values !== 'object') throw TypeError('.onnx.SparseTensorProto.values: object expected');\n        message.values = $root.onnx.TensorProto.fromObject(object.values);\n      }\n      if (object.indices != null) {\n        if (typeof object.indices !== 'object') throw TypeError('.onnx.SparseTensorProto.indices: object expected');\n        message.indices = $root.onnx.TensorProto.fromObject(object.indices);\n      }\n      if (object.dims) {\n        if (!Array.isArray(object.dims)) throw TypeError('.onnx.SparseTensorProto.dims: array expected');\n        message.dims = [];\n        for (var i = 0; i < object.dims.length; ++i)\n          if ($util.Long) (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;\n          else if (typeof object.dims[i] === 'string') message.dims[i] = parseInt(object.dims[i], 10);\n          else if (typeof object.dims[i] === 'number') message.dims[i] = object.dims[i];\n          else if (typeof object.dims[i] === 'object')\n            message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a SparseTensorProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {onnx.SparseTensorProto} message SparseTensorProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SparseTensorProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.dims = [];\n      if (options.defaults) {\n        object.values = null;\n        object.indices = null;\n      }\n      if (message.values != null && message.hasOwnProperty('values'))\n        object.values = $root.onnx.TensorProto.toObject(message.values, options);\n      if (message.indices != null && message.hasOwnProperty('indices'))\n        object.indices = $root.onnx.TensorProto.toObject(message.indices, options);\n      if (message.dims && message.dims.length) {\n        object.dims = [];\n        for (var j = 0; j < message.dims.length; ++j)\n          if (typeof message.dims[j] === 'number')\n            object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];\n          else\n            object.dims[j] =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.dims[j])\n                : options.longs === Number\n                  ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber()\n                  : message.dims[j];\n      }\n      return object;\n    };\n\n    /**\n     * Converts this SparseTensorProto to JSON.\n     * @function toJSON\n     * @memberof onnx.SparseTensorProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SparseTensorProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for SparseTensorProto\n     * @function getTypeUrl\n     * @memberof onnx.SparseTensorProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    SparseTensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.SparseTensorProto';\n    };\n\n    return SparseTensorProto;\n  })();\n\n  onnx.TensorShapeProto = (function () {\n    /**\n     * Properties of a TensorShapeProto.\n     * @memberof onnx\n     * @interface ITensorShapeProto\n     * @property {Array.<onnx.TensorShapeProto.IDimension>|null} [dim] TensorShapeProto dim\n     */\n\n    /**\n     * Constructs a new TensorShapeProto.\n     * @memberof onnx\n     * @classdesc Represents a TensorShapeProto.\n     * @implements ITensorShapeProto\n     * @constructor\n     * @param {onnx.ITensorShapeProto=} [properties] Properties to set\n     */\n    function TensorShapeProto(properties) {\n      this.dim = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TensorShapeProto dim.\n     * @member {Array.<onnx.TensorShapeProto.IDimension>} dim\n     * @memberof onnx.TensorShapeProto\n     * @instance\n     */\n    TensorShapeProto.prototype.dim = $util.emptyArray;\n\n    /**\n     * Creates a new TensorShapeProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {onnx.ITensorShapeProto=} [properties] Properties to set\n     * @returns {onnx.TensorShapeProto} TensorShapeProto instance\n     */\n    TensorShapeProto.create = function create(properties) {\n      return new TensorShapeProto(properties);\n    };\n\n    /**\n     * Encodes the specified TensorShapeProto message. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorShapeProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.dim != null && message.dim.length)\n        for (var i = 0; i < message.dim.length; ++i)\n          $root.onnx.TensorShapeProto.Dimension.encode(\n            message.dim[i],\n            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified TensorShapeProto message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TensorShapeProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TensorShapeProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.TensorShapeProto} TensorShapeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorShapeProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.TensorShapeProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            if (!(message.dim && message.dim.length)) message.dim = [];\n            message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader, reader.uint32()));\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a TensorShapeProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.TensorShapeProto} TensorShapeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TensorShapeProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TensorShapeProto message.\n     * @function verify\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TensorShapeProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.dim != null && message.hasOwnProperty('dim')) {\n        if (!Array.isArray(message.dim)) return 'dim: array expected';\n        for (var i = 0; i < message.dim.length; ++i) {\n          var error = $root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);\n          if (error) return 'dim.' + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a TensorShapeProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.TensorShapeProto} TensorShapeProto\n     */\n    TensorShapeProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.TensorShapeProto) return object;\n      var message = new $root.onnx.TensorShapeProto();\n      if (object.dim) {\n        if (!Array.isArray(object.dim)) throw TypeError('.onnx.TensorShapeProto.dim: array expected');\n        message.dim = [];\n        for (var i = 0; i < object.dim.length; ++i) {\n          if (typeof object.dim[i] !== 'object') throw TypeError('.onnx.TensorShapeProto.dim: object expected');\n          message.dim[i] = $root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a TensorShapeProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {onnx.TensorShapeProto} message TensorShapeProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TensorShapeProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.dim = [];\n      if (message.dim && message.dim.length) {\n        object.dim = [];\n        for (var j = 0; j < message.dim.length; ++j)\n          object.dim[j] = $root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this TensorShapeProto to JSON.\n     * @function toJSON\n     * @memberof onnx.TensorShapeProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TensorShapeProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TensorShapeProto\n     * @function getTypeUrl\n     * @memberof onnx.TensorShapeProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TensorShapeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.TensorShapeProto';\n    };\n\n    TensorShapeProto.Dimension = (function () {\n      /**\n       * Properties of a Dimension.\n       * @memberof onnx.TensorShapeProto\n       * @interface IDimension\n       * @property {number|Long|null} [dimValue] Dimension dimValue\n       * @property {string|null} [dimParam] Dimension dimParam\n       * @property {string|null} [denotation] Dimension denotation\n       */\n\n      /**\n       * Constructs a new Dimension.\n       * @memberof onnx.TensorShapeProto\n       * @classdesc Represents a Dimension.\n       * @implements IDimension\n       * @constructor\n       * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set\n       */\n      function Dimension(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Dimension dimValue.\n       * @member {number|Long|null|undefined} dimValue\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @instance\n       */\n      Dimension.prototype.dimValue = null;\n\n      /**\n       * Dimension dimParam.\n       * @member {string|null|undefined} dimParam\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @instance\n       */\n      Dimension.prototype.dimParam = null;\n\n      /**\n       * Dimension denotation.\n       * @member {string} denotation\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @instance\n       */\n      Dimension.prototype.denotation = '';\n\n      // OneOf field names bound to virtual getters and setters\n      var $oneOfFields;\n\n      /**\n       * Dimension value.\n       * @member {\"dimValue\"|\"dimParam\"|undefined} value\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @instance\n       */\n      Object.defineProperty(Dimension.prototype, 'value', {\n        get: $util.oneOfGetter(($oneOfFields = ['dimValue', 'dimParam'])),\n        set: $util.oneOfSetter($oneOfFields),\n      });\n\n      /**\n       * Creates a new Dimension instance using the specified properties.\n       * @function create\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set\n       * @returns {onnx.TensorShapeProto.Dimension} Dimension instance\n       */\n      Dimension.create = function create(properties) {\n        return new Dimension(properties);\n      };\n\n      /**\n       * Encodes the specified Dimension message. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Dimension.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.dimValue != null && Object.hasOwnProperty.call(message, 'dimValue'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.dimValue);\n        if (message.dimParam != null && Object.hasOwnProperty.call(message, 'dimParam'))\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.dimParam);\n        if (message.denotation != null && Object.hasOwnProperty.call(message, 'denotation'))\n          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.denotation);\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Dimension message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Dimension.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a Dimension message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TensorShapeProto.Dimension} Dimension\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Dimension.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TensorShapeProto.Dimension();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.dimValue = reader.int64();\n              break;\n            }\n            case 2: {\n              message.dimParam = reader.string();\n              break;\n            }\n            case 3: {\n              message.denotation = reader.string();\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a Dimension message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TensorShapeProto.Dimension} Dimension\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Dimension.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a Dimension message.\n       * @function verify\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Dimension.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        var properties = {};\n        if (message.dimValue != null && message.hasOwnProperty('dimValue')) {\n          properties.value = 1;\n          if (\n            !$util.isInteger(message.dimValue) &&\n            !(message.dimValue && $util.isInteger(message.dimValue.low) && $util.isInteger(message.dimValue.high))\n          )\n            return 'dimValue: integer|Long expected';\n        }\n        if (message.dimParam != null && message.hasOwnProperty('dimParam')) {\n          if (properties.value === 1) return 'value: multiple values';\n          properties.value = 1;\n          if (!$util.isString(message.dimParam)) return 'dimParam: string expected';\n        }\n        if (message.denotation != null && message.hasOwnProperty('denotation'))\n          if (!$util.isString(message.denotation)) return 'denotation: string expected';\n        return null;\n      };\n\n      /**\n       * Creates a Dimension message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TensorShapeProto.Dimension} Dimension\n       */\n      Dimension.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TensorShapeProto.Dimension) return object;\n        var message = new $root.onnx.TensorShapeProto.Dimension();\n        if (object.dimValue != null)\n          if ($util.Long) (message.dimValue = $util.Long.fromValue(object.dimValue)).unsigned = false;\n          else if (typeof object.dimValue === 'string') message.dimValue = parseInt(object.dimValue, 10);\n          else if (typeof object.dimValue === 'number') message.dimValue = object.dimValue;\n          else if (typeof object.dimValue === 'object')\n            message.dimValue = new $util.LongBits(object.dimValue.low >>> 0, object.dimValue.high >>> 0).toNumber();\n        if (object.dimParam != null) message.dimParam = String(object.dimParam);\n        if (object.denotation != null) message.denotation = String(object.denotation);\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a Dimension message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {onnx.TensorShapeProto.Dimension} message Dimension\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Dimension.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.denotation = '';\n        if (message.dimValue != null && message.hasOwnProperty('dimValue')) {\n          if (typeof message.dimValue === 'number')\n            object.dimValue = options.longs === String ? String(message.dimValue) : message.dimValue;\n          else\n            object.dimValue =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.dimValue)\n                : options.longs === Number\n                  ? new $util.LongBits(message.dimValue.low >>> 0, message.dimValue.high >>> 0).toNumber()\n                  : message.dimValue;\n          if (options.oneofs) object.value = 'dimValue';\n        }\n        if (message.dimParam != null && message.hasOwnProperty('dimParam')) {\n          object.dimParam = message.dimParam;\n          if (options.oneofs) object.value = 'dimParam';\n        }\n        if (message.denotation != null && message.hasOwnProperty('denotation')) object.denotation = message.denotation;\n        return object;\n      };\n\n      /**\n       * Converts this Dimension to JSON.\n       * @function toJSON\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Dimension.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Dimension\n       * @function getTypeUrl\n       * @memberof onnx.TensorShapeProto.Dimension\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Dimension.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TensorShapeProto.Dimension';\n      };\n\n      return Dimension;\n    })();\n\n    return TensorShapeProto;\n  })();\n\n  onnx.TypeProto = (function () {\n    /**\n     * Properties of a TypeProto.\n     * @memberof onnx\n     * @interface ITypeProto\n     * @property {onnx.TypeProto.ITensor|null} [tensorType] TypeProto tensorType\n     * @property {onnx.TypeProto.ISequence|null} [sequenceType] TypeProto sequenceType\n     * @property {onnx.TypeProto.IMap|null} [mapType] TypeProto mapType\n     * @property {onnx.TypeProto.IOptional|null} [optionalType] TypeProto optionalType\n     * @property {onnx.TypeProto.ISparseTensor|null} [sparseTensorType] TypeProto sparseTensorType\n     * @property {string|null} [denotation] TypeProto denotation\n     */\n\n    /**\n     * Constructs a new TypeProto.\n     * @memberof onnx\n     * @classdesc Represents a TypeProto.\n     * @implements ITypeProto\n     * @constructor\n     * @param {onnx.ITypeProto=} [properties] Properties to set\n     */\n    function TypeProto(properties) {\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TypeProto tensorType.\n     * @member {onnx.TypeProto.ITensor|null|undefined} tensorType\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.tensorType = null;\n\n    /**\n     * TypeProto sequenceType.\n     * @member {onnx.TypeProto.ISequence|null|undefined} sequenceType\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.sequenceType = null;\n\n    /**\n     * TypeProto mapType.\n     * @member {onnx.TypeProto.IMap|null|undefined} mapType\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.mapType = null;\n\n    /**\n     * TypeProto optionalType.\n     * @member {onnx.TypeProto.IOptional|null|undefined} optionalType\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.optionalType = null;\n\n    /**\n     * TypeProto sparseTensorType.\n     * @member {onnx.TypeProto.ISparseTensor|null|undefined} sparseTensorType\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.sparseTensorType = null;\n\n    /**\n     * TypeProto denotation.\n     * @member {string} denotation\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    TypeProto.prototype.denotation = '';\n\n    // OneOf field names bound to virtual getters and setters\n    var $oneOfFields;\n\n    /**\n     * TypeProto value.\n     * @member {\"tensorType\"|\"sequenceType\"|\"mapType\"|\"optionalType\"|\"sparseTensorType\"|undefined} value\n     * @memberof onnx.TypeProto\n     * @instance\n     */\n    Object.defineProperty(TypeProto.prototype, 'value', {\n      get: $util.oneOfGetter(\n        ($oneOfFields = ['tensorType', 'sequenceType', 'mapType', 'optionalType', 'sparseTensorType']),\n      ),\n      set: $util.oneOfSetter($oneOfFields),\n    });\n\n    /**\n     * Creates a new TypeProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {onnx.ITypeProto=} [properties] Properties to set\n     * @returns {onnx.TypeProto} TypeProto instance\n     */\n    TypeProto.create = function create(properties) {\n      return new TypeProto(properties);\n    };\n\n    /**\n     * Encodes the specified TypeProto message. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {onnx.ITypeProto} message TypeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TypeProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.tensorType != null && Object.hasOwnProperty.call(message, 'tensorType'))\n        $root.onnx.TypeProto.Tensor.encode(\n          message.tensorType,\n          writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n        ).ldelim();\n      if (message.sequenceType != null && Object.hasOwnProperty.call(message, 'sequenceType'))\n        $root.onnx.TypeProto.Sequence.encode(\n          message.sequenceType,\n          writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n        ).ldelim();\n      if (message.mapType != null && Object.hasOwnProperty.call(message, 'mapType'))\n        $root.onnx.TypeProto.Map.encode(message.mapType, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();\n      if (message.denotation != null && Object.hasOwnProperty.call(message, 'denotation'))\n        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.denotation);\n      if (message.sparseTensorType != null && Object.hasOwnProperty.call(message, 'sparseTensorType'))\n        $root.onnx.TypeProto.SparseTensor.encode(\n          message.sparseTensorType,\n          writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),\n        ).ldelim();\n      if (message.optionalType != null && Object.hasOwnProperty.call(message, 'optionalType'))\n        $root.onnx.TypeProto.Optional.encode(\n          message.optionalType,\n          writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),\n        ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified TypeProto message, length delimited. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {onnx.ITypeProto} message TypeProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TypeProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TypeProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.TypeProto} TypeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TypeProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.TypeProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.tensorType = $root.onnx.TypeProto.Tensor.decode(reader, reader.uint32());\n            break;\n          }\n          case 4: {\n            message.sequenceType = $root.onnx.TypeProto.Sequence.decode(reader, reader.uint32());\n            break;\n          }\n          case 5: {\n            message.mapType = $root.onnx.TypeProto.Map.decode(reader, reader.uint32());\n            break;\n          }\n          case 9: {\n            message.optionalType = $root.onnx.TypeProto.Optional.decode(reader, reader.uint32());\n            break;\n          }\n          case 8: {\n            message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.decode(reader, reader.uint32());\n            break;\n          }\n          case 6: {\n            message.denotation = reader.string();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a TypeProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.TypeProto} TypeProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TypeProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TypeProto message.\n     * @function verify\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TypeProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      var properties = {};\n      if (message.tensorType != null && message.hasOwnProperty('tensorType')) {\n        properties.value = 1;\n        {\n          var error = $root.onnx.TypeProto.Tensor.verify(message.tensorType);\n          if (error) return 'tensorType.' + error;\n        }\n      }\n      if (message.sequenceType != null && message.hasOwnProperty('sequenceType')) {\n        if (properties.value === 1) return 'value: multiple values';\n        properties.value = 1;\n        {\n          var error = $root.onnx.TypeProto.Sequence.verify(message.sequenceType);\n          if (error) return 'sequenceType.' + error;\n        }\n      }\n      if (message.mapType != null && message.hasOwnProperty('mapType')) {\n        if (properties.value === 1) return 'value: multiple values';\n        properties.value = 1;\n        {\n          var error = $root.onnx.TypeProto.Map.verify(message.mapType);\n          if (error) return 'mapType.' + error;\n        }\n      }\n      if (message.optionalType != null && message.hasOwnProperty('optionalType')) {\n        if (properties.value === 1) return 'value: multiple values';\n        properties.value = 1;\n        {\n          var error = $root.onnx.TypeProto.Optional.verify(message.optionalType);\n          if (error) return 'optionalType.' + error;\n        }\n      }\n      if (message.sparseTensorType != null && message.hasOwnProperty('sparseTensorType')) {\n        if (properties.value === 1) return 'value: multiple values';\n        properties.value = 1;\n        {\n          var error = $root.onnx.TypeProto.SparseTensor.verify(message.sparseTensorType);\n          if (error) return 'sparseTensorType.' + error;\n        }\n      }\n      if (message.denotation != null && message.hasOwnProperty('denotation'))\n        if (!$util.isString(message.denotation)) return 'denotation: string expected';\n      return null;\n    };\n\n    /**\n     * Creates a TypeProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.TypeProto} TypeProto\n     */\n    TypeProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.TypeProto) return object;\n      var message = new $root.onnx.TypeProto();\n      if (object.tensorType != null) {\n        if (typeof object.tensorType !== 'object') throw TypeError('.onnx.TypeProto.tensorType: object expected');\n        message.tensorType = $root.onnx.TypeProto.Tensor.fromObject(object.tensorType);\n      }\n      if (object.sequenceType != null) {\n        if (typeof object.sequenceType !== 'object') throw TypeError('.onnx.TypeProto.sequenceType: object expected');\n        message.sequenceType = $root.onnx.TypeProto.Sequence.fromObject(object.sequenceType);\n      }\n      if (object.mapType != null) {\n        if (typeof object.mapType !== 'object') throw TypeError('.onnx.TypeProto.mapType: object expected');\n        message.mapType = $root.onnx.TypeProto.Map.fromObject(object.mapType);\n      }\n      if (object.optionalType != null) {\n        if (typeof object.optionalType !== 'object') throw TypeError('.onnx.TypeProto.optionalType: object expected');\n        message.optionalType = $root.onnx.TypeProto.Optional.fromObject(object.optionalType);\n      }\n      if (object.sparseTensorType != null) {\n        if (typeof object.sparseTensorType !== 'object')\n          throw TypeError('.onnx.TypeProto.sparseTensorType: object expected');\n        message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.fromObject(object.sparseTensorType);\n      }\n      if (object.denotation != null) message.denotation = String(object.denotation);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a TypeProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {onnx.TypeProto} message TypeProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TypeProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) object.denotation = '';\n      if (message.tensorType != null && message.hasOwnProperty('tensorType')) {\n        object.tensorType = $root.onnx.TypeProto.Tensor.toObject(message.tensorType, options);\n        if (options.oneofs) object.value = 'tensorType';\n      }\n      if (message.sequenceType != null && message.hasOwnProperty('sequenceType')) {\n        object.sequenceType = $root.onnx.TypeProto.Sequence.toObject(message.sequenceType, options);\n        if (options.oneofs) object.value = 'sequenceType';\n      }\n      if (message.mapType != null && message.hasOwnProperty('mapType')) {\n        object.mapType = $root.onnx.TypeProto.Map.toObject(message.mapType, options);\n        if (options.oneofs) object.value = 'mapType';\n      }\n      if (message.denotation != null && message.hasOwnProperty('denotation')) object.denotation = message.denotation;\n      if (message.sparseTensorType != null && message.hasOwnProperty('sparseTensorType')) {\n        object.sparseTensorType = $root.onnx.TypeProto.SparseTensor.toObject(message.sparseTensorType, options);\n        if (options.oneofs) object.value = 'sparseTensorType';\n      }\n      if (message.optionalType != null && message.hasOwnProperty('optionalType')) {\n        object.optionalType = $root.onnx.TypeProto.Optional.toObject(message.optionalType, options);\n        if (options.oneofs) object.value = 'optionalType';\n      }\n      return object;\n    };\n\n    /**\n     * Converts this TypeProto to JSON.\n     * @function toJSON\n     * @memberof onnx.TypeProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TypeProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for TypeProto\n     * @function getTypeUrl\n     * @memberof onnx.TypeProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    TypeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.TypeProto';\n    };\n\n    TypeProto.Tensor = (function () {\n      /**\n       * Properties of a Tensor.\n       * @memberof onnx.TypeProto\n       * @interface ITensor\n       * @property {number|null} [elemType] Tensor elemType\n       * @property {onnx.ITensorShapeProto|null} [shape] Tensor shape\n       */\n\n      /**\n       * Constructs a new Tensor.\n       * @memberof onnx.TypeProto\n       * @classdesc Represents a Tensor.\n       * @implements ITensor\n       * @constructor\n       * @param {onnx.TypeProto.ITensor=} [properties] Properties to set\n       */\n      function Tensor(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Tensor elemType.\n       * @member {number} elemType\n       * @memberof onnx.TypeProto.Tensor\n       * @instance\n       */\n      Tensor.prototype.elemType = 0;\n\n      /**\n       * Tensor shape.\n       * @member {onnx.ITensorShapeProto|null|undefined} shape\n       * @memberof onnx.TypeProto.Tensor\n       * @instance\n       */\n      Tensor.prototype.shape = null;\n\n      /**\n       * Creates a new Tensor instance using the specified properties.\n       * @function create\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {onnx.TypeProto.ITensor=} [properties] Properties to set\n       * @returns {onnx.TypeProto.Tensor} Tensor instance\n       */\n      Tensor.create = function create(properties) {\n        return new Tensor(properties);\n      };\n\n      /**\n       * Encodes the specified Tensor message. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Tensor.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.elemType != null && Object.hasOwnProperty.call(message, 'elemType'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.elemType);\n        if (message.shape != null && Object.hasOwnProperty.call(message, 'shape'))\n          $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Tensor message, length delimited. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Tensor.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a Tensor message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TypeProto.Tensor} Tensor\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Tensor.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TypeProto.Tensor();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.elemType = reader.int32();\n              break;\n            }\n            case 2: {\n              message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a Tensor message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TypeProto.Tensor} Tensor\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Tensor.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a Tensor message.\n       * @function verify\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Tensor.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.elemType != null && message.hasOwnProperty('elemType'))\n          if (!$util.isInteger(message.elemType)) return 'elemType: integer expected';\n        if (message.shape != null && message.hasOwnProperty('shape')) {\n          var error = $root.onnx.TensorShapeProto.verify(message.shape);\n          if (error) return 'shape.' + error;\n        }\n        return null;\n      };\n\n      /**\n       * Creates a Tensor message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TypeProto.Tensor} Tensor\n       */\n      Tensor.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TypeProto.Tensor) return object;\n        var message = new $root.onnx.TypeProto.Tensor();\n        if (object.elemType != null) message.elemType = object.elemType | 0;\n        if (object.shape != null) {\n          if (typeof object.shape !== 'object') throw TypeError('.onnx.TypeProto.Tensor.shape: object expected');\n          message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);\n        }\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a Tensor message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {onnx.TypeProto.Tensor} message Tensor\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Tensor.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) {\n          object.elemType = 0;\n          object.shape = null;\n        }\n        if (message.elemType != null && message.hasOwnProperty('elemType')) object.elemType = message.elemType;\n        if (message.shape != null && message.hasOwnProperty('shape'))\n          object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);\n        return object;\n      };\n\n      /**\n       * Converts this Tensor to JSON.\n       * @function toJSON\n       * @memberof onnx.TypeProto.Tensor\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Tensor.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Tensor\n       * @function getTypeUrl\n       * @memberof onnx.TypeProto.Tensor\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Tensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TypeProto.Tensor';\n      };\n\n      return Tensor;\n    })();\n\n    TypeProto.Sequence = (function () {\n      /**\n       * Properties of a Sequence.\n       * @memberof onnx.TypeProto\n       * @interface ISequence\n       * @property {onnx.ITypeProto|null} [elemType] Sequence elemType\n       */\n\n      /**\n       * Constructs a new Sequence.\n       * @memberof onnx.TypeProto\n       * @classdesc Represents a Sequence.\n       * @implements ISequence\n       * @constructor\n       * @param {onnx.TypeProto.ISequence=} [properties] Properties to set\n       */\n      function Sequence(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Sequence elemType.\n       * @member {onnx.ITypeProto|null|undefined} elemType\n       * @memberof onnx.TypeProto.Sequence\n       * @instance\n       */\n      Sequence.prototype.elemType = null;\n\n      /**\n       * Creates a new Sequence instance using the specified properties.\n       * @function create\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {onnx.TypeProto.ISequence=} [properties] Properties to set\n       * @returns {onnx.TypeProto.Sequence} Sequence instance\n       */\n      Sequence.create = function create(properties) {\n        return new Sequence(properties);\n      };\n\n      /**\n       * Encodes the specified Sequence message. Does not implicitly {@link onnx.TypeProto.Sequence.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {onnx.TypeProto.ISequence} message Sequence message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Sequence.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.elemType != null && Object.hasOwnProperty.call(message, 'elemType'))\n          $root.onnx.TypeProto.encode(message.elemType, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Sequence message, length delimited. Does not implicitly {@link onnx.TypeProto.Sequence.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {onnx.TypeProto.ISequence} message Sequence message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Sequence.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a Sequence message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TypeProto.Sequence} Sequence\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Sequence.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TypeProto.Sequence();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a Sequence message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TypeProto.Sequence} Sequence\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Sequence.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a Sequence message.\n       * @function verify\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Sequence.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.elemType != null && message.hasOwnProperty('elemType')) {\n          var error = $root.onnx.TypeProto.verify(message.elemType);\n          if (error) return 'elemType.' + error;\n        }\n        return null;\n      };\n\n      /**\n       * Creates a Sequence message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TypeProto.Sequence} Sequence\n       */\n      Sequence.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TypeProto.Sequence) return object;\n        var message = new $root.onnx.TypeProto.Sequence();\n        if (object.elemType != null) {\n          if (typeof object.elemType !== 'object')\n            throw TypeError('.onnx.TypeProto.Sequence.elemType: object expected');\n          message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);\n        }\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a Sequence message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {onnx.TypeProto.Sequence} message Sequence\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Sequence.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.elemType = null;\n        if (message.elemType != null && message.hasOwnProperty('elemType'))\n          object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);\n        return object;\n      };\n\n      /**\n       * Converts this Sequence to JSON.\n       * @function toJSON\n       * @memberof onnx.TypeProto.Sequence\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Sequence.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Sequence\n       * @function getTypeUrl\n       * @memberof onnx.TypeProto.Sequence\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Sequence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TypeProto.Sequence';\n      };\n\n      return Sequence;\n    })();\n\n    TypeProto.Map = (function () {\n      /**\n       * Properties of a Map.\n       * @memberof onnx.TypeProto\n       * @interface IMap\n       * @property {number|null} [keyType] Map keyType\n       * @property {onnx.ITypeProto|null} [valueType] Map valueType\n       */\n\n      /**\n       * Constructs a new Map.\n       * @memberof onnx.TypeProto\n       * @classdesc Represents a Map.\n       * @implements IMap\n       * @constructor\n       * @param {onnx.TypeProto.IMap=} [properties] Properties to set\n       */\n      function Map(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Map keyType.\n       * @member {number} keyType\n       * @memberof onnx.TypeProto.Map\n       * @instance\n       */\n      Map.prototype.keyType = 0;\n\n      /**\n       * Map valueType.\n       * @member {onnx.ITypeProto|null|undefined} valueType\n       * @memberof onnx.TypeProto.Map\n       * @instance\n       */\n      Map.prototype.valueType = null;\n\n      /**\n       * Creates a new Map instance using the specified properties.\n       * @function create\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {onnx.TypeProto.IMap=} [properties] Properties to set\n       * @returns {onnx.TypeProto.Map} Map instance\n       */\n      Map.create = function create(properties) {\n        return new Map(properties);\n      };\n\n      /**\n       * Encodes the specified Map message. Does not implicitly {@link onnx.TypeProto.Map.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {onnx.TypeProto.IMap} message Map message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Map.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.keyType != null && Object.hasOwnProperty.call(message, 'keyType'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.keyType);\n        if (message.valueType != null && Object.hasOwnProperty.call(message, 'valueType'))\n          $root.onnx.TypeProto.encode(message.valueType, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Map message, length delimited. Does not implicitly {@link onnx.TypeProto.Map.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {onnx.TypeProto.IMap} message Map message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Map.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a Map message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TypeProto.Map} Map\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Map.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TypeProto.Map();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.keyType = reader.int32();\n              break;\n            }\n            case 2: {\n              message.valueType = $root.onnx.TypeProto.decode(reader, reader.uint32());\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a Map message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TypeProto.Map} Map\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Map.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a Map message.\n       * @function verify\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Map.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.keyType != null && message.hasOwnProperty('keyType'))\n          if (!$util.isInteger(message.keyType)) return 'keyType: integer expected';\n        if (message.valueType != null && message.hasOwnProperty('valueType')) {\n          var error = $root.onnx.TypeProto.verify(message.valueType);\n          if (error) return 'valueType.' + error;\n        }\n        return null;\n      };\n\n      /**\n       * Creates a Map message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TypeProto.Map} Map\n       */\n      Map.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TypeProto.Map) return object;\n        var message = new $root.onnx.TypeProto.Map();\n        if (object.keyType != null) message.keyType = object.keyType | 0;\n        if (object.valueType != null) {\n          if (typeof object.valueType !== 'object') throw TypeError('.onnx.TypeProto.Map.valueType: object expected');\n          message.valueType = $root.onnx.TypeProto.fromObject(object.valueType);\n        }\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a Map message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {onnx.TypeProto.Map} message Map\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Map.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) {\n          object.keyType = 0;\n          object.valueType = null;\n        }\n        if (message.keyType != null && message.hasOwnProperty('keyType')) object.keyType = message.keyType;\n        if (message.valueType != null && message.hasOwnProperty('valueType'))\n          object.valueType = $root.onnx.TypeProto.toObject(message.valueType, options);\n        return object;\n      };\n\n      /**\n       * Converts this Map to JSON.\n       * @function toJSON\n       * @memberof onnx.TypeProto.Map\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Map.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Map\n       * @function getTypeUrl\n       * @memberof onnx.TypeProto.Map\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Map.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TypeProto.Map';\n      };\n\n      return Map;\n    })();\n\n    TypeProto.Optional = (function () {\n      /**\n       * Properties of an Optional.\n       * @memberof onnx.TypeProto\n       * @interface IOptional\n       * @property {onnx.ITypeProto|null} [elemType] Optional elemType\n       */\n\n      /**\n       * Constructs a new Optional.\n       * @memberof onnx.TypeProto\n       * @classdesc Represents an Optional.\n       * @implements IOptional\n       * @constructor\n       * @param {onnx.TypeProto.IOptional=} [properties] Properties to set\n       */\n      function Optional(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Optional elemType.\n       * @member {onnx.ITypeProto|null|undefined} elemType\n       * @memberof onnx.TypeProto.Optional\n       * @instance\n       */\n      Optional.prototype.elemType = null;\n\n      /**\n       * Creates a new Optional instance using the specified properties.\n       * @function create\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {onnx.TypeProto.IOptional=} [properties] Properties to set\n       * @returns {onnx.TypeProto.Optional} Optional instance\n       */\n      Optional.create = function create(properties) {\n        return new Optional(properties);\n      };\n\n      /**\n       * Encodes the specified Optional message. Does not implicitly {@link onnx.TypeProto.Optional.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {onnx.TypeProto.IOptional} message Optional message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Optional.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.elemType != null && Object.hasOwnProperty.call(message, 'elemType'))\n          $root.onnx.TypeProto.encode(message.elemType, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n        return writer;\n      };\n\n      /**\n       * Encodes the specified Optional message, length delimited. Does not implicitly {@link onnx.TypeProto.Optional.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {onnx.TypeProto.IOptional} message Optional message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      Optional.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes an Optional message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TypeProto.Optional} Optional\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Optional.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TypeProto.Optional();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes an Optional message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TypeProto.Optional} Optional\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Optional.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies an Optional message.\n       * @function verify\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      Optional.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.elemType != null && message.hasOwnProperty('elemType')) {\n          var error = $root.onnx.TypeProto.verify(message.elemType);\n          if (error) return 'elemType.' + error;\n        }\n        return null;\n      };\n\n      /**\n       * Creates an Optional message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TypeProto.Optional} Optional\n       */\n      Optional.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TypeProto.Optional) return object;\n        var message = new $root.onnx.TypeProto.Optional();\n        if (object.elemType != null) {\n          if (typeof object.elemType !== 'object')\n            throw TypeError('.onnx.TypeProto.Optional.elemType: object expected');\n          message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);\n        }\n        return message;\n      };\n\n      /**\n       * Creates a plain object from an Optional message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {onnx.TypeProto.Optional} message Optional\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      Optional.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.elemType = null;\n        if (message.elemType != null && message.hasOwnProperty('elemType'))\n          object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);\n        return object;\n      };\n\n      /**\n       * Converts this Optional to JSON.\n       * @function toJSON\n       * @memberof onnx.TypeProto.Optional\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      Optional.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for Optional\n       * @function getTypeUrl\n       * @memberof onnx.TypeProto.Optional\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      Optional.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TypeProto.Optional';\n      };\n\n      return Optional;\n    })();\n\n    TypeProto.SparseTensor = (function () {\n      /**\n       * Properties of a SparseTensor.\n       * @memberof onnx.TypeProto\n       * @interface ISparseTensor\n       * @property {number|null} [elemType] SparseTensor elemType\n       * @property {onnx.ITensorShapeProto|null} [shape] SparseTensor shape\n       */\n\n      /**\n       * Constructs a new SparseTensor.\n       * @memberof onnx.TypeProto\n       * @classdesc Represents a SparseTensor.\n       * @implements ISparseTensor\n       * @constructor\n       * @param {onnx.TypeProto.ISparseTensor=} [properties] Properties to set\n       */\n      function SparseTensor(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * SparseTensor elemType.\n       * @member {number} elemType\n       * @memberof onnx.TypeProto.SparseTensor\n       * @instance\n       */\n      SparseTensor.prototype.elemType = 0;\n\n      /**\n       * SparseTensor shape.\n       * @member {onnx.ITensorShapeProto|null|undefined} shape\n       * @memberof onnx.TypeProto.SparseTensor\n       * @instance\n       */\n      SparseTensor.prototype.shape = null;\n\n      /**\n       * Creates a new SparseTensor instance using the specified properties.\n       * @function create\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {onnx.TypeProto.ISparseTensor=} [properties] Properties to set\n       * @returns {onnx.TypeProto.SparseTensor} SparseTensor instance\n       */\n      SparseTensor.create = function create(properties) {\n        return new SparseTensor(properties);\n      };\n\n      /**\n       * Encodes the specified SparseTensor message. Does not implicitly {@link onnx.TypeProto.SparseTensor.verify|verify} messages.\n       * @function encode\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {onnx.TypeProto.ISparseTensor} message SparseTensor message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      SparseTensor.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.elemType != null && Object.hasOwnProperty.call(message, 'elemType'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.elemType);\n        if (message.shape != null && Object.hasOwnProperty.call(message, 'shape'))\n          $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n        return writer;\n      };\n\n      /**\n       * Encodes the specified SparseTensor message, length delimited. Does not implicitly {@link onnx.TypeProto.SparseTensor.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {onnx.TypeProto.ISparseTensor} message SparseTensor message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      SparseTensor.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n\n      /**\n       * Decodes a SparseTensor message from the specified reader or buffer.\n       * @function decode\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {onnx.TypeProto.SparseTensor} SparseTensor\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      SparseTensor.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.onnx.TypeProto.SparseTensor();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1: {\n              message.elemType = reader.int32();\n              break;\n            }\n            case 2: {\n              message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());\n              break;\n            }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n\n      /**\n       * Decodes a SparseTensor message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {onnx.TypeProto.SparseTensor} SparseTensor\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      SparseTensor.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n\n      /**\n       * Verifies a SparseTensor message.\n       * @function verify\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      SparseTensor.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.elemType != null && message.hasOwnProperty('elemType'))\n          if (!$util.isInteger(message.elemType)) return 'elemType: integer expected';\n        if (message.shape != null && message.hasOwnProperty('shape')) {\n          var error = $root.onnx.TensorShapeProto.verify(message.shape);\n          if (error) return 'shape.' + error;\n        }\n        return null;\n      };\n\n      /**\n       * Creates a SparseTensor message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {onnx.TypeProto.SparseTensor} SparseTensor\n       */\n      SparseTensor.fromObject = function fromObject(object) {\n        if (object instanceof $root.onnx.TypeProto.SparseTensor) return object;\n        var message = new $root.onnx.TypeProto.SparseTensor();\n        if (object.elemType != null) message.elemType = object.elemType | 0;\n        if (object.shape != null) {\n          if (typeof object.shape !== 'object') throw TypeError('.onnx.TypeProto.SparseTensor.shape: object expected');\n          message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);\n        }\n        return message;\n      };\n\n      /**\n       * Creates a plain object from a SparseTensor message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {onnx.TypeProto.SparseTensor} message SparseTensor\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      SparseTensor.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) {\n          object.elemType = 0;\n          object.shape = null;\n        }\n        if (message.elemType != null && message.hasOwnProperty('elemType')) object.elemType = message.elemType;\n        if (message.shape != null && message.hasOwnProperty('shape'))\n          object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);\n        return object;\n      };\n\n      /**\n       * Converts this SparseTensor to JSON.\n       * @function toJSON\n       * @memberof onnx.TypeProto.SparseTensor\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      SparseTensor.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      /**\n       * Gets the default type url for SparseTensor\n       * @function getTypeUrl\n       * @memberof onnx.TypeProto.SparseTensor\n       * @static\n       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n       * @returns {string} The default type url\n       */\n      SparseTensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n        if (typeUrlPrefix === undefined) {\n          typeUrlPrefix = 'type.googleapis.com';\n        }\n        return typeUrlPrefix + '/onnx.TypeProto.SparseTensor';\n      };\n\n      return SparseTensor;\n    })();\n\n    return TypeProto;\n  })();\n\n  onnx.OperatorSetIdProto = (function () {\n    /**\n     * Properties of an OperatorSetIdProto.\n     * @memberof onnx\n     * @interface IOperatorSetIdProto\n     * @property {string|null} [domain] OperatorSetIdProto domain\n     * @property {number|Long|null} [version] OperatorSetIdProto version\n     */\n\n    /**\n     * Constructs a new OperatorSetIdProto.\n     * @memberof onnx\n     * @classdesc Represents an OperatorSetIdProto.\n     * @implements IOperatorSetIdProto\n     * @constructor\n     * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set\n     */\n    function OperatorSetIdProto(properties) {\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * OperatorSetIdProto domain.\n     * @member {string} domain\n     * @memberof onnx.OperatorSetIdProto\n     * @instance\n     */\n    OperatorSetIdProto.prototype.domain = '';\n\n    /**\n     * OperatorSetIdProto version.\n     * @member {number|Long} version\n     * @memberof onnx.OperatorSetIdProto\n     * @instance\n     */\n    OperatorSetIdProto.prototype.version = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n    /**\n     * Creates a new OperatorSetIdProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set\n     * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto instance\n     */\n    OperatorSetIdProto.create = function create(properties) {\n      return new OperatorSetIdProto(properties);\n    };\n\n    /**\n     * Encodes the specified OperatorSetIdProto message. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    OperatorSetIdProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.domain != null && Object.hasOwnProperty.call(message, 'domain'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.domain);\n      if (message.version != null && Object.hasOwnProperty.call(message, 'version'))\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.version);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified OperatorSetIdProto message, length delimited. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    OperatorSetIdProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an OperatorSetIdProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OperatorSetIdProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.OperatorSetIdProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.domain = reader.string();\n            break;\n          }\n          case 2: {\n            message.version = reader.int64();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes an OperatorSetIdProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OperatorSetIdProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an OperatorSetIdProto message.\n     * @function verify\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    OperatorSetIdProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.domain != null && message.hasOwnProperty('domain'))\n        if (!$util.isString(message.domain)) return 'domain: string expected';\n      if (message.version != null && message.hasOwnProperty('version'))\n        if (\n          !$util.isInteger(message.version) &&\n          !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high))\n        )\n          return 'version: integer|Long expected';\n      return null;\n    };\n\n    /**\n     * Creates an OperatorSetIdProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n     */\n    OperatorSetIdProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.OperatorSetIdProto) return object;\n      var message = new $root.onnx.OperatorSetIdProto();\n      if (object.domain != null) message.domain = String(object.domain);\n      if (object.version != null)\n        if ($util.Long) (message.version = $util.Long.fromValue(object.version)).unsigned = false;\n        else if (typeof object.version === 'string') message.version = parseInt(object.version, 10);\n        else if (typeof object.version === 'number') message.version = object.version;\n        else if (typeof object.version === 'object')\n          message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();\n      return message;\n    };\n\n    /**\n     * Creates a plain object from an OperatorSetIdProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {onnx.OperatorSetIdProto} message OperatorSetIdProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    OperatorSetIdProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        object.domain = '';\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, false);\n          object.version =\n            options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.version = options.longs === String ? '0' : 0;\n      }\n      if (message.domain != null && message.hasOwnProperty('domain')) object.domain = message.domain;\n      if (message.version != null && message.hasOwnProperty('version'))\n        if (typeof message.version === 'number')\n          object.version = options.longs === String ? String(message.version) : message.version;\n        else\n          object.version =\n            options.longs === String\n              ? $util.Long.prototype.toString.call(message.version)\n              : options.longs === Number\n                ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber()\n                : message.version;\n      return object;\n    };\n\n    /**\n     * Converts this OperatorSetIdProto to JSON.\n     * @function toJSON\n     * @memberof onnx.OperatorSetIdProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    OperatorSetIdProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for OperatorSetIdProto\n     * @function getTypeUrl\n     * @memberof onnx.OperatorSetIdProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    OperatorSetIdProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.OperatorSetIdProto';\n    };\n\n    return OperatorSetIdProto;\n  })();\n\n  /**\n   * OperatorStatus enum.\n   * @name onnx.OperatorStatus\n   * @enum {number}\n   * @property {number} EXPERIMENTAL=0 EXPERIMENTAL value\n   * @property {number} STABLE=1 STABLE value\n   */\n  onnx.OperatorStatus = (function () {\n    var valuesById = {},\n      values = Object.create(valuesById);\n    values[(valuesById[0] = 'EXPERIMENTAL')] = 0;\n    values[(valuesById[1] = 'STABLE')] = 1;\n    return values;\n  })();\n\n  onnx.FunctionProto = (function () {\n    /**\n     * Properties of a FunctionProto.\n     * @memberof onnx\n     * @interface IFunctionProto\n     * @property {string|null} [name] FunctionProto name\n     * @property {Array.<string>|null} [input] FunctionProto input\n     * @property {Array.<string>|null} [output] FunctionProto output\n     * @property {Array.<string>|null} [attribute] FunctionProto attribute\n     * @property {Array.<onnx.IAttributeProto>|null} [attributeProto] FunctionProto attributeProto\n     * @property {Array.<onnx.INodeProto>|null} [node] FunctionProto node\n     * @property {string|null} [docString] FunctionProto docString\n     * @property {Array.<onnx.IOperatorSetIdProto>|null} [opsetImport] FunctionProto opsetImport\n     * @property {string|null} [domain] FunctionProto domain\n     */\n\n    /**\n     * Constructs a new FunctionProto.\n     * @memberof onnx\n     * @classdesc Represents a FunctionProto.\n     * @implements IFunctionProto\n     * @constructor\n     * @param {onnx.IFunctionProto=} [properties] Properties to set\n     */\n    function FunctionProto(properties) {\n      this.input = [];\n      this.output = [];\n      this.attribute = [];\n      this.attributeProto = [];\n      this.node = [];\n      this.opsetImport = [];\n      if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * FunctionProto name.\n     * @member {string} name\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.name = '';\n\n    /**\n     * FunctionProto input.\n     * @member {Array.<string>} input\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.input = $util.emptyArray;\n\n    /**\n     * FunctionProto output.\n     * @member {Array.<string>} output\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.output = $util.emptyArray;\n\n    /**\n     * FunctionProto attribute.\n     * @member {Array.<string>} attribute\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.attribute = $util.emptyArray;\n\n    /**\n     * FunctionProto attributeProto.\n     * @member {Array.<onnx.IAttributeProto>} attributeProto\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.attributeProto = $util.emptyArray;\n\n    /**\n     * FunctionProto node.\n     * @member {Array.<onnx.INodeProto>} node\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.node = $util.emptyArray;\n\n    /**\n     * FunctionProto docString.\n     * @member {string} docString\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.docString = '';\n\n    /**\n     * FunctionProto opsetImport.\n     * @member {Array.<onnx.IOperatorSetIdProto>} opsetImport\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.opsetImport = $util.emptyArray;\n\n    /**\n     * FunctionProto domain.\n     * @member {string} domain\n     * @memberof onnx.FunctionProto\n     * @instance\n     */\n    FunctionProto.prototype.domain = '';\n\n    /**\n     * Creates a new FunctionProto instance using the specified properties.\n     * @function create\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {onnx.IFunctionProto=} [properties] Properties to set\n     * @returns {onnx.FunctionProto} FunctionProto instance\n     */\n    FunctionProto.create = function create(properties) {\n      return new FunctionProto(properties);\n    };\n\n    /**\n     * Encodes the specified FunctionProto message. Does not implicitly {@link onnx.FunctionProto.verify|verify} messages.\n     * @function encode\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {onnx.IFunctionProto} message FunctionProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FunctionProto.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);\n      if (message.input != null && message.input.length)\n        for (var i = 0; i < message.input.length; ++i)\n          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.input[i]);\n      if (message.output != null && message.output.length)\n        for (var i = 0; i < message.output.length; ++i)\n          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.output[i]);\n      if (message.attribute != null && message.attribute.length)\n        for (var i = 0; i < message.attribute.length; ++i)\n          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.attribute[i]);\n      if (message.node != null && message.node.length)\n        for (var i = 0; i < message.node.length; ++i)\n          $root.onnx.NodeProto.encode(message.node[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();\n      if (message.docString != null && Object.hasOwnProperty.call(message, 'docString'))\n        writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.docString);\n      if (message.opsetImport != null && message.opsetImport.length)\n        for (var i = 0; i < message.opsetImport.length; ++i)\n          $root.onnx.OperatorSetIdProto.encode(\n            message.opsetImport[i],\n            writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),\n          ).ldelim();\n      if (message.domain != null && Object.hasOwnProperty.call(message, 'domain'))\n        writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.domain);\n      if (message.attributeProto != null && message.attributeProto.length)\n        for (var i = 0; i < message.attributeProto.length; ++i)\n          $root.onnx.AttributeProto.encode(\n            message.attributeProto[i],\n            writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified FunctionProto message, length delimited. Does not implicitly {@link onnx.FunctionProto.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {onnx.IFunctionProto} message FunctionProto message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FunctionProto.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a FunctionProto message from the specified reader or buffer.\n     * @function decode\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {onnx.FunctionProto} FunctionProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FunctionProto.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.onnx.FunctionProto();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1: {\n            message.name = reader.string();\n            break;\n          }\n          case 4: {\n            if (!(message.input && message.input.length)) message.input = [];\n            message.input.push(reader.string());\n            break;\n          }\n          case 5: {\n            if (!(message.output && message.output.length)) message.output = [];\n            message.output.push(reader.string());\n            break;\n          }\n          case 6: {\n            if (!(message.attribute && message.attribute.length)) message.attribute = [];\n            message.attribute.push(reader.string());\n            break;\n          }\n          case 11: {\n            if (!(message.attributeProto && message.attributeProto.length)) message.attributeProto = [];\n            message.attributeProto.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 7: {\n            if (!(message.node && message.node.length)) message.node = [];\n            message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 8: {\n            message.docString = reader.string();\n            break;\n          }\n          case 9: {\n            if (!(message.opsetImport && message.opsetImport.length)) message.opsetImport = [];\n            message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));\n            break;\n          }\n          case 10: {\n            message.domain = reader.string();\n            break;\n          }\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a FunctionProto message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {onnx.FunctionProto} FunctionProto\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FunctionProto.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a FunctionProto message.\n     * @function verify\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    FunctionProto.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.name != null && message.hasOwnProperty('name'))\n        if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.input != null && message.hasOwnProperty('input')) {\n        if (!Array.isArray(message.input)) return 'input: array expected';\n        for (var i = 0; i < message.input.length; ++i)\n          if (!$util.isString(message.input[i])) return 'input: string[] expected';\n      }\n      if (message.output != null && message.hasOwnProperty('output')) {\n        if (!Array.isArray(message.output)) return 'output: array expected';\n        for (var i = 0; i < message.output.length; ++i)\n          if (!$util.isString(message.output[i])) return 'output: string[] expected';\n      }\n      if (message.attribute != null && message.hasOwnProperty('attribute')) {\n        if (!Array.isArray(message.attribute)) return 'attribute: array expected';\n        for (var i = 0; i < message.attribute.length; ++i)\n          if (!$util.isString(message.attribute[i])) return 'attribute: string[] expected';\n      }\n      if (message.attributeProto != null && message.hasOwnProperty('attributeProto')) {\n        if (!Array.isArray(message.attributeProto)) return 'attributeProto: array expected';\n        for (var i = 0; i < message.attributeProto.length; ++i) {\n          var error = $root.onnx.AttributeProto.verify(message.attributeProto[i]);\n          if (error) return 'attributeProto.' + error;\n        }\n      }\n      if (message.node != null && message.hasOwnProperty('node')) {\n        if (!Array.isArray(message.node)) return 'node: array expected';\n        for (var i = 0; i < message.node.length; ++i) {\n          var error = $root.onnx.NodeProto.verify(message.node[i]);\n          if (error) return 'node.' + error;\n        }\n      }\n      if (message.docString != null && message.hasOwnProperty('docString'))\n        if (!$util.isString(message.docString)) return 'docString: string expected';\n      if (message.opsetImport != null && message.hasOwnProperty('opsetImport')) {\n        if (!Array.isArray(message.opsetImport)) return 'opsetImport: array expected';\n        for (var i = 0; i < message.opsetImport.length; ++i) {\n          var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);\n          if (error) return 'opsetImport.' + error;\n        }\n      }\n      if (message.domain != null && message.hasOwnProperty('domain'))\n        if (!$util.isString(message.domain)) return 'domain: string expected';\n      return null;\n    };\n\n    /**\n     * Creates a FunctionProto message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {onnx.FunctionProto} FunctionProto\n     */\n    FunctionProto.fromObject = function fromObject(object) {\n      if (object instanceof $root.onnx.FunctionProto) return object;\n      var message = new $root.onnx.FunctionProto();\n      if (object.name != null) message.name = String(object.name);\n      if (object.input) {\n        if (!Array.isArray(object.input)) throw TypeError('.onnx.FunctionProto.input: array expected');\n        message.input = [];\n        for (var i = 0; i < object.input.length; ++i) message.input[i] = String(object.input[i]);\n      }\n      if (object.output) {\n        if (!Array.isArray(object.output)) throw TypeError('.onnx.FunctionProto.output: array expected');\n        message.output = [];\n        for (var i = 0; i < object.output.length; ++i) message.output[i] = String(object.output[i]);\n      }\n      if (object.attribute) {\n        if (!Array.isArray(object.attribute)) throw TypeError('.onnx.FunctionProto.attribute: array expected');\n        message.attribute = [];\n        for (var i = 0; i < object.attribute.length; ++i) message.attribute[i] = String(object.attribute[i]);\n      }\n      if (object.attributeProto) {\n        if (!Array.isArray(object.attributeProto))\n          throw TypeError('.onnx.FunctionProto.attributeProto: array expected');\n        message.attributeProto = [];\n        for (var i = 0; i < object.attributeProto.length; ++i) {\n          if (typeof object.attributeProto[i] !== 'object')\n            throw TypeError('.onnx.FunctionProto.attributeProto: object expected');\n          message.attributeProto[i] = $root.onnx.AttributeProto.fromObject(object.attributeProto[i]);\n        }\n      }\n      if (object.node) {\n        if (!Array.isArray(object.node)) throw TypeError('.onnx.FunctionProto.node: array expected');\n        message.node = [];\n        for (var i = 0; i < object.node.length; ++i) {\n          if (typeof object.node[i] !== 'object') throw TypeError('.onnx.FunctionProto.node: object expected');\n          message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);\n        }\n      }\n      if (object.docString != null) message.docString = String(object.docString);\n      if (object.opsetImport) {\n        if (!Array.isArray(object.opsetImport)) throw TypeError('.onnx.FunctionProto.opsetImport: array expected');\n        message.opsetImport = [];\n        for (var i = 0; i < object.opsetImport.length; ++i) {\n          if (typeof object.opsetImport[i] !== 'object')\n            throw TypeError('.onnx.FunctionProto.opsetImport: object expected');\n          message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);\n        }\n      }\n      if (object.domain != null) message.domain = String(object.domain);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a FunctionProto message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {onnx.FunctionProto} message FunctionProto\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    FunctionProto.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) {\n        object.input = [];\n        object.output = [];\n        object.attribute = [];\n        object.node = [];\n        object.opsetImport = [];\n        object.attributeProto = [];\n      }\n      if (options.defaults) {\n        object.name = '';\n        object.docString = '';\n        object.domain = '';\n      }\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.input && message.input.length) {\n        object.input = [];\n        for (var j = 0; j < message.input.length; ++j) object.input[j] = message.input[j];\n      }\n      if (message.output && message.output.length) {\n        object.output = [];\n        for (var j = 0; j < message.output.length; ++j) object.output[j] = message.output[j];\n      }\n      if (message.attribute && message.attribute.length) {\n        object.attribute = [];\n        for (var j = 0; j < message.attribute.length; ++j) object.attribute[j] = message.attribute[j];\n      }\n      if (message.node && message.node.length) {\n        object.node = [];\n        for (var j = 0; j < message.node.length; ++j)\n          object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);\n      }\n      if (message.docString != null && message.hasOwnProperty('docString')) object.docString = message.docString;\n      if (message.opsetImport && message.opsetImport.length) {\n        object.opsetImport = [];\n        for (var j = 0; j < message.opsetImport.length; ++j)\n          object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);\n      }\n      if (message.domain != null && message.hasOwnProperty('domain')) object.domain = message.domain;\n      if (message.attributeProto && message.attributeProto.length) {\n        object.attributeProto = [];\n        for (var j = 0; j < message.attributeProto.length; ++j)\n          object.attributeProto[j] = $root.onnx.AttributeProto.toObject(message.attributeProto[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this FunctionProto to JSON.\n     * @function toJSON\n     * @memberof onnx.FunctionProto\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    FunctionProto.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * Gets the default type url for FunctionProto\n     * @function getTypeUrl\n     * @memberof onnx.FunctionProto\n     * @static\n     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n     * @returns {string} The default type url\n     */\n    FunctionProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n      if (typeUrlPrefix === undefined) {\n        typeUrlPrefix = 'type.googleapis.com';\n      }\n      return typeUrlPrefix + '/onnx.FunctionProto';\n    };\n\n    return FunctionProto;\n  })();\n\n  return onnx;\n})();\n\nmodule.exports = $root;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { flatbuffers } from 'flatbuffers';\nimport Long from 'long';\n\nimport { Graph } from './graph';\nimport { onnxruntime } from './ort-schema/flatbuffers/ort-generated';\nimport { onnx } from './ort-schema/protobuf/onnx';\nimport { Tensor } from './tensor';\n\n// check the inputs shape before running an OP.\n// return true when the inputs pass the check\n// return false when the inputs do not fit the requirement\n// throw exception when fatal error or not implemented\nexport function checkInputsShape(inputs: Tensor[], ...expectedDimensions: number[]): boolean {\n  if (!inputs || inputs.length !== expectedDimensions.length) {\n    return false;\n  }\n  for (let i = 0; i < inputs.length; i++) {\n    if (!inputs[i].dims || inputs[i].dims.length !== expectedDimensions[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Evaluates the given expression and asserts error message if condition is unmet.\nexport function assert(expr: boolean, msg: () => string) {\n  if (!expr) {\n    throw new Error(typeof msg === 'string' ? msg : msg());\n  }\n}\n\nexport class ArrayUtil {\n  /**\n   * Verifies if 2 input arrays contain the same elements.\n   * @param n1 Array 1\n   * @param n2 Array 2\n   * @returns Whether these 2 are equal\n   */\n  static arraysEqual(\n    n1:\n      | readonly number[]\n      | Int8Array\n      | Uint8Array\n      | Int16Array\n      | Uint16Array\n      | Int32Array\n      | Uint32Array\n      | Uint8ClampedArray\n      | Float32Array\n      | Float64Array,\n    n2:\n      | readonly number[]\n      | Int8Array\n      | Uint8Array\n      | Int16Array\n      | Uint16Array\n      | Int32Array\n      | Uint32Array\n      | Uint8ClampedArray\n      | Float32Array\n      | Float64Array,\n  ) {\n    if (n1.length !== n2.length) {\n      return false;\n    }\n    for (let i = 0; i < n1.length; i++) {\n      if (n1[i] !== n2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nexport class MatMulUtil {\n  /**\n   * Fix the input shapes for MatMul operation if they need fixing\n   * @param dimsA The shape of tensor A. Should be an array of positive integers\n   * @param dimsB The shape of tensor B. Should be an array of positive integers\n   * @returns A tuple containing the preprocessed input shapes as required by ONNX specifications\n   */\n  static preprocessInputShapes(\n    dimsA: readonly number[],\n    dimsB: readonly number[],\n  ): [readonly number[], readonly number[]] {\n    // If the first argument is 1-D, it is promoted to a matrix by prepending\n    // a 1 to its dimensions. After matrix multiplication the prepended 1 is\n    // removed.\n    const a = dimsA.length === 1 ? [1, dimsA[0]] : dimsA;\n\n    // If the second argument is 1-D, it is promoted to a matrix by appending\n    // a 1 to its dimensions. After matrix multiplication the appended 1 is\n    // removed.\n    const b = dimsB.length === 1 ? [dimsB[0], 1] : dimsB;\n\n    return [a, b];\n  }\n\n  /**\n   * Fix the output shape computed for MatMul operation if it needs fixing\n   * @param outputShape The computed outputShape. Should be an array (atleast of length 2) of positive integers.\n   * This will be mutated.\n   * @param aRank The rank of tensor A.\n   * @param bRank The rank of tensor B.\n   */\n  static postprocessOutputShape(outputShape: number[], aRank: number, bRank: number) {\n    // Remove prepended dimension if first input is 1d\n    if (aRank === 1) {\n      // outputShape = outputShape.slice(0, outputShape.length - 2).concat(outputShape.slice(outputShape.length - 1));\n      outputShape.splice(outputShape.length - 2, 1);\n    }\n    // Remove appended dimension if second input is 1d\n    if (bRank === 1) {\n      outputShape.pop();\n    }\n  }\n\n  /**\n   * Calculate the expected shape when matrix multiplication\n   * @param a The shape of tensor A. Should be a tuple of 2 positive integers\n   * @param b The shape of tensor B. Should be a tuple of 2 positive integers\n   * @returns The expected shape of the result, or undefined if N/A\n   */\n  static calcMatMulShape(a: [number, number], b: [number, number]): [number, number] | undefined {\n    return a[1] !== b[0] ? undefined : [a[0], b[1]];\n  }\n}\n\nexport class BroadcastUtil {\n  /**\n   * Calculate the expected shape when broadcasting 2 tensors\n   * @param a The shape of tensor A. Should be an array of positive integers\n   * @param b The shape of tensor B. Should be an array of positive integers\n   * @param isMatMul Whether the operation is MatMul\n   * @returns The expected shape of the result, or undefined if N/A\n   */\n  static calcShape(\n    adims: readonly number[],\n    bdims: readonly number[],\n    isMatMul = false,\n  ): readonly number[] | undefined {\n    const arank = adims.length;\n    const brank = bdims.length;\n    if (arank === 0) {\n      return bdims;\n    }\n    if (brank === 0) {\n      return adims;\n    }\n    const crank = Math.max(adims.length, bdims.length);\n    const cdims = new Array<number>(crank);\n\n    // calculate the last 2 dimension if it is MatMul\n    if (isMatMul) {\n      if (arank < 2 || brank < 2) {\n        return undefined;\n      }\n      const cShapeMatMul = MatMulUtil.calcMatMulShape(\n        [adims[arank - 2], adims[arank - 1]],\n        [bdims[brank - 2], bdims[brank - 1]],\n      );\n      if (cShapeMatMul === undefined) {\n        return undefined;\n      }\n      [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;\n    }\n\n    for (let i = isMatMul ? 3 : 1; i <= crank; i++) {\n      const aLen = arank - i < 0 ? 1 : adims[arank - i];\n      const bLen = brank - i < 0 ? 1 : bdims[brank - i];\n\n      if (aLen !== bLen && aLen > 1 && bLen > 1) {\n        return undefined;\n      }\n      cdims[crank - i] = Math.max(aLen, bLen);\n    }\n\n    return cdims;\n  }\n\n  /**\n   * Given the indices of a broadcasted tensor, calculate the original indices\n   * @param broadcastedIndices The given indices of the broadcasted tensor.\n   * @param originalShape The original shape of the tensor before broadcas\n   * @returns The calculated indices that maps to the original tensor.\n   */\n  static index(broadcastedIndices: readonly number[], originalShape: readonly number[]): number[] {\n    // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same\n    // length as the broadcasted shape, and for each dimension the index should\n    // not be out of range.\n    const originalIndices = new Array(originalShape.length);\n    BroadcastUtil.fillIndex(broadcastedIndices, originalShape, originalIndices);\n    return originalIndices;\n  }\n\n  /**\n   * Given the indices of a broadcasted tensor, calculate the original indices\n   * @param broadcastedIndices The given indices of the broadcasted tensor.\n   * @param originalShape The original shape of the tensor before broadcast\n   * @param originalIndices The mapping of broadcastedIndices to the originalIndices (output parameter - will be\n   *     mutated).\n   */\n  static fillIndex(broadcastedIndices: readonly number[], originalShape: readonly number[], originalIndices: number[]) {\n    // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same length as the\n    // broadcasted shape, and for each dimension the index should not be out of range.\n    // NOTE 2: we assume the parameter originalIndices has the same length as the originalShape\n    const dimOffset = broadcastedIndices.length - originalShape.length;\n    for (let i = 0; i < originalShape.length; i++) {\n      originalIndices[i] = broadcastedIndices[dimOffset + i] % originalShape[i];\n    }\n  }\n\n  /**\n   * Perform the broadcasting operation on the specific operator\n   * @param a The input tensor A\n   * @param b The input tensor B\n   * @param op The operator lambda function\n   * @param inplace Whether to write the result back to A.\n   * @returns The result tensor, or undefined if input not broadcastable.\n   */\n  static calc(\n    a: Tensor,\n    b: Tensor,\n    op: (a: string | number, b: string | number) => string | number,\n    inplace: boolean,\n    resultType?: Tensor.DataType,\n  ): Tensor | undefined {\n    const outputShape = BroadcastUtil.calcShape(a.dims, b.dims);\n\n    if (outputShape) {\n      if (inplace && !ShapeUtil.areEqual(outputShape, a.dims)) {\n        // B is not broadcastable to A, failed to calculate inplace.\n        return undefined;\n      }\n\n      const size = ShapeUtil.size(outputShape);\n      const c = inplace ? a : new Tensor(outputShape, resultType || a.type);\n\n      // both inputs are scalars\n      if (outputShape.length === 0) {\n        c.set([], op(a.get([]) as number, b.get([]) as number));\n      }\n\n      // atleast one input is a non-scalar\n      else {\n        const outputIndices = new Array<number>(outputShape.length);\n        const originalIndicesA = new Array(a.dims.length);\n        const originalIndicesB = new Array(b.dims.length);\n        let valA: string | number = 0;\n        let valB: string | number = 0;\n        let isAScalar = false;\n        let isBScalar = false;\n        if (a.dims.length === 0) {\n          valA = a.get([]) as number;\n          isAScalar = true;\n        }\n        if (b.dims.length === 0) {\n          valB = b.get([]) as number;\n          isBScalar = true;\n        }\n        let rest: number;\n        for (let i = 0; i < size; i++) {\n          // traversal indices\n          rest = i;\n          for (let j = outputShape.length - 1; j >= 0; j--) {\n            outputIndices[j] = rest % outputShape[j];\n            rest = Math.floor(rest / outputShape[j]);\n          }\n\n          if (!isAScalar) {\n            // map outputIndices (which is actually broadcasted) to the originalIndices\n            BroadcastUtil.fillIndex(outputIndices, a.dims, originalIndicesA);\n            valA = a.get(originalIndicesA) as number;\n          }\n          if (!isBScalar) {\n            BroadcastUtil.fillIndex(outputIndices, b.dims, originalIndicesB);\n            valB = b.get(originalIndicesB) as number;\n          }\n\n          c.set(outputIndices, op(valA, valB));\n        }\n      }\n\n      return c;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Determine if a shape is unidirectional broadcastable to another shape\n   * @param shape The input shape\n   * @param finalShape The desired shape after broadcasting\n   */\n  static isValidBroadcast(shape: readonly number[], finalShape: readonly number[]): boolean {\n    // align shape to the right\n    const inputRank = shape.length;\n    const finalRank = finalShape.length;\n    if (inputRank > finalRank) {\n      return false;\n    }\n    for (let i = 1; i <= inputRank; i++) {\n      if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determine the broadcasted dims in input shape based on the given output shape.\n   * Note that this function only returns the broadcasted dims.\n   * @param inputShape The input shape\n   * @param outputShape The output shape\n   * @returns The broadcasted dims in input shape.\n   */\n  static getBroadcastDims(inputShape: readonly number[], outputShape: readonly number[]): number[] {\n    const inRank = inputShape.length;\n    const dims: number[] = [];\n    for (let i = 0; i < inRank; i++) {\n      const dim = inRank - 1 - i;\n      const a = inputShape[dim] || 1;\n      const b = outputShape[outputShape.length - 1 - i] || 1;\n      if (b > 1 && a === 1) {\n        dims.unshift(dim);\n      }\n    }\n    return dims;\n  }\n}\n\n// copy array helper\n// mimics memcpy as much as possible\nexport function arrayCopyHelper(\n  target: number[] | Tensor.NumberType,\n  source: number[] | Tensor.NumberType,\n  targetIndex: number,\n  sourceIndex: number,\n  blockSize: number,\n) {\n  if (sourceIndex < 0 || sourceIndex >= source.length) {\n    throw new Error('sourceIndex out of bounds');\n  }\n  if (targetIndex < 0 || targetIndex >= target.length) {\n    throw new Error('targetIndex out of bounds');\n  }\n  if (sourceIndex + blockSize > source.length) {\n    throw new Error('source indices to be copied are outside bounds');\n  }\n  if (targetIndex + blockSize > target.length) {\n    throw new Error('target array is too small to hold result');\n  }\n\n  for (let offset = 0; offset < blockSize; offset++) {\n    target[targetIndex + offset] = source[sourceIndex + offset];\n  }\n}\n\nexport class GemmUtil {\n  // will make sure input shapes are compatible for this op\n  // and return back the shape of the output in the form of a tuple\n  // will throw exception if the input shapes are not compatible\n  static getShapeOfGemmResult(\n    leftShape: readonly number[],\n    transLeft: boolean,\n    rightShape: readonly number[],\n    transRight: boolean,\n    biasShape?: readonly number[],\n  ): readonly number[] {\n    if (leftShape.length !== 2 || rightShape.length !== 2) {\n      throw new Error('shape need to be of size 2');\n    }\n\n    let M: number;\n    let K: number;\n    let N: number;\n\n    if (transLeft) {\n      M = leftShape[1];\n      K = leftShape[0];\n    } else {\n      M = leftShape[0];\n      K = leftShape[1];\n    }\n\n    let kDim = -1;\n\n    if (transRight) {\n      N = rightShape[0];\n      kDim = 1;\n    } else {\n      N = rightShape[1];\n      kDim = 0;\n    }\n\n    if (rightShape[kDim] !== K) {\n      throw new Error('dimension mismatch');\n    }\n\n    if (M <= 0 || N <= 0 || K <= 0) {\n      throw new Error('invalid shape specified');\n    }\n\n    if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {\n      throw new Error('gemm: invalid bias shape for broadcast');\n    }\n\n    return [M, N, K];\n  }\n}\n\nexport class ProtoUtil {\n  static tensorDataTypeFromProto(\n    typeProto: onnx.TensorProto.DataType | onnxruntime.experimental.fbs.TensorDataType,\n  ): Tensor.DataType {\n    switch (typeProto) {\n      case onnx.TensorProto.DataType.INT8:\n        return 'int8';\n      case onnx.TensorProto.DataType.UINT8:\n        return 'uint8';\n      case onnx.TensorProto.DataType.BOOL:\n        return 'bool';\n      case onnx.TensorProto.DataType.INT16:\n        return 'int16';\n      case onnx.TensorProto.DataType.UINT16:\n        return 'uint16';\n      case onnx.TensorProto.DataType.INT32:\n        return 'int32';\n      case onnx.TensorProto.DataType.UINT32:\n        return 'uint32';\n      case onnx.TensorProto.DataType.FLOAT:\n        return 'float32';\n      case onnx.TensorProto.DataType.DOUBLE:\n        return 'float64';\n      case onnx.TensorProto.DataType.STRING:\n        return 'string';\n\n      // For INT64/UINT64, reduce their value to 32-bits.\n      // Should throw exception when overflow\n      case onnx.TensorProto.DataType.INT64:\n        return 'int32';\n      case onnx.TensorProto.DataType.UINT64:\n        return 'uint32';\n\n      default:\n        throw new Error(`unsupported data type: ${onnx.TensorProto.DataType[typeProto]}`);\n    }\n  }\n\n  static tensorDataTypeStringToEnum(type: string): onnx.TensorProto.DataType {\n    switch (type) {\n      case 'int8':\n        return onnx.TensorProto.DataType.INT8;\n      case 'uint8':\n        return onnx.TensorProto.DataType.UINT8;\n      case 'bool':\n        return onnx.TensorProto.DataType.BOOL;\n      case 'int16':\n        return onnx.TensorProto.DataType.INT16;\n      case 'uint16':\n        return onnx.TensorProto.DataType.UINT16;\n      case 'int32':\n        return onnx.TensorProto.DataType.INT32;\n      case 'uint32':\n        return onnx.TensorProto.DataType.UINT32;\n      case 'float32':\n        return onnx.TensorProto.DataType.FLOAT;\n      case 'float64':\n        return onnx.TensorProto.DataType.DOUBLE;\n      case 'string':\n        return onnx.TensorProto.DataType.STRING;\n      case 'int64':\n        return onnx.TensorProto.DataType.INT64;\n      case 'uint64':\n        return onnx.TensorProto.DataType.UINT64;\n\n      default:\n        throw new Error(`unsupported data type: ${type}`);\n    }\n  }\n\n  static tensorDimsFromProto(dims: Array<number | Long>): number[] {\n    // get rid of Long type for dims\n    return dims.map((d) => (Long.isLong(d) ? d.toNumber() : d));\n  }\n\n  static tensorValueTypeFromProto(valueType: onnx.TypeProto.ITensor): Graph.ValueType {\n    return {\n      tensorType: ProtoUtil.tensorDataTypeFromProto(valueType.elemType!),\n      shape: { dims: ProtoUtil.tensorDimsFromProto(valueType.shape!.dim!.map((d) => d.dimValue!)) },\n    };\n  }\n\n  static tensorDimsFromORTFormat(tensor: onnxruntime.experimental.fbs.Tensor) {\n    const dims = [];\n    for (let i = 0; i < tensor.dimsLength(); i++) {\n      dims.push(LongUtil.longToNumber(tensor.dims(i)!));\n    }\n    return dims;\n  }\n\n  static tensorAttributesFromORTFormat(node: onnxruntime.experimental.fbs.Node) {\n    const attributes = [];\n    for (let i = 0; i < node.attributesLength(); i++) {\n      attributes.push(node.attributes(i)!);\n    }\n    return attributes;\n  }\n}\n\nexport class LongUtil {\n  // This function is called to get a number from long type of data for attribute, dim, and ir version,\n  // which values are signed integers.\n  // To make it more generic, add an optional parameter to convert to a unsigned number.\n  static longToNumber(n: Long | flatbuffers.Long | number, unsigned?: boolean) {\n    if (Long.isLong(n)) {\n      return n.toNumber();\n    } else if (n instanceof flatbuffers.Long) {\n      return Long.fromValue({ low: n.low, high: n.high, unsigned: unsigned ?? false }).toNumber();\n    }\n    return n;\n  }\n  static isLong(n: unknown) {\n    return Long.isLong(n) || n instanceof flatbuffers.Long;\n  }\n}\n\nexport class ShapeUtil {\n  static size(dims: readonly number[]): number {\n    return ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);\n  }\n\n  // `axis` inclusive\n  static sizeFromDimension(dims: readonly number[], axis: number): number {\n    if (axis < 0 || axis > dims.length) {\n      throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);\n    }\n    return ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);\n  }\n\n  // `axis` exclusive\n  static sizeToDimension(dims: readonly number[], axis: number): number {\n    if (axis < 0 || axis > dims.length) {\n      throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);\n    }\n    return ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);\n  }\n\n  static getSizeFromDimensionRange(dims: readonly number[], start: number, end: number): number {\n    let size = 1;\n    for (let i = start; i < end; i++) {\n      // safety check as this method is called by multiple other methods requiring size.\n      // size cannot be 0 or negative.\n      if (dims[i] <= 0) {\n        throw new Error(\n          // eslint-disable-next-line max-len\n          'cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.',\n        );\n      }\n      size *= dims[i];\n    }\n    return size;\n  }\n\n  static computeStrides(dims: readonly number[]): readonly number[] {\n    const rank = dims.length;\n    if (rank === 0) {\n      return [];\n    } else if (rank === 1) {\n      return [1];\n    }\n    const strides = new Array(rank);\n    strides[rank - 1] = 1;\n    strides[rank - 2] = dims[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * dims[i + 1];\n    }\n    return strides;\n  }\n\n  static transpose(dims: readonly number[]): readonly number[] {\n    const copy = dims.slice();\n    return copy.reverse();\n  }\n\n  static indicesToOffset(indices: readonly number[], strides: readonly number[], axis?: number): number {\n    if (axis === undefined) {\n      axis = indices.length;\n    }\n    let offset = 0;\n    for (let i = 0; i < axis; ++i) {\n      offset += strides[i] * indices[i];\n    }\n    return offset;\n  }\n\n  static offsetToIndices(offset: number, strides: readonly number[]): readonly number[] {\n    const rank = strides.length;\n    if (rank === 0) {\n      return [];\n    } else if (rank === 1) {\n      return [offset * strides[0]];\n    }\n    const indices: number[] = new Array(strides.length);\n    for (let i = 0; i < indices.length - 1; ++i) {\n      indices[i] = Math.floor(offset / strides[i]);\n      offset -= indices[i] * strides[i];\n    }\n    indices[indices.length - 1] = offset;\n    return indices;\n  }\n\n  /**\n   * normailze axis of range [-r, r) into [0, r).\n   */\n  static normalizeAxis(axis: number, tensorRank: number): number {\n    if (axis < -tensorRank && axis >= tensorRank) {\n      throw new Error('unsupported axis for this operation.');\n    }\n    return axis < 0 ? axis + tensorRank : axis;\n  }\n\n  static normalizeAxes(axes: readonly number[], tensorRank: number): number[] {\n    return axes.map((x) => this.normalizeAxis(x, tensorRank));\n  }\n\n  // Increment an index into a tensor (in lexicographic\n  // ordering), wrapping around the specified upper_bound.\n  /**\n   * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.\n   * @param index Given index to increment (Will be mutated)\n   * @param dims The dimensions of the tensor for which the given index corresponds to\n   * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank\n   */\n  static incrementIndex(index: number[], dims: readonly number[], axisToIncrementOn?: number) {\n    if (dims.length === 0 || index.length === 0) {\n      throw new Error('Index incrementing unsupported for scalar Tensor');\n    }\n    if (axisToIncrementOn === undefined) {\n      axisToIncrementOn = dims.length;\n    } else {\n      if (axisToIncrementOn <= 0 || axisToIncrementOn > dims.length) {\n        throw new Error('Incorrect axis to increment on');\n      }\n    }\n\n    for (let k = axisToIncrementOn - 1; k >= 0; --k) {\n      index[k]++;\n      if (index[k] < dims[k]) {\n        break;\n      }\n      index[k] = 0;\n    }\n  }\n\n  /**\n   * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array\n   * Used in Reshape\n   * @param originalDims Original Shape array\n   * @param shapeHints array containing values to compute the new dimensions\n   * For example:\n   * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]\n   * originalDims = [2,2] and shapeHints = [4] will return [4]\n   * originalDims = [2,2] and shapeHints = [5] will throw an exception\n   * https://github.com/onnx/onnx/blob/main/docs/Operators.md#Reshape\n   */\n\n  static calculateReshapedDims(originalDims: readonly number[], shapeHints: ArrayLike<number>): number[] {\n    // reshape to a Scalar Tensor\n    if (shapeHints.length === 0) {\n      if (originalDims.length === 0 || ShapeUtil.size(originalDims) === 1) {\n        return [];\n      } else {\n        throw new Error('cannot reshape to a scalar Tensor');\n      }\n    }\n\n    const nDims = shapeHints.length;\n    const reshapedDims = new Array<number>(nDims);\n    let unknownDimension = -1;\n    let newTensorSize = 1;\n    for (let i = 0; i < nDims; i++) {\n      if (shapeHints[i] < -1) {\n        throw new Error('a dimension in shape hints cannot be less than -1');\n      }\n      if (shapeHints[i] === -1) {\n        if (unknownDimension !== -1) {\n          throw new Error('at most one dimension in shape hints can be -1');\n        }\n        unknownDimension = i;\n      } else {\n        if (shapeHints[i] === 0) {\n          if (i >= originalDims.length) {\n            throw new Error('the dimension with value zero exceeds the dimension size of the input tensor');\n          }\n          reshapedDims[i] = originalDims[i];\n        } else {\n          reshapedDims[i] = shapeHints[i];\n        }\n        newTensorSize *= reshapedDims[i];\n      }\n    }\n\n    const oldTensorSize = ShapeUtil.size(originalDims);\n    if (unknownDimension !== -1) {\n      if (oldTensorSize % newTensorSize !== 0) {\n        throw new Error(\n          `the input tensor cannot be reshaped to the requested shape. Input shape: [${\n            originalDims\n          }] Output shape: [${shapeHints}]`,\n        );\n      }\n      reshapedDims[unknownDimension] = oldTensorSize / newTensorSize;\n    }\n    // validate sizes from originalDims and reshapedDims match\n    else {\n      if (newTensorSize !== oldTensorSize) {\n        throw new Error(\"reshapedDims and originalDims don't have matching sizes\");\n      }\n    }\n    return reshapedDims;\n  }\n\n  /**\n   * Sorts a given array based on the indices in the Perm array\n   * Used in Transpose\n   * @param a Array to be sorted such as dims or strides\n   * @param perm Perm given; if null a will be reversed\n   */\n  static sortBasedOnPerm(a: readonly number[], perm?: readonly number[]): readonly number[] {\n    if (perm) {\n      return perm.map((v) => a[v]);\n    } else {\n      return a.slice().reverse();\n    }\n  }\n\n  /**\n   * Pads a given shape according to the padding values\n   * @param dims shape of the Tensor to be padded\n   * @param pad pad values\n   */\n  static padShape(dims: readonly number[], pad: readonly number[]): readonly number[] {\n    const rank = dims.length;\n    return dims.map((v, i) => v + pad[i] + pad[i + rank]);\n  }\n\n  /**\n   * Determines if the two shapes are identical\n   * @param shape1\n   * @param shape2\n   */\n  static areEqual(shape1: readonly number[], shape2: readonly number[]): boolean {\n    if (shape1.length !== shape2.length) {\n      return false;\n    }\n    return shape1.every((v, i) => v === shape2[i]);\n  }\n\n  /**\n   * Validates if the given `dims` or `shape` is valid in ONNX.js context and returns data size\n   * @param dims - input `dims` that needs to be checked\n   */\n  static validateDimsAndCalcSize(dims: readonly number[]): number {\n    if (dims.length > 6) {\n      throw new TypeError('Only rank 0 to 6 is supported for tensor shape.');\n    }\n    let size = 1;\n    for (const n of dims) {\n      if (!Number.isInteger(n)) {\n        throw new TypeError(`Invalid shape: ${n} is not an integer`);\n      }\n      if (n < 0 || n > 2147483647) {\n        throw new TypeError(`Invalid shape: length ${n} is not allowed`);\n      }\n      size *= n;\n    }\n    return size;\n  }\n\n  /**\n   * Determines the shape of output tensor y = flatten(x, axis)\n   * @param dims - shape of input tensor\n   * @param axis - flatten axis, in the range [-r, r]\n   */\n  static flattenShape(dims: readonly number[], axis: number): readonly number[] {\n    if (axis < 0) {\n      axis += dims.length;\n    }\n    const total = dims.reduce((x, y) => x * y, 1);\n    const right = dims.slice(axis).reduce((x, y) => x * y, 1);\n    const outputDims = [total / right, right];\n\n    return outputDims;\n  }\n\n  /**\n   * Determines the shape of output tensor y = squeeze(x, axes)\n   * @param dims - shape of input tensor\n   * @param axes - squeeze axes\n   */\n  static squeezeShape(dims: readonly number[], axes: readonly number[]): readonly number[] {\n    const outputDims = new Array<number>();\n\n    // sanity check\n    axes = ShapeUtil.normalizeAxes(axes, dims.length);\n\n    for (let i = 0; i < dims.length; i++) {\n      const inSqueezeList = axes.indexOf(i) >= 0;\n      if (inSqueezeList && dims[i] !== 1) {\n        throw new Error('squeeze an axis of size different than 1');\n      }\n\n      if ((axes.length === 0 && dims[i] > 1) || (axes.length > 0 && !inSqueezeList)) {\n        outputDims.push(dims[i]);\n      }\n    }\n\n    return outputDims;\n  }\n\n  /**\n   * Determines the shape of output tensor y = unsqueeze(x, axes)\n   * @param dims - shape of input tensor\n   * @param axes - unsqueeze axes\n   */\n  static unsqueezeShape(dims: readonly number[], axes: readonly number[]): readonly number[] {\n    const outputDims = new Array<number>(dims.length + axes.length);\n\n    // initialize the array elements to 0\n    outputDims.fill(0);\n\n    // set all axes indices to 1 in outputDims and check for duplicates\n    for (let i = 0; i < axes.length; i++) {\n      const axis = ShapeUtil.normalizeAxis(axes[i], outputDims.length);\n      if (axis >= outputDims.length) {\n        throw new Error(\"'axes' has an out of range axis\");\n      }\n      if (outputDims[axis] !== 0) {\n        throw new Error(\"'axes' has a duplicate axis\");\n      }\n\n      outputDims[axis] = 1;\n    }\n\n    // fill in the zero entries of outputDims with the input tensor's shape\n    let inputDimsIterator = 0;\n    for (let i = 0; i < outputDims.length; i++) {\n      if (outputDims[i] === 0) {\n        outputDims[i] = dims[inputDimsIterator++];\n      }\n    }\n\n    // sanity check assertion. 'inputDimsIterator'\n    // should be equal to the length of 'dims'\n    if (inputDimsIterator !== dims.length) {\n      throw new Error('the unsqueezed dimension could not be established');\n    }\n\n    return outputDims;\n  }\n}\n\n// bunch of helper methods that do a variety of math operations\nexport class MathUtil {\n  // y = (x*x) + y\n  static sqr(\n    target: number[] | Tensor.NumberType,\n    source: number[] | Tensor.NumberType,\n    targetIndex: number,\n    sourceIndex: number,\n    blockSize: number,\n  ) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] += Math.pow(source[sourceIndex + offset], 2);\n    }\n  }\n\n  // y = ax + y\n  static axpy(\n    target: number[] | Tensor.NumberType,\n    source: number[] | Tensor.NumberType,\n    targetIndex: number,\n    sourceIndex: number,\n    blockSize: number,\n    alpha: number,\n  ) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] += alpha * source[sourceIndex + offset];\n    }\n  }\n\n  // y = pow(x, b)\n  static powx(\n    target: number[] | Tensor.NumberType,\n    source: number[] | Tensor.NumberType,\n    targetIndex: number,\n    sourceIndex: number,\n    blockSize: number,\n    b: number,\n  ) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] = Math.pow(source[sourceIndex + offset], b);\n    }\n  }\n\n  // y = x * y\n  static mul(\n    target: number[] | Tensor.NumberType,\n    source: number[] | Tensor.NumberType,\n    targetIndex: number,\n    sourceIndex: number,\n    blockSize: number,\n  ) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] = source[sourceIndex + offset] * target[targetIndex + offset];\n    }\n  }\n}\n\nexport class SplitUtil {\n  /**\n   * Calculates new Shapes from existing one and the splits given along the axis provides\n   * @param dims Shape of the Tensor to be splitted into two or more Shapes\n   * @param axis The dimension along which the Tensor will be split\n   * @param splits Offsets for the start of each split\n   */\n  static splitShape(\n    dims: readonly number[],\n    axis: number,\n    split: number[],\n    numOutputs?: number,\n  ): [number[][], number[]] {\n    if (split.length === 0) {\n      if (!numOutputs) {\n        throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");\n      }\n      SplitUtil.determineSplit(dims[axis], numOutputs, split);\n    }\n\n    const shapes: number[][] = [];\n    const offsets = [0];\n    for (let i = 0; i < split.length; ++i) {\n      if (i !== 0) {\n        offsets.push(offsets[i - 1] + split[i - 1]);\n      }\n      const shape = dims.slice();\n      shape[axis] = split[i];\n      shapes.push(shape);\n    }\n    return [shapes, offsets];\n  }\n\n  static determineSplit(numElementsAlongAxis: number, numOutputs: number, split: number[]) {\n    // If 'split' is not specified by the user, we need to partition the number of elements equally among the outputs\n    if (numElementsAlongAxis % numOutputs !== 0) {\n      throw new Error('cannot split tensor to equal sized parts');\n    }\n    for (let i = 0; i < numOutputs; ++i) {\n      split.push(numElementsAlongAxis / numOutputs);\n    }\n  }\n}\n\nexport class ReduceUtil {\n  /**\n   * Perform reduce operations on the specific operator\n   * @param a Input tensor data\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param keepdims If set to true, the axes which are reduced are left in the\n   *    result as dimensions with size one.\n   * @param op1 The operation to be performed on each element in the tensor\n   * @param op2 The operation to be performed between elements in the tensor\n   */\n  static calcReduce(\n    a: Tensor,\n    axes: number[],\n    keepdims: boolean,\n    op1: (b: number) => number,\n    op2: (a: number, b: number) => number,\n  ): Tensor {\n    const dims = a.dims.slice(0);\n    // if axes is not set, perform reduce on all axes\n    if (axes.length === 0) {\n      dims.forEach((_d, ind) => axes.push(ind));\n    }\n    // get a temporary broadcastable output shape\n    const outputDims = ReduceUtil.calcReduceShape(dims, axes, true);\n\n    // loop through the output and calculate result one by one\n    const size = ShapeUtil.size(outputDims);\n    const y = new Tensor(outputDims, a.type);\n    const strides = ShapeUtil.computeStrides(outputDims);\n    const inputStrides = ShapeUtil.computeStrides(dims);\n    const indicesY = new Array(dims.length);\n    for (let i = 0; i < size; i++) {\n      const indices = ShapeUtil.offsetToIndices(i, strides);\n      // map index\n      BroadcastUtil.fillIndex(indices, dims, indicesY);\n      y.set(\n        indices,\n        ReduceUtil.calcReduceByAxis(\n          a.numberData,\n          axes,\n          dims,\n          0,\n          ShapeUtil.indicesToOffset(indicesY, inputStrides),\n          op1,\n          op2,\n        ),\n      );\n    }\n\n    if (keepdims) {\n      return y;\n    } else {\n      // keepdims == 0, calculate the expected shape\n      return new Tensor(\n        ReduceUtil.calcReduceShape(dims, axes, keepdims),\n        y.type,\n        undefined,\n        undefined,\n        y.data,\n        y.dataId,\n      );\n    }\n  }\n\n  /**\n   * Perform reduce operations on the specific operator on specific axes\n   * @param a Input tensor data\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param dims The input dimension.\n   * @param curAxisInd Index in axes specifying the current dimension along\n   *      which the tensor will be reduced\n   * @param pos The current index of element to perform operation\n   * @param op1 The operation to be performed on each element in the tensor\n   * @param op2 The operation to be performed between elements in the tensor\n   */\n  static calcReduceByAxis(\n    input: Tensor.NumberType,\n    axes: number[],\n    dims: number[],\n    curAxisInd: number,\n    pos: number,\n    op1: (b: number) => number,\n    op2: (a: number, b: number) => number,\n  ): number {\n    let res = 0;\n    if (curAxisInd >= axes.length) {\n      return op1(input[pos]);\n    }\n    const axis = axes[curAxisInd];\n    const step = axis >= dims.length ? 1 : ShapeUtil.size(dims.slice(axis + 1));\n    for (let i = 0; i < dims[axis]; i++) {\n      res =\n        i === 0\n          ? ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2)\n          : op2(res, ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2));\n      pos += step;\n    }\n    return res;\n  }\n\n  /**\n   * Calculate the expected shape of a reduce operation\n   * @param dims The input tensor dimension\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param keepdims If set to true, the axes which are reduced are left in the\n   *    result as dimensions with size one.\n   */\n  static calcReduceShape(dims: readonly number[], axes: readonly number[], keepDims: boolean): number[] {\n    const outputDims = dims.slice();\n    for (let i = 0; i < axes.length; i++) {\n      if (keepDims) {\n        outputDims[axes[i]] = 1;\n      } else {\n        outputDims[axes[i]] = 0;\n      }\n    }\n    return outputDims.filter((dim) => dim !== 0);\n  }\n}\n\nexport class PoolConvUtil {\n  /**\n   * Adjust the kernel, strides, pads to correct rank. Set to default value if not present\n   * @param isGlobalOperator If true, perform global pooling.\n   * @param inputDims The input tensor dimension.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param strides Stride along each axis.\n   * @param dilations Dilation along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   */\n  static adjustPoolAttributes(\n    isGlobalOperator: boolean,\n    inputDims: readonly number[],\n    kernelShape: number[],\n    strides: number[],\n    dilations: number[],\n    pads: number[],\n  ) {\n    if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {\n      throw new Error('length of specified kernel shapes should be 2 less than length of input dimensions');\n    }\n\n    if (isGlobalOperator) {\n      // adjust kernel shape to cover the input dims\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        if (dim >= kernelShape.length) {\n          kernelShape.push(inputDims[dim + 2]);\n        } else {\n          kernelShape[dim] = inputDims[dim + 2];\n        }\n      }\n    }\n\n    // adjust strides length to match kernel shape length\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (dim < strides.length) {\n        if (strides[dim] < 0) {\n          throw new Error('strides should be greater than or equal to 1');\n        }\n      } else {\n        strides.push(1);\n      }\n    }\n\n    // adjust dilation value\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (dim < dilations.length) {\n        if (dilations[dim] < 0) {\n          throw new Error('dilations should be greater than or equal to 1');\n        }\n      } else {\n        dilations.push(1);\n      }\n    }\n\n    // adjust pads length to match 2 * kernel shape length\n    for (let dim = 0; dim < kernelShape.length * 2; dim++) {\n      if (dim < pads.length) {\n        if (pads[dim] < 0) {\n          throw new Error('pad should be greater than or equal to 1');\n        }\n      } else {\n        pads.push(0);\n      }\n    }\n\n    // sanity checks for values in kernel shapes and pads\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (kernelShape[dim] <= 0) {\n        throw new Error('kernel shapes need to be greater than 0');\n      }\n\n      if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {\n        throw new Error('pads should be smaller than kernel');\n      }\n    }\n  }\n\n  // adjust pad values based on 'autoPad' attribute\n  static adjustPadsBasedOnAutoPad(\n    inputDims: readonly number[],\n    strides: readonly number[],\n    dilations: readonly number[],\n    kernelShape: readonly number[],\n    pads: number[],\n    autoPad?: string,\n  ) {\n    if (!autoPad) {\n      return;\n    }\n\n    if (pads.length !== 2 * (inputDims.length - 2)) {\n      throw new Error('length of pads should be twice the length of data dimensions');\n    }\n\n    if (strides.length !== inputDims.length - 2) {\n      throw new Error('length of strides should be the length of data dimensions');\n    }\n\n    if (kernelShape.length !== inputDims.length - 2) {\n      throw new Error('length of kernel shapes should be the length of data dimensions');\n    }\n\n    for (let dim = 0; dim < inputDims.length - 2; dim++) {\n      PoolConvUtil.adjustPadAndReturnShape(\n        inputDims[dim + 2],\n        strides[dim],\n        dilations[dim],\n        kernelShape[dim],\n        pads,\n        dim,\n        dim + inputDims.length - 2,\n        autoPad,\n      );\n    }\n  }\n\n  /**\n   * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)\n   * @param isGlobalOperator If true, perform global pooling.\n   * @param inputDims The input tensor dimension. (inputs[0].dims)\n   * @param strides Stride along each axis.\n   * @param dilations Dilation along each axis.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each\n   *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.\n   */\n  static computePoolOutputShape(\n    isGlobalOperator: boolean,\n    inputDims: readonly number[],\n    strides: number[],\n    dilations: number[],\n    kernelShape: number[],\n    pads: number[],\n    autoPad?: string,\n  ): number[] {\n    if (inputDims.length <= 0) {\n      throw new Error('input shape must be of size greater than 0');\n    }\n\n    // Add batch size and number of channels of output\n    const outputDims = [inputDims[0], inputDims[1]];\n\n    PoolConvUtil.computeShapeHelper(\n      isGlobalOperator,\n      inputDims,\n      outputDims,\n      strides,\n      dilations,\n      kernelShape,\n      pads,\n      autoPad,\n    );\n    return outputDims;\n  }\n\n  /**\n   * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)\n   * @param inputDims The input tensor dimension. (inputs[0].dims)\n   * @param filterDims The filter tensor dimension. (inputs[1].dims)\n   * @param strides Stride along each axis.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each\n   *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.\n   */\n  static computeConvOutputShape(\n    inputDims: readonly number[],\n    filterDims: readonly number[],\n    strides: number[],\n    dilations: number[],\n    kernelShape: number[],\n    pads: number[],\n    autoPad?: string,\n  ): number[] {\n    if (inputDims.length <= 0 || filterDims.length <= 0) {\n      throw new Error('invalid input tensor dims or invalid filter tensor dims');\n    }\n\n    // Add batch size and number of channels of output\n    const outputDims = [inputDims[0], filterDims[0]];\n\n    PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);\n    return outputDims;\n  }\n\n  // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels\n  // called by computePoolOutputShape() and computeConvOutputShape()\n  // adjust pads based on 'autoPad' attribute prior to shape computation\n  private static computeShapeHelper(\n    isGlobalOperator: boolean,\n    inputDims: readonly number[],\n    outputDims: number[],\n    strides: readonly number[],\n    dilations: readonly number[],\n    kernelShape: readonly number[],\n    pads: number[],\n    autoPad?: string,\n  ) {\n    if (isGlobalOperator) {\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        outputDims.push(1);\n      }\n    } else {\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        outputDims.push(\n          PoolConvUtil.adjustPadAndReturnShape(\n            inputDims[dim + 2],\n            strides[dim],\n            dilations[dim],\n            kernelShape[dim],\n            pads,\n            dim,\n            dim + inputDims.length - 2,\n            autoPad,\n          ),\n        );\n      }\n    }\n  }\n\n  // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()\n  // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension\n  private static adjustPadAndReturnShape(\n    inSize: number,\n    stride: number,\n    dilation: number,\n    kernel: number,\n    pads: number[],\n    padHeadIndex: number,\n    padTailIndex: number,\n    autoPad?: string,\n  ): number {\n    const dkernel = dilation * (kernel - 1) + 1;\n    if (autoPad && autoPad !== 'NOTSET') {\n      switch (autoPad) {\n        case 'VALID':\n          pads[padHeadIndex] = 0;\n          pads[padTailIndex] = 0;\n          return Math.floor((inSize - dkernel) / stride + 1);\n        case 'SAME_LOWER':\n        case 'SAME_UPPER':\n          if (dilation !== 1) {\n            throw new Error('Dilation not supported for SAME_UPPER or SAME_LOWER');\n          } else {\n            const legacyTargetSize = (inSize + stride - 1) / stride;\n            const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;\n            pads[padHeadIndex] = autoPad === 'SAME_LOWER' ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);\n            pads[padTailIndex] = padNeeded - pads[padHeadIndex];\n            return Math.floor((inSize + padNeeded - kernel) / stride + 1);\n          }\n        default:\n          throw new Error('Unsupported AutoPad type');\n      }\n    } else {\n      return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);\n    }\n  }\n}\n\nexport const MIN_CLIP = -3.4028234663852886e38;\nexport const MAX_CLIP = 3.4028234663852886e38;\n\nexport function decodeUtf8String(buffer: Uint8Array): string {\n  return new TextDecoder().decode(buffer);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Guid } from 'guid-typescript';\nimport Long from 'long';\n\nimport { onnxruntime } from './ort-schema/flatbuffers/ort-generated';\nimport { onnx } from './ort-schema/protobuf/onnx';\nimport { decodeUtf8String, ProtoUtil, ShapeUtil } from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Tensor {\n  export interface DataTypeMap {\n    bool: Uint8Array;\n    float32: Float32Array;\n    float64: Float64Array;\n    string: string[];\n    int8: Int8Array;\n    uint8: Uint8Array;\n    int16: Int16Array;\n    uint16: Uint16Array;\n    int32: Int32Array;\n    uint32: Uint32Array;\n    int64: BigInt64Array;\n  }\n\n  export type DataType = keyof DataTypeMap;\n\n  export type StringType = Tensor.DataTypeMap['string'];\n  export type BooleanType = Tensor.DataTypeMap['bool'];\n  export type IntegerType =\n    | Tensor.DataTypeMap['int8']\n    | Tensor.DataTypeMap['uint8']\n    | Tensor.DataTypeMap['int16']\n    | Tensor.DataTypeMap['uint16']\n    | Tensor.DataTypeMap['int32']\n    | Tensor.DataTypeMap['uint32'];\n  export type FloatType = Tensor.DataTypeMap['float32'] | Tensor.DataTypeMap['float64'];\n  export type NumberType = BooleanType | IntegerType | FloatType;\n\n  export type Id = Guid;\n}\n\ntype TensorData = Tensor.DataTypeMap[Tensor.DataType];\n\ntype DataProvider = (id: Tensor.Id) => TensorData;\ntype AsyncDataProvider = (id: Tensor.Id) => Promise<TensorData>;\n\nexport class Tensor {\n  /**\n   * get the underlying tensor data\n   */\n  get data(): TensorData {\n    if (this.cache === undefined) {\n      const data = this.dataProvider!(this.dataId);\n      if (data.length !== this.size) {\n        throw new Error('Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.');\n      }\n      this.cache = data;\n    }\n    return this.cache;\n  }\n\n  /**\n   * get the underlying string tensor data. Should only use when type is STRING\n   */\n  get stringData() {\n    if (this.type !== 'string') {\n      throw new TypeError('data type is not string');\n    }\n\n    return this.data as Tensor.StringType;\n  }\n\n  /**\n   * get the underlying integer tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,\n   * INT16, INT32, UINT32, BOOL)\n   */\n  get integerData() {\n    switch (this.type) {\n      case 'uint8':\n      case 'int8':\n      case 'uint16':\n      case 'int16':\n      case 'int32':\n      case 'uint32':\n      case 'bool':\n        return this.data as Tensor.IntegerType;\n\n      default:\n        throw new TypeError('data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)');\n    }\n  }\n\n  /**\n   * get the underlying float tensor data. Should only use when type is one of the following: (FLOAT, DOUBLE)\n   */\n  get floatData() {\n    switch (this.type) {\n      case 'float32':\n      case 'float64':\n        return this.data as Tensor.FloatType;\n\n      default:\n        throw new TypeError('data type is not float (float32, float64)');\n    }\n  }\n\n  /**\n   * get the underlying number tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,\n   * INT16, INT32, UINT32, BOOL, FLOAT, DOUBLE)\n   */\n  get numberData() {\n    if (this.type !== 'string') {\n      return this.data as Tensor.NumberType;\n    }\n    throw new TypeError('type cannot be non-number (string)');\n  }\n\n  /**\n   * get value of an element at the given indices\n   */\n  get(indices: readonly number[]): Tensor.DataTypeMap[Tensor.DataType][number] {\n    return this.data[ShapeUtil.indicesToOffset(indices, this.strides)];\n  }\n\n  /**\n   * set value of an element at the given indices\n   */\n  set(indices: readonly number[], value: Tensor.DataTypeMap[Tensor.DataType][number]) {\n    this.data[ShapeUtil.indicesToOffset(indices, this.strides)] = value;\n  }\n\n  /**\n   * get the underlying tensor data asynchronously\n   */\n  async getData(): Promise<TensorData> {\n    if (this.cache === undefined) {\n      this.cache = await this.asyncDataProvider!(this.dataId);\n    }\n    return this.cache;\n  }\n\n  /**\n   * get the number of elements in the tensor\n   */\n  public readonly size: number;\n\n  private _strides: readonly number[];\n  /**\n   * get the strides for each dimension\n   */\n  get strides(): readonly number[] {\n    if (!this._strides) {\n      this._strides = ShapeUtil.computeStrides(this.dims);\n    }\n    return this._strides;\n  }\n\n  constructor(\n    /**\n     * get the dimensions of the tensor\n     */\n    public readonly dims: readonly number[],\n    /**\n     * get the type of the tensor\n     */\n    public readonly type: Tensor.DataType,\n    private dataProvider?: DataProvider,\n    private asyncDataProvider?: AsyncDataProvider,\n    private cache?: TensorData,\n    /**\n     * get the data ID that used to map to a tensor data\n     */\n    public readonly dataId: Guid = Guid.create(),\n  ) {\n    this.size = ShapeUtil.validateDimsAndCalcSize(dims);\n    const size = this.size;\n    const empty = dataProvider === undefined && asyncDataProvider === undefined && cache === undefined;\n\n    if (cache !== undefined) {\n      if (cache.length !== size) {\n        throw new RangeError(\"Input dims doesn't match data length.\");\n      }\n    }\n\n    if (type === 'string') {\n      if (cache !== undefined && (!Array.isArray(cache) || !cache.every((i) => typeof i === 'string'))) {\n        throw new TypeError('cache should be a string array');\n      }\n\n      if (empty) {\n        this.cache = new Array<string>(size);\n      }\n    } else {\n      if (cache !== undefined) {\n        const constructor = dataviewConstructor(type);\n        if (!(cache instanceof constructor)) {\n          throw new TypeError(`cache should be type ${constructor.name}`);\n        }\n      }\n\n      if (empty) {\n        const buf = new ArrayBuffer(size * sizeof(type));\n        this.cache = createView(buf, type);\n      }\n    }\n  }\n\n  /**\n   * Construct new Tensor from a ONNX Tensor object\n   * @param tensorProto the ONNX Tensor\n   */\n  static fromProto(tensorProto: onnx.ITensorProto): Tensor {\n    if (!tensorProto) {\n      throw new Error('cannot construct Value from an empty tensor');\n    }\n    const type = ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType!);\n    const dims = ProtoUtil.tensorDimsFromProto(tensorProto.dims!);\n\n    const value = new Tensor(dims, type);\n\n    if (type === 'string') {\n      // When it's STRING type, the value should always be stored in field\n      // 'stringData'\n      tensorProto.stringData!.forEach((str, i) => {\n        value.data[i] = decodeUtf8String(str);\n      });\n    } else if (\n      tensorProto.rawData &&\n      typeof tensorProto.rawData.byteLength === 'number' &&\n      tensorProto.rawData.byteLength > 0\n    ) {\n      // NOT considering segment for now (IMPORTANT)\n\n      // populate value from rawData\n      const dataDest = value.data;\n      const dataSource = new DataView(\n        tensorProto.rawData.buffer,\n        tensorProto.rawData.byteOffset,\n        tensorProto.rawData.byteLength,\n      );\n      const elementSize = sizeofProto(tensorProto.dataType!);\n      const length = tensorProto.rawData.byteLength / elementSize;\n\n      if (tensorProto.rawData.byteLength % elementSize !== 0) {\n        throw new Error('invalid buffer length');\n      }\n      if (dataDest.length !== length) {\n        throw new Error('buffer length mismatch');\n      }\n\n      for (let i = 0; i < length; i++) {\n        const n = readProto(dataSource, tensorProto.dataType!, i * elementSize);\n        dataDest[i] = n;\n      }\n    } else {\n      // populate value from array\n      let array: Array<number | Long>;\n      switch (tensorProto.dataType) {\n        case onnx.TensorProto.DataType.FLOAT:\n          array = tensorProto.floatData!;\n          break;\n        case onnx.TensorProto.DataType.INT32:\n        case onnx.TensorProto.DataType.INT16:\n        case onnx.TensorProto.DataType.UINT16:\n        case onnx.TensorProto.DataType.INT8:\n        case onnx.TensorProto.DataType.UINT8:\n        case onnx.TensorProto.DataType.BOOL:\n          array = tensorProto.int32Data!;\n          break;\n        case onnx.TensorProto.DataType.INT64:\n          array = tensorProto.int64Data!;\n          break;\n        case onnx.TensorProto.DataType.DOUBLE:\n          array = tensorProto.doubleData!;\n          break;\n        case onnx.TensorProto.DataType.UINT32:\n        case onnx.TensorProto.DataType.UINT64:\n          array = tensorProto.uint64Data!;\n          break;\n        default:\n          // should never run here\n          throw new Error('unspecific error');\n      }\n\n      if (array === null || array === undefined) {\n        throw new Error('failed to populate data from a tensorproto value');\n      }\n\n      const data = value.data;\n      if (data.length !== array.length) {\n        throw new Error('array length mismatch');\n      }\n\n      for (let i = 0; i < array.length; i++) {\n        const element = array[i];\n        if (Long.isLong(element)) {\n          data[i] = longToNumber(element, tensorProto.dataType);\n        } else {\n          data[i] = element;\n        }\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * Construct new Tensor from raw data\n   * @param data the raw data object. Should be a string array for 'string' tensor, and the corresponding typed array\n   * for other types of tensor.\n   * @param dims the dimensions of the tensor\n   * @param type the type of the tensor\n   */\n  static fromData(data: Tensor.DataTypeMap[Tensor.DataType], dims: readonly number[], type: Tensor.DataType) {\n    return new Tensor(dims, type, undefined, undefined, data);\n  }\n\n  static fromOrtTensor(ortTensor: ortFbs.Tensor) {\n    if (!ortTensor) {\n      throw new Error('cannot construct Value from an empty tensor');\n    }\n    const dims = ProtoUtil.tensorDimsFromORTFormat(ortTensor);\n    const type = ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType());\n\n    const value = new Tensor(dims, type);\n\n    if (type === 'string') {\n      // When it's STRING type, the value should always be stored in field\n      // 'stringData'\n      for (let i = 0; i < ortTensor.stringDataLength(); i++) {\n        value.data[i] = ortTensor.stringData(i);\n      }\n    } else if (\n      ortTensor.rawDataArray() &&\n      typeof ortTensor.rawDataLength() === 'number' &&\n      ortTensor.rawDataLength() > 0\n    ) {\n      // NOT considering segment for now (IMPORTANT)\n\n      // populate value from rawData\n      const dataDest = value.data;\n      const dataSource = new DataView(\n        ortTensor.rawDataArray()!.buffer,\n        ortTensor.rawDataArray()!.byteOffset,\n        ortTensor.rawDataLength(),\n      );\n      const elementSize = sizeofProto(ortTensor.dataType());\n      const length = ortTensor.rawDataLength() / elementSize;\n\n      if (ortTensor.rawDataLength() % elementSize !== 0) {\n        throw new Error('invalid buffer length');\n      }\n      if (dataDest.length !== length) {\n        throw new Error('buffer length mismatch');\n      }\n\n      for (let i = 0; i < length; i++) {\n        const n = readProto(dataSource, ortTensor.dataType(), i * elementSize);\n        dataDest[i] = n;\n      }\n    }\n    return value;\n  }\n}\n\nfunction sizeof(type: Tensor.DataType): number {\n  switch (type) {\n    case 'bool':\n    case 'int8':\n    case 'uint8':\n      return 1;\n    case 'int16':\n    case 'uint16':\n      return 2;\n    case 'int32':\n    case 'uint32':\n    case 'float32':\n      return 4;\n    case 'float64':\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${type}`);\n  }\n}\n\nfunction sizeofProto(type: onnx.TensorProto.DataType | ortFbs.TensorDataType): number {\n  switch (type) {\n    case onnx.TensorProto.DataType.UINT8:\n    case onnx.TensorProto.DataType.INT8:\n    case onnx.TensorProto.DataType.BOOL:\n      return 1;\n    case onnx.TensorProto.DataType.UINT16:\n    case onnx.TensorProto.DataType.INT16:\n      return 2;\n    case onnx.TensorProto.DataType.FLOAT:\n    case onnx.TensorProto.DataType.INT32:\n    case onnx.TensorProto.DataType.UINT32:\n      return 4;\n    case onnx.TensorProto.DataType.INT64:\n    case onnx.TensorProto.DataType.DOUBLE:\n    case onnx.TensorProto.DataType.UINT64:\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${onnx.TensorProto.DataType[type]}`);\n  }\n}\n\nfunction createView(dataBuffer: ArrayBuffer, type: Tensor.DataType) {\n  return new (dataviewConstructor(type))(dataBuffer);\n}\n\nfunction dataviewConstructor(type: Tensor.DataType) {\n  switch (type) {\n    case 'bool':\n    case 'uint8':\n      return Uint8Array;\n    case 'int8':\n      return Int8Array;\n    case 'int16':\n      return Int16Array;\n    case 'uint16':\n      return Uint16Array;\n    case 'int32':\n      return Int32Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'int64':\n      return BigInt64Array;\n    case 'float32':\n      return Float32Array;\n    case 'float64':\n      return Float64Array;\n    default:\n      // should never run to here\n      throw new Error('unspecified error');\n  }\n}\n\n// convert a long number to a 32-bit integer (cast-down)\nfunction longToNumber(i: Long, type: onnx.TensorProto.DataType | ortFbs.TensorDataType): number {\n  // INT64, UINT32, UINT64\n  if (type === onnx.TensorProto.DataType.INT64 || type === ortFbs.TensorDataType.INT64) {\n    if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) {\n      throw new TypeError('int64 is not supported');\n    }\n  } else if (\n    type === onnx.TensorProto.DataType.UINT32 ||\n    type === ortFbs.TensorDataType.UINT32 ||\n    type === onnx.TensorProto.DataType.UINT64 ||\n    type === ortFbs.TensorDataType.UINT64\n  ) {\n    if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) {\n      throw new TypeError('uint64 is not supported');\n    }\n  } else {\n    throw new TypeError(`not a LONG type: ${onnx.TensorProto.DataType[type]}`);\n  }\n\n  return i.toNumber();\n}\n\n// read one value from TensorProto\nfunction readProto(\n  view: DataView,\n  type: onnx.TensorProto.DataType | ortFbs.TensorDataType,\n  byteOffset: number,\n): number {\n  switch (type) {\n    case onnx.TensorProto.DataType.BOOL:\n    case onnx.TensorProto.DataType.UINT8:\n      return view.getUint8(byteOffset);\n    case onnx.TensorProto.DataType.INT8:\n      return view.getInt8(byteOffset);\n    case onnx.TensorProto.DataType.UINT16:\n      return view.getUint16(byteOffset, true);\n    case onnx.TensorProto.DataType.INT16:\n      return view.getInt16(byteOffset, true);\n    case onnx.TensorProto.DataType.FLOAT:\n      return view.getFloat32(byteOffset, true);\n    case onnx.TensorProto.DataType.INT32:\n      return view.getInt32(byteOffset, true);\n    case onnx.TensorProto.DataType.UINT32:\n      return view.getUint32(byteOffset, true);\n    case onnx.TensorProto.DataType.INT64:\n      return longToNumber(\n        Long.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), false),\n        type,\n      );\n    case onnx.TensorProto.DataType.DOUBLE:\n      return view.getFloat64(byteOffset, true);\n    case onnx.TensorProto.DataType.UINT64:\n      return longToNumber(\n        Long.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), true),\n        type,\n      );\n    default:\n      throw new Error(`cannot read from DataView for type ${onnx.TensorProto.DataType[type]}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * represent a version irrelevant abstraction of for GLSL source code\n */\nexport interface Glsl {\n  readonly version: string;\n  readonly attribute: string;\n  readonly varyingVertex: string;\n  readonly varyingFrag: string;\n  readonly texture2D: string;\n  readonly output: string;\n  readonly outputDeclaration: string;\n}\n\nconst GLSL_ES_2_0: Glsl = {\n  version: '',\n  attribute: 'attribute',\n  varyingVertex: 'varying',\n  varyingFrag: 'varying',\n  texture2D: 'texture2D',\n  output: 'gl_FragColor',\n  outputDeclaration: '',\n};\nconst GLSL_ES_3_0: Glsl = {\n  version: '#version 300 es',\n  attribute: 'in',\n  varyingVertex: 'out',\n  varyingFrag: 'in',\n  texture2D: 'texture',\n  output: 'outputColor',\n  outputDeclaration: 'out vec4 outputColor;',\n};\n\nexport function getGlsl(version: 1 | 2) {\n  return version === 1 ? GLSL_ES_2_0 : GLSL_ES_3_0;\n}\n\nexport function getVertexShaderSource(version: 1 | 2): string {\n  const glsl = getGlsl(version);\n  return `${glsl.version}\n      precision highp float;\n      ${glsl.attribute} vec3 position;\n      ${glsl.attribute} vec2 textureCoord;\n\n      ${glsl.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`;\n}\n\nexport function getFragShaderPreamble(version: 1 | 2): string {\n  const glsl = getGlsl(version);\n  return `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFrag} vec2 TexCoords;\n    ${glsl.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `;\n}\n\nexport function getDefaultFragShaderMain(version: 1 | 2, outputShapeLength: number): string {\n  const glsl = getGlsl(version);\n  return `\n  void main() {\n    int indices[${outputShapeLength}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${glsl.output} = result;\n  }\n  `;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../tensor';\n\n/**\n * Layout info is used for mapping n-dimensional array to 2D textures\n * The layout is created by the TextureLayoutStrategy based on\n * the Tensor's dimensions and strides\n */\nexport interface TextureLayout {\n  width: number;\n  height: number;\n  /**\n   * specify the number of value that encoded in a single pixel\n   */\n  channels: 1 | 2 | 3 | 4;\n  /**\n   * whether in packed mode or not\n   */\n  isPacked?: boolean;\n  /**\n   * the normalized shape\n   */\n  shape: readonly number[];\n  /**\n   * the stride of each dimensions, calculated according to shape\n   */\n  strides: readonly number[];\n  /**\n   * the original shape(dims) of the corresponding tensor\n   */\n  unpackedShape: readonly number[];\n\n  reversedWH?: boolean;\n}\nexport interface TextureData extends TextureLayout {\n  tensor: Tensor;\n  texture: WebGLTexture;\n}\n\nexport enum TextureType {\n  unpacked, // <-- normal unpacked texture\n  unpackedReversed, // <-- unpacked texture used in old ONNX.js implementation (deprecated)\n  packed, // <-- normal packed texture\n  downloadUint8AsFloat, // <-- ONLY used in texture downloading for iOS devices\n  packedLastDimension, // <-- ONLY used in old ONNX.js Conv implementation for input W (deprecated)\n}\n\nexport interface TensorInfo {\n  id?: Tensor.Id;\n  dims: readonly number[];\n  type: Tensor.DataType;\n  textureType: TextureType;\n}\n\nexport interface ProgramVariable {\n  type: 'float' | 'int';\n  name: string;\n  arrayLength?: number;\n  data: number | number[];\n}\n\n/**\n * A set of metadata of a shader program.\n */\nexport interface ProgramMetadata {\n  /**\n   * the name of the program. used for debugging and profiling\n   */\n  name: string;\n  /**\n   * texture types for each input\n   */\n  inputTypes: TextureType[];\n  /**\n   * names of each input\n   */\n  inputNames: string[];\n  /**\n   * an optional string as a cache hint in the artifact cache\n   */\n  cacheHint?: string;\n}\n\n/**\n * A ProgramInfoLoader allows\n */\nexport interface ProgramInfoLoader extends ProgramMetadata {\n  /**\n   * a function to get the program info\n   */\n  get(): ProgramInfo;\n}\n\n/**\n * A set of data that represent a shader program\n */\nexport interface ProgramInfo extends ProgramMetadata {\n  /**\n   * information of uniform variables\n   */\n  variables?: ProgramVariable[];\n  /**\n   * tensor info for output\n   */\n  output: TensorInfo;\n  /**\n   * the shader's processing source code\n   */\n  shaderSource: string;\n  /**\n   * whether the shader source contains a customized main function implementation\n   */\n  hasMain?: boolean;\n}\n\nexport interface VariableInfo {\n  type: 'float' | 'int';\n  name: string;\n  arrayLength?: number;\n}\n\nexport interface ProgramVariable {\n  type: 'float' | 'int';\n  name: string;\n  arrayLength?: number;\n  data: number | number[];\n}\n\n/**\n * Information of uniforms that shader uses\n */\nexport interface UniformInfo {\n  type: 'sampler2D' | VariableInfo['type'];\n  name: string;\n  arrayLength?: number;\n}\n\nexport interface UniformLocation extends UniformInfo {\n  location: WebGLUniformLocation;\n}\n\n/**\n * Artifact is the result of compilation\n * It does not contain input of output data\n * However anything that could be run as a \"program\"\n */\nexport interface Artifact {\n  programInfo: ProgramInfo;\n  program: WebGLProgram;\n  uniformLocations: UniformLocation[];\n  attribLocations: { position: number; textureCoord: number };\n}\nexport declare namespace Artifact {\n  type UniformLocations = Artifact['uniformLocations'];\n  type AttribLocations = Artifact['attribLocations'];\n}\n\nexport interface UniformData {\n  [name: string]: number | number[];\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { assert } from '../../util';\n/**\n * Given a non RGBA shape calculate the R version\n * It is assumed that the dimensions are multiples of given channels\n * NOTE: it is always the last dim that gets packed.\n * @param unpackedShape original shape to create a packed version from\n */\nexport function getPackedShape(unpackedShape: readonly number[]): readonly number[] {\n  const len = unpackedShape.length;\n  return unpackedShape.slice(0, len - 1).concat(unpackedShape[len - 1] / 4);\n}\n\nexport async function repeatedTry(\n  checkFn: () => boolean,\n  delayFn = (_counter: number) => 0,\n  maxCounter?: number,\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    let tryCount = 0;\n\n    const tryFn = () => {\n      if (checkFn()) {\n        resolve();\n        return;\n      }\n\n      tryCount++;\n\n      const nextBackoff = delayFn(tryCount);\n\n      if (maxCounter != null && tryCount >= maxCounter) {\n        reject();\n        return;\n      }\n      setTimeout(tryFn, nextBackoff);\n    };\n\n    tryFn();\n  });\n}\n\n/**\n * Generates the function name from an input sampler name.\n * @param samplerName Name of the sampler.\n */\nexport function generateShaderFuncNameFromInputSamplerName(samplerName: string): string {\n  assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, () => 'empty string found for sampler name');\n  return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1);\n}\n\n/**\n * Generates the function name from an input sampler name at output coordinates.\n * @param samplerName Name of the sampler.\n */\nexport function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName: string): string {\n  assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, () => 'empty string found for sampler name');\n  return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1) + 'AtOutCoords';\n}\n\n/** Returns a new input shape (a copy) that has a squeezed logical shape. */\nexport function squeezeInputShape(inputShape: readonly number[], squeezedShape: number[]): number[] {\n  // Deep copy.\n  let newInputShape: number[] = JSON.parse(JSON.stringify(inputShape));\n  newInputShape = squeezedShape;\n  return newInputShape;\n}\n\n/** Returns a list of squeezed parameters for shader functions */\nexport function getSqueezedParams(params: string[], keptDims: number[]): string {\n  return keptDims.map((d) => params[d]).join(', ');\n}\n\n/** Returns the data type for different ranks. */\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'int';\n  } else if (rank === 2) {\n    return 'ivec2';\n  } else if (rank === 3) {\n    return 'ivec3';\n  } else if (rank === 4) {\n    return 'ivec4';\n  } else if (rank === 5) {\n    return 'ivec5';\n  } else if (rank === 6) {\n    return 'ivec6';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\nexport function getGlChannels(rank = 6): string[] {\n  return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getGlChannels } from '../utils';\n\nexport function getVecChannels(name: string, rank: number): string[] {\n  return getGlChannels(rank).map((d) => `${name}.${d}`);\n}\n\nexport function getChannels(name: string, rank: number): string[] {\n  if (rank === 1) {\n    return [name];\n  }\n  return getVecChannels(name, rank);\n}\n\nexport function unpackFromChannel(): string {\n  return `\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  `;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, TextureType } from '../types';\nimport { getCoordsDataType } from '../utils';\n\nimport { getChannels } from './packing-utils';\n\nconst packProgramMetadata = {\n  name: 'pack',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpackedReversed],\n};\n\nconst createPackProgramInfo = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfo => {\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  const inputShape = input.dims;\n\n  const inputRank = inputShape.length;\n  // createTextureLayoutFromShape won't change output rank. Need to verify by running tests\n  const outputRank = input.dims.length;\n\n  const coordsDataType = getCoordsDataType(outputRank);\n  const channels = getChannels('rc', outputRank);\n  const setup = getSetup(outputRank, channels, inputShape[inputShape.length - 2], inputShape[inputShape.length - 1]);\n\n  let reversedInputWH;\n  if (inputRank === 0) {\n    reversedInputWH = [1, 1];\n  } else if (inputRank === 1) {\n    reversedInputWH = [inputShape[0], 1];\n  } else {\n    reversedInputWH = [inputShape[outputRank - 1], inputShape[outputRank - 2]];\n  }\n  const outOfBoundsCondition = getOutOfBoundsCondition(outputRank, reversedInputWH, channels);\n  const output = getOutput(inputShape, channels);\n\n  const shaderSource = `\n        void main() {\n          ${coordsDataType} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            ${glsl.output} = vec4(0);\n          } else {\n            ${setup}\n\n            ${glsl.output} = vec4(${output});\n          }\n        }\n      `;\n  return {\n    ...packProgramMetadata,\n    hasMain: true,\n    output: { dims: input.dims, type: input.type, textureType: TextureType.packed },\n    shaderSource,\n  };\n};\n\nexport const createPackProgramInfoLoader = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfoLoader => ({\n  ...packProgramMetadata,\n  get: () => createPackProgramInfo(handler, input),\n});\n\n/**\n * check output coordinate location and return false if it is outside input's width/height boundary\n */\nfunction getOutOfBoundsCondition(rank: number, shape: readonly number[], dims: string[]): string {\n  if (rank === 0) {\n    return 'false';\n  }\n  if (rank === 1) {\n    return `rc > ${shape[0]}`;\n  }\n\n  let cond = '';\n  for (let i = rank - 2; i < rank; i++) {\n    cond += `${dims[i]} >= ${shape[i - rank + 2]}`;\n    if (i < rank - 1) {\n      cond += '||';\n    }\n  }\n\n  return cond;\n}\n\n/**\n * code snippet to sample input texture with output coordinates\n */\nfunction getOutput(shape: readonly number[], dims: string[]): string {\n  const rank = shape.length;\n\n  if (rank === 0) {\n    return 'getA(), 0, 0, 0';\n  }\n\n  if (rank === 1) {\n    return `getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n  }\n\n  const coord00 = 'r, c';\n  const coord01 = 'r, cp1';\n  const coord10 = 'rp1, c';\n  const coord11 = 'rp1, cp1';\n  let D = '';\n  if (rank > 2) {\n    for (let i = 0; i < rank - 2; ++i) {\n      D = D + `${dims[i]},`;\n    }\n  }\n  return `getA(${D}${coord00}),\n          rEdge ? 0. : getA(${D}${coord10}),\n          cEdge ? 0. : getA(${D}${coord01}),\n          rEdge || cEdge ? 0. : getA(${D}${coord11})`;\n}\n\n/**\n * code snippet to setup 4 coordinates and edge conditions\n */\nfunction getSetup(rank: number, dims: string[], rows: number, cols: number): string {\n  if (rank === 0 || rank === 1) {\n    return '';\n  }\n  // rank >= 2 for width+height pack.\n  else {\n    const setup = `\n    int r = ${dims[rank - 2]};\n    int c = ${dims[rank - 1]};\n    int rp1 = ${dims[rank - 2]} + 1;\n    int cp1 = ${dims[rank - 1]} + 1;\n    bool rEdge = rp1 >= ${cols};\n    bool cEdge = cp1 >= ${rows};\n    `;\n    return setup;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { unpackFromChannel } from './packing-utils';\n\nconst createPackedReshape3DProgramMetadata = (outputShape3D: readonly number[]) => ({\n  name: 'Reshape (packed)',\n  inputTypes: [TextureType.packed],\n  inputNames: ['A'],\n  cacheHint: `${outputShape3D}`,\n});\n\nconst createPackedReshape3DProgramInfo = (\n  handler: WebGLInferenceHandler,\n  input3D: Tensor,\n  metadata: ProgramMetadata,\n  outputShape3D: readonly number[],\n): ProgramInfo => {\n  const inputShape3D = input3D.dims as [number, number, number];\n  const squeezedOutputShape = outputShape3D as [number, number, number];\n\n  let mainLoop = '';\n  for (let i = 0; i < 4; i++) {\n    let outputCoords = '';\n    switch (i) {\n      case 0:\n        outputCoords = 'outputCoords = rc;';\n        break;\n      case 1:\n        outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z);';\n        break;\n      case 2:\n        outputCoords = 'outputCoords = ivec3(rc.x, rc.y, rc.z+1);';\n        break;\n      case 3:\n        outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);';\n        break;\n      default:\n        throw new Error();\n    }\n\n    mainLoop += `\n        ${outputCoords}\n        ${i > 0 ? 'if(outputCoords.y < rows && outputCoords.z < cols){' : ''}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${i > 0 ? '}' : ''}\n      `;\n  }\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n\n  const shaderSource = `\n      ${getReshapedInputCoords(inputShape3D)}\n      ${getFlattenedIndexFrom3D(squeezedOutputShape)}\n      ${unpackFromChannel()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${squeezedOutputShape[2]};\n        int cols = ${squeezedOutputShape[1]};\n\n        ${mainLoop}\n        ${glsl.output} = result;\n      }\n    `;\n\n  return {\n    ...metadata,\n    output: { dims: squeezedOutputShape, type: input3D.type, textureType: TextureType.packed },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const createPackedReshape3DProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  input3D: Tensor,\n  outputShape3D: readonly number[],\n): ProgramInfoLoader => {\n  const metadata = createPackedReshape3DProgramMetadata(outputShape3D);\n  return { ...metadata, get: () => createPackedReshape3DProgramInfo(handler, input3D, metadata, outputShape3D) };\n};\n\nexport function processDims3D(shape: ArrayLike<number>): [number, number, number] {\n  if (shape.length === 0) {\n    return [1, 1, 1];\n  }\n  // TODO: squeeze other shapes to 2D case\n  let batch = 1;\n  for (let i = 0; i < shape.length - 2; ++i) {\n    batch *= shape[i];\n  }\n  return [batch, shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\n\n// For packed reshape, we need to re-arrange texel data for output shape.\n// Our pack is designed to pack a 2x2 tile in last h and w dimension, so\n// for the reshaped new tensor, we just need to re-arrange the last h and\n// w dimension. For any shape that is not in 3D, i.e. [batch, W, H], we\n// first convert it to 3D by collapsing other dimension to batch dim, then\n// process with the last two dimensions.\n// Note: we only need the shape tensor to calculate output shape, so the\n// content in shape tensor is never uploaded to GPU. It is always kept in CPU.\n// TODO: optimize the algorithm -- in some cases, if the last two dims are\n// the same between input shape and output shape, the packed reshape can be\n// treated as no-op.\nexport function isReshapeCheap(dims: readonly number[], reshapedDims: readonly number[]) {\n  let isCheapReshape = false;\n  if (dims.length === 0 || reshapedDims.length === 0) {\n    // scalar\n    isCheapReshape = true;\n  } else if (dims.length < 2 || reshapedDims.length < 2) {\n    // 1D\n    isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1];\n  } else {\n    // 2D +\n    isCheapReshape =\n      dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1] &&\n      dims[dims.length - 2] === reshapedDims[reshapedDims.length - 2];\n  }\n\n  return isCheapReshape;\n}\n\nfunction getReshapedInputCoords(shape: [number, number, number]): string {\n  const strides = ShapeUtil.computeStrides(shape);\n  const coords = ['b', 'r', 'c'];\n  const index = 'index';\n  const coordsFromIndexSnippet = strides\n    .map((stride, i) => {\n      const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n      const line2 =\n        i === strides.length - 1\n          ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}`\n          : `index -= ${coords[i]} * ${stride}`;\n      return `${line1}; ${line2};`;\n    })\n    .join('');\n\n  return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(b, r, c);\n    }\n  `;\n}\n\nfunction getFlattenedIndexFrom3D(shape: [number, number, number]): string {\n  const strides = ShapeUtil.computeStrides(shape);\n\n  return `\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${strides[0]} + coords.z * ${strides[1]} + coords.y;\n  }\n`;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { TextureData, TextureType } from '../types';\n\nexport const encodeAsUint8 = (inferenceHandler: WebGLInferenceHandler, input: TextureData): TextureData => {\n  const outputShape = input.shape;\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  /**\n   * https://github.com/tensorflow/tfjs-core/blob/master/src/kernels/webgl/encode_float_gpu.ts\n   */\n  const shaderSource = `\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${glsl.texture2D}(X,TexCoords).r;\n      ${glsl.output} = encodeAsUint8(value);\n    }`;\n  const programInfo = {\n    name: 'Uint8Encode',\n    inputTypes: [TextureType.unpacked],\n    inputNames: ['X'],\n    output: { dims: outputShape, type: input.tensor.type, textureType: TextureType.downloadUint8AsFloat },\n    shaderSource,\n    hasMain: true,\n  };\n  return inferenceHandler.executeProgram(programInfo, [input.tensor]);\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, TextureType } from '../types';\nimport { getCoordsDataType } from '../utils';\n\nimport { getChannels, unpackFromChannel } from './packing-utils';\n\nconst unpackProgramMetadata = {\n  name: 'unpack',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed],\n};\n\nexport const createUnpackProgramInfo = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfo => {\n  const rank = input.dims.length;\n\n  const channels = getChannels('rc', rank);\n  const innerDims = channels.slice(-2);\n  const coordsDataType = getCoordsDataType(rank);\n  const unpackChannel = unpackFromChannel();\n  const isScalar = input.dims.length === 0;\n  const sourceCoords = isScalar ? '' : getSourceCoords(rank, channels);\n  const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  const shaderSource = `\n    ${unpackChannel}\n    void main() {\n      ${coordsDataType} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${sourceCoords});\n\n       ${glsl.output} = vec4(getChannel(packedInput, ${coords}), 0, 0, 0);\n     }\n   `;\n\n  return {\n    ...unpackProgramMetadata,\n    hasMain: true,\n    output: { dims: input.dims, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nexport const createUnpackProgramInfoLoader = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfoLoader => ({\n  ...unpackProgramMetadata,\n  get: () => createUnpackProgramInfo(handler, input),\n});\n\nfunction getSourceCoords(rank: number, dims: string[]): string {\n  if (rank === 1) {\n    return 'rc';\n  }\n\n  let coords = '';\n  for (let i = 0; i < rank; i++) {\n    coords += dims[i];\n    if (i < rank - 1) {\n      coords += ',';\n    }\n  }\n  return coords;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Logger } from '../../instrument';\n\nexport declare namespace Encoder {\n  export interface DataTypeMap {\n    float: Float32Array;\n    byte: Uint8Array;\n    int: Uint32Array;\n  }\n  export type DataType = keyof DataTypeMap;\n  type DataArrayType = DataTypeMap[DataType];\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport const enum EncoderUsage {\n  Default = 0,\n  UploadOnly,\n  Download4BytesAsFloat32,\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/**\n * Abstraction for mapping data types to texture texlets\n * Encoding means how a Float32 is mapped to 1 or 4 channels for each texlet\n * Decoding means how a texlet's channels are mapped to a resulting Float32\n */\nexport interface DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  encode(src: Encoder.DataArrayType, textureSize: number): Encoder.DataArrayType;\n  allocate(size: number): Encoder.DataArrayType;\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Encoder.DataArrayType;\n}\n/**\n * WebGL2 data encoder\n * Uses R32F as the format for texlet\n */\nexport class RedFloat32DataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  constructor(gl: WebGL2RenderingContext, channels = 1) {\n    if (channels === 1) {\n      this.internalFormat = gl.R32F;\n      this.format = gl.RED;\n      this.textureType = gl.FLOAT;\n      this.channelSize = channels;\n    } else if (channels === 4) {\n      this.internalFormat = gl.RGBA32F;\n      this.format = gl.RGBA;\n      this.textureType = gl.FLOAT;\n      this.channelSize = channels;\n    } else {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n  }\n  encode(src: Encoder.DataArrayType, textureSize: number): Encoder.DataArrayType {\n    let result: Float32Array;\n    let source: Float32Array;\n    if (src.constructor !== Float32Array) {\n      Logger.warning('Encoder', 'data was not of type Float32; creating new Float32Array');\n      source = new Float32Array(src);\n    }\n    if (textureSize * this.channelSize > src.length) {\n      Logger.warning('Encoder', 'Source data too small. Allocating larger array');\n      source = src as Float32Array;\n      result = this.allocate(textureSize * this.channelSize) as Float32Array;\n      source.forEach((v, i) => (result[i] = v));\n    } else {\n      source = src as Float32Array;\n      result = source;\n    }\n    return result;\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Float32Array(size * 4);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Float32Array {\n    if (this.channelSize === 1) {\n      const filteredData = (buffer as Float32Array).filter((_value, index) => index % 4 === 0).subarray(0, dataSize);\n      return filteredData;\n    }\n    return buffer.subarray(0, dataSize) as Float32Array;\n  }\n}\n/**\n * Data encoder for WebGL 1 with support for floating point texture\n */\nexport class RGBAFloatDataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  constructor(gl: WebGLRenderingContext, channels = 1, textureType?: number) {\n    if (channels !== 1 && channels !== 4) {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n    this.internalFormat = gl.RGBA;\n    this.format = gl.RGBA;\n    this.channelSize = channels;\n    this.textureType = textureType || gl.FLOAT;\n  }\n  encode(src: Float32Array, textureSize: number): Encoder.DataArrayType {\n    let dest = src;\n    if (this.channelSize === 1) {\n      Logger.verbose('Encoder', 'Exploding into a larger array');\n      dest = this.allocate(textureSize) as Float32Array;\n      src.forEach((v, i) => (dest[i * 4] = v));\n    }\n    return dest;\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Float32Array(size * 4);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Float32Array {\n    if (this.channelSize === 1) {\n      const filteredData = (buffer as Float32Array).filter((_value, index) => index % 4 === 0).subarray(0, dataSize);\n      return filteredData;\n    }\n    return buffer.subarray(0, dataSize) as Float32Array;\n  }\n}\n\nexport class Uint8DataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize = 4;\n  constructor(gl: WebGLRenderingContext, channels = 1) {\n    if (channels === 1) {\n      this.internalFormat = gl.ALPHA;\n      this.format = gl.ALPHA; // not tested\n      this.textureType = gl.UNSIGNED_BYTE;\n      this.channelSize = channels;\n    } else if (channels === 4) {\n      this.internalFormat = gl.RGBA;\n      this.format = gl.RGBA;\n      this.textureType = gl.UNSIGNED_BYTE;\n      this.channelSize = channels;\n    } else {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n  }\n  encode(src: Uint8Array, _textureSize: number): Encoder.DataArrayType {\n    return new Uint8Array(src.buffer, src.byteOffset, src.byteLength);\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Uint8Array(size * this.channelSize);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Uint8Array {\n    if (buffer instanceof Uint8Array) {\n      return buffer.subarray(0, dataSize);\n    }\n    throw new Error(`Invalid array type: ${buffer.constructor}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ShapeUtil } from '../../util';\n\nimport { TextureLayoutStrategy, WidthHeightPrefs } from './texture-layout-strategy';\nimport { TextureLayout, TextureType } from './types';\n\nexport const createTextureLayoutFromTextureType = (\n  textureLayoutStrategy: TextureLayoutStrategy,\n  shape: readonly number[],\n  textureType: TextureType,\n): TextureLayout => {\n  const channel = textureType === TextureType.unpacked || textureType === TextureType.unpackedReversed ? 1 : 4;\n  const isPacked = textureType === TextureType.packed;\n  const reverseWH = textureType === TextureType.unpackedReversed || textureType === TextureType.packed;\n  const breakAxis = textureType === TextureType.packedLastDimension ? shape.length - 1 : undefined;\n  const unpackedShape =\n    textureType === TextureType.packedLastDimension\n      ? shape.map((d, i) => (i === shape.length - 1 ? d * 4 : d))\n      : undefined;\n  return createTextureLayoutFromShape(textureLayoutStrategy, shape, channel, unpackedShape, {\n    isPacked,\n    reverseWH,\n    breakAxis,\n  });\n};\n\nexport const calculateTextureWidthAndHeight = (\n  textureLayoutStrategy: TextureLayoutStrategy,\n  shape: readonly number[],\n  textureType: TextureType,\n): [number, number] => {\n  const layout = createTextureLayoutFromTextureType(textureLayoutStrategy, shape, textureType);\n  return [layout.width, layout.height];\n};\n\n/**\n * Create a TextureLayout object from shape.\n */\nexport const createTextureLayoutFromShape = (\n  textureLayoutStrategy: TextureLayoutStrategy,\n  shape: readonly number[],\n  channels: 1 | 4 = 1,\n  unpackedShape?: readonly number[],\n  prefs?: WidthHeightPrefs,\n): TextureLayout => {\n  const isPacked = !!(prefs && prefs.isPacked);\n  const [width, height] = textureLayoutStrategy.computeTextureWH(isPacked ? unpackedShape || shape : shape, prefs);\n  const rank = shape.length;\n  let inferredDims = shape.slice(0);\n  if (rank === 0) {\n    inferredDims = [1];\n  }\n  if (channels === 1) {\n    // unpackedShape will take `shape` and not `inferredDims` so as to create a scalar Tensor if need be\n    unpackedShape = shape;\n  } else if (isPacked) {\n    if (channels !== 4) {\n      throw new Error('a packed texture must be 4-channel');\n    }\n    unpackedShape = shape;\n    if (rank > 0) {\n      inferredDims[rank - 1] = Math.ceil(inferredDims[rank - 1] / 2);\n    }\n    if (rank > 1) {\n      inferredDims[rank - 2] = Math.ceil(inferredDims[rank - 2] / 2);\n    }\n  } else if (!unpackedShape) {\n    throw new Error('Unpacked shape is needed when using channels > 1');\n  }\n  return {\n    width,\n    height,\n    channels,\n    isPacked,\n    shape: inferredDims,\n    strides: ShapeUtil.computeStrides(inferredDims),\n    unpackedShape,\n    reversedWH: prefs && prefs.reverseWH,\n  };\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceHandler } from '../../backend';\nimport { Logger } from '../../instrument';\nimport { Tensor } from '../../tensor';\nimport { ShapeUtil } from '../../util';\n\nimport { createPackProgramInfoLoader } from './ops/pack';\nimport { createPackedReshape3DProgramInfoLoader, isReshapeCheap, processDims3D } from './ops/reshape-packed';\nimport { encodeAsUint8 } from './ops/uint8-encode';\nimport { createUnpackProgramInfoLoader } from './ops/unpack';\nimport { WebGLSessionHandler } from './session-handler';\nimport { EncoderUsage } from './texture-data-encoder';\nimport {\n  calculateTextureWidthAndHeight,\n  createTextureLayoutFromShape,\n  createTextureLayoutFromTextureType,\n} from './texture-layout';\nimport { Artifact, ProgramInfo, ProgramInfoLoader, TextureData, TextureLayout, TextureType } from './types';\n\nconst getProgramInfoUniqueKey = (\n  programInfo: ProgramInfo | ProgramInfoLoader,\n  inputTextureDatas: TextureData[],\n): string => {\n  const inputs = inputTextureDatas\n    .map((texture) => `${texture.unpackedShape.join(',')};${texture.width}x${texture.height}`)\n    .join('_');\n  let key = programInfo.name;\n  if (programInfo.cacheHint) {\n    key += '[' + programInfo.cacheHint + ']';\n  }\n  key += ':' + inputs;\n  return key;\n};\n\nexport class WebGLInferenceHandler implements InferenceHandler {\n  private packedTextureDataCache: Map<Tensor.Id, TextureData>;\n  private unpackedTextureDataCache: Map<Tensor.Id, TextureData>;\n  constructor(public session: WebGLSessionHandler) {\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache = new Map();\n  }\n\n  /**\n   * @returns [width, height]\n   */\n  calculateTextureWidthAndHeight(shape: readonly number[], textureType: TextureType): [number, number] {\n    return calculateTextureWidthAndHeight(this.session.layoutStrategy, shape, textureType);\n  }\n\n  executeProgram(program: ProgramInfo | ProgramInfoLoader, inputs: readonly Tensor[]): TextureData {\n    if (inputs.length < program.inputNames.length) {\n      throw new Error(`Input size mustn't be less than ${program.inputNames.length}.`);\n    }\n    if (program.inputNames.length !== program.inputTypes.length) {\n      throw new Error('input names size does not match input types');\n    }\n\n    // create texture info for input\n    const inputTextureDatas: TextureData[] = [];\n    for (let i = 0; i < program.inputNames.length; ++i) {\n      inputTextureDatas[i] = this.getOrCreateTextureData(inputs[i], program.inputTypes[i]);\n    }\n\n    const key = getProgramInfoUniqueKey(program, inputTextureDatas);\n    let artifact = this.session.programManager.getArtifact(key);\n    const programInfo = artifact\n      ? artifact.programInfo\n      : typeof (program as ProgramInfoLoader).get === 'function'\n        ? (program as ProgramInfoLoader).get()\n        : (program as ProgramInfo);\n\n    // create texture info for output\n    const outputTextureLayout = createTextureLayoutFromTextureType(\n      this.session.layoutStrategy,\n      programInfo.output.dims,\n      programInfo.output.textureType,\n    );\n    const outputTextureData = this.createTextureData(outputTextureLayout, programInfo.output.type);\n\n    if (!artifact) {\n      artifact = this.session.programManager.build(programInfo, inputTextureDatas, outputTextureData);\n      this.session.programManager.setArtifact(key, artifact);\n    }\n\n    this.runProgram(artifact, inputTextureDatas, outputTextureData);\n    return outputTextureData;\n  }\n\n  run(program: ProgramInfoLoader, inputs: readonly Tensor[]): Tensor {\n    const outputTextureData = this.executeProgram(program, inputs);\n    return outputTextureData.tensor;\n  }\n\n  private runProgram(artifact: Artifact, inputs: TextureData[], output: TextureData): void {\n    // input should match\n    for (let i = 0; i < inputs.length; ++i) {\n      if (!!inputs[i].isPacked !== (artifact.programInfo.inputTypes[i] === TextureType.packed)) {\n        throw new Error(`input[${i}] property packed inconsistent`);\n      }\n    }\n\n    // output should match\n    if (!!output.isPacked !== (artifact.programInfo.output.textureType === TextureType.packed)) {\n      throw new Error('output property packed inconsistent');\n    }\n\n    this.session.programManager.run(artifact, inputs, output);\n  }\n\n  /**\n   * Create a TextureData object from a tensor.\n   * Usage = EncoderUsage.UploadOnly.\n   * If a related texture data is found in cache, returns it;\n   * Otherwise:\n   *   Creates a new texture layout if not provided;\n   *   Creates WebGLTexture with the layout;\n   *   Upload tensor data to the texture;\n   *   Creates a texture data object associated with the given tensor.\n   * @param tensor the tensor with data to upload\n   */\n  private getOrCreateTextureData(tensor: Tensor, textureType: TextureType) {\n    let td = this.getTextureData(tensor.dataId, textureType === TextureType.packed);\n\n    if (!td) {\n      // check if we have texture data in different type\n      td = this.getTextureData(tensor.dataId, textureType !== TextureType.packed);\n      if (td) {\n        if (textureType === TextureType.packed) {\n          return this.pack(td);\n        } else {\n          return this.unpack(td);\n        }\n      }\n    }\n\n    if (!td) {\n      const layout = createTextureLayoutFromTextureType(this.session.layoutStrategy, tensor.dims, textureType);\n\n      if (textureType === TextureType.packedLastDimension) {\n        const group = 1;\n        const channels = 4;\n        const shape = tensor.dims;\n        if (shape.length === 4) {\n          // pre-processing for kernel data of Conv.\n          //\n          // TODO: currently this is a hacking to overwrite Conv's weight. The correct way to do this should be:\n          // 1. implement texture based const-folding\n          // 2. create a WebGL program \"preprocessConvWeight\" to do the same work as below\n          // 3. run the program before dotProduct.\n          //\n          const adjustedKernelShape = [shape[0], Math.ceil((shape[1] * shape[2] * shape[3]) / channels)];\n          const adjustedLayout = createTextureLayoutFromTextureType(\n            this.session.layoutStrategy,\n            adjustedKernelShape,\n            textureType,\n          );\n          let buffer = tensor.numberData;\n          if ((shape[1] * shape[2] * shape[3]) % channels !== 0) {\n            const numFeatureMaps = shape[0];\n            const oldRowSize = shape[1] * shape[2] * shape[3];\n            const newRowSize = Math.ceil((oldRowSize * group) / channels) * channels;\n            const newSize = numFeatureMaps * newRowSize;\n            buffer = new Float32Array(newSize);\n            for (let f = 0; f < numFeatureMaps; ++f) {\n              const oldOffset = f * oldRowSize;\n              const newOffset = f * newRowSize + (f % group) * oldRowSize;\n              buffer.set(tensor.numberData.subarray(oldOffset, oldOffset + oldRowSize), newOffset);\n            }\n          }\n          return this.createTextureData(adjustedLayout, tensor.type, buffer, tensor, EncoderUsage.UploadOnly);\n        }\n      }\n\n      if (textureType === TextureType.packed) {\n        const unpackedTextureLayout = createTextureLayoutFromShape(this.session.layoutStrategy, tensor.dims, 1, [], {\n          reverseWH: true,\n        });\n        const unpackedTextureData = this.createTextureData(\n          unpackedTextureLayout,\n          tensor.type,\n          tensor.numberData,\n          tensor,\n          EncoderUsage.UploadOnly,\n        );\n        td = this.pack(unpackedTextureData);\n      } else {\n        td = this.createTextureData(layout, tensor.type, tensor.numberData, tensor, EncoderUsage.UploadOnly);\n      }\n    }\n    return td;\n  }\n\n  /**\n   * Create a TextureData object using the given data and bind to the given tensor.\n   * Usage = EncoderUsage.UploadOnly.\n   * NOTE: this function is a hack for Conv implementation. should remove this function, after rewriting Conv\n   * implementation by Graph.Transformer\n   * @param dataType the tensor data type\n   * @param data the actual data to upload\n   * @param tensor the tensor to bind. tensor's data is ignored.\n   */\n  createTextureDataFromLayoutBindTensor(\n    layout: TextureLayout,\n    dataType: Tensor.DataType,\n    data: Tensor.NumberType,\n    tensor: Tensor,\n  ): TextureData {\n    return this.createTextureData(layout, dataType, data, tensor, EncoderUsage.UploadOnly);\n  }\n\n  private createTextureData(\n    layout: TextureLayout,\n    dataType: Tensor.DataType,\n    data?: Tensor.NumberType,\n    tensor?: Tensor,\n    usage?: EncoderUsage,\n  ): TextureData {\n    Logger.verbose('InferenceHandler', `Creating TextureData: layout:[${JSON.stringify(layout)}]`);\n    const texture = this.session.textureManager.createTextureFromLayout(dataType, layout, data, usage);\n    return this.createTextureDataFromTexture(layout, dataType, texture, tensor);\n  }\n\n  reshapeUnpacked(input: Tensor, reshapedDims: readonly number[]): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.unpacked);\n    const newTextureLayout: TextureLayout = {\n      channels: inputTD.channels,\n      height: inputTD.height,\n      width: inputTD.width,\n      // handle reshaping into scalar Tensors\n      shape: reshapedDims.length !== 0 ? reshapedDims : [1],\n      strides: ShapeUtil.computeStrides(reshapedDims),\n      unpackedShape: reshapedDims,\n    };\n    const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);\n    return newTextureData.tensor;\n  }\n\n  reshapePacked(input: Tensor, reshapedDims: readonly number[]): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.packed);\n\n    // check if the reshape is 'cheap'\n    if (isReshapeCheap(input.dims, reshapedDims)) {\n      const newTextureLayout: TextureLayout = {\n        channels: inputTD.channels,\n        height: inputTD.height,\n        width: inputTD.width,\n        // handle reshaping into scalar Tensors\n        shape: reshapedDims.length !== 0 ? reshapedDims : [1],\n        strides: ShapeUtil.computeStrides(reshapedDims),\n        unpackedShape: reshapedDims,\n        isPacked: true,\n      };\n      const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);\n      return newTextureData.tensor;\n    }\n\n    const squeezedInputShape = processDims3D(input.dims);\n    const squeezedOutputShape = processDims3D(reshapedDims);\n\n    const squeezedInputTensor = this.reshapePacked(input, squeezedInputShape);\n    const squeezedOutputTensor = this.run(\n      createPackedReshape3DProgramInfoLoader(this, squeezedInputTensor, squeezedOutputShape),\n      [squeezedInputTensor],\n    );\n    const outputTensor = this.reshapePacked(squeezedOutputTensor, reshapedDims);\n    return outputTensor;\n  }\n\n  cast(input: Tensor, type: Tensor.DataType): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.unpacked);\n    const newTextureData = this.createTextureDataFromTexture(inputTD as TextureLayout, type, inputTD.texture);\n    return newTextureData.tensor;\n  }\n\n  private createTextureDataFromTexture(\n    layout: TextureLayout,\n    dataType: Tensor.DataType,\n    texture: WebGLTexture,\n    tensor?: Tensor,\n    tensorId?: Tensor.Id,\n  ) {\n    const textureData: TextureData = {\n      ...layout,\n      tensor:\n        tensor ||\n        new Tensor(\n          layout.unpackedShape,\n          dataType,\n          (_id: Tensor.Id) => this.readTexture(textureData),\n          async (_id: Tensor.Id) => this.readTextureAsync(textureData),\n          undefined,\n          tensorId,\n        ),\n      texture,\n    };\n    this.setTextureData(textureData.tensor.dataId, textureData, layout.isPacked);\n    return textureData;\n  }\n\n  private getTextureData(tensorId: Tensor.Id, isPacked = false): TextureData | undefined {\n    return this.session.isInitializer(tensorId)\n      ? this.session.getTextureData(tensorId, isPacked)\n      : isPacked\n        ? this.packedTextureDataCache.get(tensorId)\n        : this.unpackedTextureDataCache.get(tensorId);\n  }\n  setTextureData(tensorId: Tensor.Id, td: TextureData, isPacked = false): void {\n    if (this.session.isInitializer(tensorId)) {\n      this.session.setTextureData(tensorId, td, isPacked);\n    } else {\n      (isPacked ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(tensorId, td);\n    }\n  }\n  isTextureLayoutCached(tensor: Tensor, isPacked = false): boolean {\n    return !!this.getTextureData(tensor.dataId, isPacked);\n  }\n\n  dispose(): void {\n    this.session.textureManager.clearActiveTextures();\n    this.packedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));\n    this.unpackedTextureDataCache = new Map();\n  }\n\n  readTexture(textureData: TextureData): Tensor.NumberType {\n    if (textureData.isPacked) {\n      return this.readTexture(this.unpack(textureData));\n    }\n    if (!this.session.backend.glContext.isFloat32DownloadSupported) {\n      return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));\n    }\n    return this.session.textureManager.readTexture(textureData, textureData.tensor.type, textureData.channels);\n  }\n\n  async readTextureAsync(textureData: TextureData): Promise<Tensor.NumberType> {\n    if (textureData.isPacked) {\n      return this.readTextureAsync(this.unpack(textureData));\n    }\n    if (!this.session.backend.glContext.isFloat32DownloadSupported) {\n      return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));\n    }\n    return this.session.textureManager.readTextureAsync(textureData, textureData.tensor.type, textureData.channels);\n  }\n\n  pack(input: TextureData): TextureData {\n    const outputTextureData = this.executeProgram(createPackProgramInfoLoader(this, input.tensor), [input.tensor]);\n    return outputTextureData;\n  }\n\n  unpack(input: TextureData): TextureData {\n    const outputTextureData = this.executeProgram(createUnpackProgramInfoLoader(this, input.tensor), [input.tensor]);\n    return outputTextureData;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nclass AttributeWithCacheKeyImpl {\n  constructor(attribute: Record<string, unknown>) {\n    Object.assign(this, attribute);\n  }\n\n  private key: string;\n  public get cacheKey(): string {\n    if (!this.key) {\n      this.key = Object.getOwnPropertyNames(this)\n        .sort()\n        .map((name) => `${(this as Record<string, unknown>)[name]}`)\n        .join(';');\n    }\n    return this.key;\n  }\n}\n\nexport interface AttributeWithCacheKey {\n  readonly cacheKey: string;\n}\n\nexport const createAttributeWithCacheKey = <T extends Record<string, unknown>>(\n  attribute: T,\n): T & AttributeWithCacheKey => new AttributeWithCacheKeyImpl(attribute) as unknown as T & AttributeWithCacheKey;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface BatchNormalizationAttributes extends AttributeWithCacheKey {\n  epsilon: number;\n  momentum: number;\n  spatial: number;\n}\n\nconst batchNormalizationProgramMetadata = {\n  name: 'BatchNormalization',\n  inputNames: ['A', 'Scale', 'B', 'Mean', 'Variance'],\n  inputTypes: [\n    TextureType.unpacked,\n    TextureType.unpacked,\n    TextureType.unpacked,\n    TextureType.unpacked,\n    TextureType.unpacked,\n  ],\n};\n\nexport const batchNormalization: OperatorImplementation<BatchNormalizationAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: BatchNormalizationAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(\n    {\n      ...batchNormalizationProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createBatchNormalizationProgramInfo(inferenceHandler, inputs, attributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseBatchNormalizationAttributes: OperatorInitialization<BatchNormalizationAttributes> = (\n  node: Graph.Node,\n): BatchNormalizationAttributes => {\n  const epsilon = node.attributes.getFloat('epsilon', 1e-5);\n  const momentum = node.attributes.getFloat('momentum', 0.9);\n  const spatial = node.attributes.getInt('spatial', 1);\n  return createAttributeWithCacheKey({ epsilon, momentum, spatial });\n};\n\nconst createBatchNormalizationProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: BatchNormalizationAttributes,\n): ProgramInfo => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const rank = inputs[0].dims.length;\n  const [scaleWidth, scaleHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    inputs[1].dims,\n    TextureType.unpacked,\n  );\n  const shaderSource = `\n  float process(int[${rank}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${scaleWidth}, ${scaleHeight});\n    float scale = getColorAsFloat(${glsl.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${glsl.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${glsl.texture2D}(Variance, position));\n    float b = getColorAsFloat(${glsl.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${attributes.epsilon})) ) + b;\n  }`;\n  return {\n    ...batchNormalizationProgramMetadata,\n    output: { dims: inputs[0].dims, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 5) {\n    throw new Error('BatchNormalization requires 5 inputs.');\n  }\n\n  const X = inputs[0];\n  const scale = inputs[1];\n  const B = inputs[2];\n  const mean = inputs[3];\n  const var_ = inputs[4];\n\n  // input should atleast have three dimensions - N,C,dim1,...,dimn\n  // other inputs can have only one dimensions\n  if (\n    X.dims.length < 3 ||\n    scale.dims.length !== 1 ||\n    B.dims.length !== 1 ||\n    mean.dims.length !== 1 ||\n    var_.dims.length !== 1\n  ) {\n    throw new Error('invalid input shape.');\n  }\n  if (\n    scale.dims[0] !== X.dims[1] ||\n    B.dims[0] !== X.dims[1] ||\n    mean.dims[0] !== X.dims[1] ||\n    var_.dims[0] !== X.dims[1]\n  ) {\n    throw new Error('invalid input shape.');\n  }\n  if (\n    (X.type !== 'float32' && X.type !== 'float64') ||\n    (scale.type !== 'float32' && scale.type !== 'float64') ||\n    (B.type !== 'float32' && B.type !== 'float64') ||\n    (mean.type !== 'float32' && mean.type !== 'float64') ||\n    (var_.type !== 'float32' && var_.type !== 'float64')\n  ) {\n    throw new Error('invalid input tensor types.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ProgramInfo, TextureLayout } from './types';\nimport { WebGLContext } from './webgl-context';\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum FunctionType {\n  ValueBased,\n  Positional,\n}\nexport interface GlslFunction<T extends FunctionType> {\n  body: string;\n  name: string;\n  type: T;\n}\nexport type GlslValueFunction = GlslFunction<FunctionType.ValueBased>;\nexport interface GlslPositionalFunction extends GlslFunction<FunctionType.Positional> {\n  inputShape: readonly number[];\n  outputShape: readonly number[];\n}\n\nexport class GlslContext {\n  constructor(\n    public glContext: WebGLContext,\n    public programInfo: ProgramInfo,\n    public inputTextureLayouts: TextureLayout[],\n    public outputTextureLayout: TextureLayout,\n  ) {}\n}\nexport abstract class GlslLib {\n  constructor(public context: GlslContext) {}\n  abstract getFunctions(): { [name: string]: GlslLibRoutine };\n  abstract getCustomTypes(): { [name: string]: string };\n}\n\n// abstraction to represent a GLSL library routine and it's dependencies\nexport class GlslLibRoutine {\n  constructor(\n    public routineBody: string,\n    public dependencies?: string[],\n  ) {}\n}\n\n// abstraction to represent a GLSL library routine and it's dependencies AS GRAPH Nodes\n// this level of abstraction is used to topologically sort routines before fragment shade inclusion\nexport class GlslLibRoutineNode {\n  dependencies: GlslLibRoutineNode[];\n  routineBody: string;\n  constructor(\n    public name: string,\n    routineBody?: string,\n    dependencies?: GlslLibRoutineNode[],\n  ) {\n    if (dependencies) {\n      this.dependencies = dependencies;\n    } else {\n      this.dependencies = [];\n    }\n\n    if (routineBody) {\n      this.routineBody = routineBody;\n    }\n  }\n  addDependency(node: GlslLibRoutineNode) {\n    if (node) {\n      this.dependencies.push(node);\n    }\n  }\n}\n\n// topologically sort GLSL library routines (graph nodes abstraction) before shader script inclusion\nexport class TopologicalSortGlslRoutines {\n  static returnOrderedNodes(nodes: GlslLibRoutineNode[]): GlslLibRoutineNode[] {\n    if (!nodes || nodes.length === 0) {\n      return [];\n    }\n\n    if (nodes.length === 1) {\n      return nodes;\n    }\n\n    const cycleCheck = new Set<string>();\n    const alreadyTraversed = new Set<string>();\n    const result = new Array<GlslLibRoutineNode>();\n\n    this.createOrderedNodes(nodes, cycleCheck, alreadyTraversed, result);\n    return result;\n  }\n\n  private static createOrderedNodes(\n    graphNodes: GlslLibRoutineNode[],\n    cycleCheck: Set<string>,\n    alreadyTraversed: Set<string>,\n    result: GlslLibRoutineNode[],\n  ) {\n    for (let i = 0; i < graphNodes.length; ++i) {\n      this.dfsTraverse(graphNodes[i], cycleCheck, alreadyTraversed, result);\n    }\n  }\n\n  private static dfsTraverse(\n    root: GlslLibRoutineNode,\n    cycleCheck: Set<string>,\n    alreadyTraversed: Set<string>,\n    result: GlslLibRoutineNode[],\n  ) {\n    // if this root has already been traversed return\n    if (!root || alreadyTraversed.has(root.name)) {\n      return;\n    }\n\n    // cyclic dependency has been detected\n    if (cycleCheck.has(root.name)) {\n      throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");\n    }\n\n    // hold this node to detect cycles if any\n    cycleCheck.add(root.name);\n\n    // traverse children in a dfs fashion\n    const dependencies = root.dependencies;\n    if (dependencies && dependencies.length > 0) {\n      for (let i = 0; i < dependencies.length; ++i) {\n        this.dfsTraverse(dependencies[i], cycleCheck, alreadyTraversed, result);\n      }\n    }\n\n    // add to result holder\n    result.push(root);\n\n    // mark this node as traversed so that we don't traverse from this again\n    alreadyTraversed.add(root.name);\n\n    // release the hold\n    cycleCheck.delete(root.name);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { BroadcastUtil, ShapeUtil } from '../../../util';\nimport { FunctionType, GlslValueFunction } from '../glsl-definitions';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, TextureType } from '../types';\n\nexport function glslAdd(): GlslValueFunction {\n  const name = 'add_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslDiv(): GlslValueFunction {\n  const name = 'div_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslMul(): GlslValueFunction {\n  const name = 'mul_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslSub(): GlslValueFunction {\n  const name = 'sub_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslEqual(): GlslValueFunction {\n  const name = 'equal_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslGreater(): GlslValueFunction {\n  const name = 'greater_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslLess(): GlslValueFunction {\n  const name = 'less_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslAnd(): GlslValueFunction {\n  const name = 'and_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslOr(): GlslValueFunction {\n  const name = 'or_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslXor(): GlslValueFunction {\n  const name = 'xor_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslPow(): GlslValueFunction {\n  return glslBuiltinBinary('pow');\n}\nexport function glslPRelu(): GlslValueFunction {\n  const name = 'prelu_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\n\nfunction glslBuiltinBinary(fname: string): GlslValueFunction {\n  const name = `${fname}_`;\n  const body = `\n  float ${name}(float a, float b) {\n    return ${fname}(a, b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return ${fname}(v1, v2);\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\n\nconst createBinaryProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  glslFunc: GlslValueFunction,\n  outputTensorType: Tensor.DataType = inputs[0].type,\n  cacheKey?: string,\n): ProgramInfoLoader => {\n  const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n  return {\n    name: glslFunc.name,\n    inputNames: ['A', 'B'],\n    inputTypes: [textureType, textureType],\n    cacheHint: cacheKey,\n    get: () => createBinaryProgramInfo(handler, inputs, glslFunc, outputTensorType),\n  };\n};\n\nconst createBinaryProgramInfo = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  glslFunc: GlslValueFunction,\n  outputTensorType: Tensor.DataType = inputs[0].type,\n): ProgramInfo => {\n  const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n  const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);\n  let outputShape = inputs[0].dims;\n\n  const usePackedTexture = handler.session.pack;\n\n  if (isBroadcast) {\n    const calculatedShape = BroadcastUtil.calcShape(inputs[0].dims, inputs[1].dims, false);\n    if (!calculatedShape) {\n      throw new Error(\"Can't perform binary op on the given tensors\");\n    }\n    outputShape = calculatedShape;\n    const outputRank = outputShape.length;\n    const aRank = inputs[0].dims.length !== 0 ? inputs[0].dims.length : 1;\n    const bRank = inputs[1].dims.length !== 0 ? inputs[1].dims.length : 1;\n    const aBcast = inputs[0].dims.length !== 0 ? 'bcastIndices_A(indices, aindices);' : 'aindices[0] = 0;';\n    const bBcast = inputs[1].dims.length !== 0 ? 'bcastIndices_B(indices, bindices);' : 'bindices[0] = 0;';\n\n    const glsl = getGlsl(handler.session.backend.glContext.version);\n    const shaderSource = usePackedTexture\n      ? `\n      ${glslFunc.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${glslFunc.name}(a, b);\n        ${glsl.output} = result;\n      }`\n      : `\n      ${glslFunc.body}\n      float process(int indices[${outputRank}]) {\n        int aindices[${aRank}];\n        int bindices[${bRank}];\n        ${aBcast}\n        ${bBcast}\n        return ${glslFunc.name}(_A(aindices), _B(bindices));\n      }`;\n\n    return {\n      name: glslFunc.name,\n      inputNames: ['A', 'B'],\n      inputTypes: [textureType, textureType],\n      output: { dims: outputShape, type: outputTensorType, textureType },\n      shaderSource,\n      hasMain: usePackedTexture,\n    };\n  }\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  const shaderSource = `\n    ${glslFunc.body}\n    void main() {\n      vec4 v1 = ${glsl.texture2D}(A, TexCoords);\n      vec4 v2 = ${glsl.texture2D}(B, TexCoords);\n      vec4 result = ${glslFunc.name}(v1, v2);\n      ${glsl.output} = result;\n    }\n    `;\n\n  return {\n    name: glslFunc.name,\n    inputNames: ['A', 'B'],\n    inputTypes: [textureType, textureType],\n    output: { dims: inputs[0].dims, type: outputTensorType, textureType },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const add = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAdd()), inputs),\n];\n\nexport const and = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAnd(), 'bool'), inputs),\n];\n\nexport const div = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslDiv()), inputs),\n];\n\nexport const equal = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslEqual(), 'bool'), inputs),\n];\n\nexport const greater = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslGreater(), 'bool'), inputs),\n];\n\nexport const less = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslLess(), 'bool'), inputs),\n];\n\nexport const mul = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslMul()), inputs),\n];\n\nexport const or = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslOr(), 'bool'), inputs),\n];\n\nexport const pow = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPow()), inputs),\n];\n\nexport const pRelu = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPRelu()), inputs),\n];\n\nexport const sub = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslSub()), inputs),\n];\n\nexport const xor = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createBinaryProgramInfoLoader(handler, inputs, glslXor(), 'bool'), inputs),\n];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ProtoUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const cast: OperatorImplementation<Tensor.DataType> = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  to: Tensor.DataType,\n): Tensor[] => {\n  validateInputs(inputs);\n  return [handler.cast(inputs[0], to)];\n};\n\nexport const parseCastAttributes: OperatorInitialization<Tensor.DataType> = (node: Graph.Node): Tensor.DataType =>\n  ProtoUtil.tensorDataTypeFromProto(node.attributes.getInt('to'));\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Cast requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\nimport { getCoordsDataType, getGlChannels } from '../utils';\n\nimport { ConcatAttributes } from './concat';\nimport { getChannels, unpackFromChannel } from './packing-utils';\n\nconst createPackedConcatProgramMetadata = (inputCount: number, cacheHint: string) => ({\n  name: 'Concat (packed)',\n  inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),\n  inputTypes: Array(inputCount).fill(TextureType.packed),\n  cacheHint,\n});\n\nconst createPackedConcatProgramInfo = (\n  handler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  axis: number,\n): ProgramInfo => {\n  const inputShape = inputs[0].dims.slice();\n  if (axis >= inputShape.length || axis < -1 * inputShape.length) {\n    throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n  }\n  if (axis < 0) {\n    axis = inputShape.length + axis;\n  }\n  // ensure all of the non-concatenated axes match each other\n  // calculate the shape of the output tensor while we do that\n  const outputShape = inputShape.slice(0);\n  for (let i = 1; i < inputs.length; i++) {\n    const dataNShape = inputs[i].dims.slice();\n    for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {\n      // add to the placeholder for computing output shape\n      if (axisIndex === axis) {\n        outputShape[axis] += dataNShape[axisIndex];\n      }\n      // ensure all non-cancatenated axes match each other\n      else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {\n        throw new Error('non concat dimensions must match');\n      }\n    }\n  }\n\n  const rank = outputShape.length;\n  const coords = getChannels('coords', rank);\n  const dtype = getCoordsDataType(rank);\n  const unpackChannel = unpackFromChannel();\n\n  const shapes = inputs.map((i) => i.dims);\n  const channels = getGlChannels(rank);\n  const offsets: number[] = new Array(shapes.length - 1);\n\n  offsets[0] = shapes[0][axis];\n  for (let i = 1; i < offsets.length; i++) {\n    offsets[i] = offsets[i - 1] + shapes[i][axis];\n  }\n\n  const channel = channels[axis];\n  const lastChannels = channels.slice(-2);\n  const allChannels = channels.join();\n\n  let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getX0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n  for (let i = 1; i < offsets.length; i++) {\n    const shift = offsets[i - 1];\n    getValueSnippet += `\n            if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n              return getChannel(\n                getX${i}(${getShiftedChannelsSnippet(channels, channel, shift)}),\n                vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));\n            }`;\n  }\n  const lastIndex = offsets.length;\n  const shift = offsets[offsets.length - 1];\n  getValueSnippet += `\n            return getChannel(\n              getX${lastIndex}(${getShiftedChannelsSnippet(channels, channel, shift)}),\n              vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));`;\n\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n\n  const shaderSource = `\n          ${unpackChannel}\n          float getValue(${channels.map((x) => 'int ' + x)}) {\n            ${getValueSnippet}\n          }\n\n          void main() {\n            ${dtype} coords = getOutputCoords();\n            int lastDim = coords.${channels[rank - 1]};\n            coords.${channels[rank - 1]} = coords.${channels[rank - 2]};\n            coords.${channels[rank - 2]} = lastDim;\n\n            vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n            ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n            if (${coords[rank - 1]} < ${outputShape[rank - 1]}) {\n              result.g = getValue(${coords});\n            }\n\n            ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n            if (${coords[rank - 2]} < ${outputShape[rank - 2]}) {\n              result.a = getValue(${coords});\n            }\n\n            ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n            if (${coords[rank - 2]} < ${outputShape[rank - 2]} &&\n                ${coords[rank - 1]} < ${outputShape[rank - 1]}) {\n              result.b = getValue(${coords});\n            }\n            ${glsl.output} = result;\n          }\n        `;\n\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.packed },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const createPackedConcatProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ConcatAttributes,\n): ProgramInfoLoader => {\n  const metadata = createPackedConcatProgramMetadata(inputs.length, attributes.cacheKey);\n  return { ...metadata, get: () => createPackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };\n};\n\nconst getShiftedChannelsSnippet = (channels: string[], channel: string, shift: number): string => {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return `${c} - ${shift}`;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { createPackedConcatProgramInfoLoader } from './concat-packed';\n\nexport interface ConcatAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nexport const concat: OperatorImplementation<ConcatAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ConcatAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  if (inferenceHandler.session.pack && inputs[0].dims.length > 1) {\n    const output = inferenceHandler.run(\n      createPackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes),\n      inputs,\n    );\n    return [output];\n  } else {\n    const output = inferenceHandler.run(\n      createUnpackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes),\n      inputs,\n    );\n    return [output];\n  }\n};\n\nconst createUnpackedConcatProgramMetadata = (inputCount: number, cacheHint: string) => ({\n  name: 'Concat',\n  inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),\n  inputTypes: Array(inputCount).fill(TextureType.unpacked),\n  cacheHint,\n});\n\nconst createUnpackedConcatProgramInfo = (\n  _handler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  axis: number,\n): ProgramInfo => {\n  const inputShape = inputs[0].dims.slice();\n  if (axis >= inputShape.length || axis < -1 * inputShape.length) {\n    throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n  }\n  if (axis < 0) {\n    axis = inputShape.length + axis;\n  }\n  // ensure all of the non-concatenated axes match each other\n  // calculate the shape of the output tensor while we do that\n  const outputShape = inputShape.slice(0);\n  for (let i = 1; i < inputs.length; i++) {\n    const dataNShape = inputs[i].dims.slice();\n    for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {\n      // add to the placeholder for computing output shape\n      if (axisIndex === axis) {\n        outputShape[axis] += dataNShape[axisIndex];\n      }\n      // ensure all non-cancatenated axes match each other\n      else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {\n        throw new Error('non concat dimensions must match');\n      }\n    }\n  }\n\n  const rank = outputShape.length;\n\n  const sizeInConcatAxis = new Array<number>(inputs.length);\n  let previousSum = 0;\n  for (let i = 0; i < sizeInConcatAxis.length; ++i) {\n    previousSum += inputs[i].dims[axis];\n    sizeInConcatAxis[i] = previousSum;\n  }\n\n  let getTextureIndexWhereDataResidesMethod = '';\n  // in most cases linear search is sufficient, as in most scenarios, only 2 tensors are concatenated\n  if (inputs.length < 5) {\n    getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);\n  } else {\n    getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesBinarySearch(sizeInConcatAxis);\n  }\n\n  const fetchDataFromCorrectTextureMethod = getFetchDataFromCorrectTextureMethod(inputs.length, rank);\n  const getSizeInConcatAxisValueFromIndexMethod = getGetSizeInConcatAxisValueFromIndexMethod(sizeInConcatAxis);\n  const shaderSource = `\n        ${fetchDataFromCorrectTextureMethod}\n        ${getSizeInConcatAxisValueFromIndexMethod}\n        ${getTextureIndexWhereDataResidesMethod}\n        float process(int indices[${rank}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${axis}]);\n\n          if(textureIndex != 0) {\n            indices[${axis}] = indices[${axis}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst createUnpackedConcatProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ConcatAttributes,\n): ProgramInfoLoader => {\n  const metadata = createUnpackedConcatProgramMetadata(inputs.length, attributes.cacheKey);\n  return { ...metadata, get: () => createUnpackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };\n};\n\nconst getTextureIndexWhereDataResidesLinearSearch = (sizeInConcatAxis: number[]): string => {\n  const searchAxis = sizeInConcatAxis.map(\n    (size, i) => `if(index<${size}) {return ${i};}\n`,\n  );\n  return `int getTextureWhereDataResides(int index) {\n      ${searchAxis.join('')}\n    }`;\n};\n\n// TODO: Implement BinarySearch in GLSL\nconst getTextureIndexWhereDataResidesBinarySearch = (sizeInConcatAxis: number[]): string =>\n  getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);\n\nconst getFetchDataFromCorrectTextureMethod = (numberOfTensors: number, tensorRank: number) => {\n  const codeLines: string[] = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${tensorRank}]) {`];\n  for (let i = 0; i < numberOfTensors; ++i) {\n    if (i === 0) {\n      codeLines.push('\\t' + `if (textureIndex == ${i}) { return _X${i}(indices); }`);\n    } else if (i === numberOfTensors - 1) {\n      codeLines.push('\\t' + `else { return _X${i}(indices); }`);\n    } else {\n      codeLines.push('\\t' + `else if (textureIndex == ${i}) { return _X${i}(indices); }`);\n    }\n  }\n  codeLines.push('\\t' + '}');\n  return codeLines.join('\\n');\n};\n\nconst getGetSizeInConcatAxisValueFromIndexMethod = (sizeInConcatAxis: number[]): string => {\n  const codeLines: string[] = ['int getSizeInConcatAxisValueFromIndex(int index) {'];\n  for (let i = 0; i < sizeInConcatAxis.length; ++i) {\n    if (i === 0) {\n      codeLines.push('\\t' + `if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);\n    } else if (i === sizeInConcatAxis.length - 1) {\n      codeLines.push('\\t' + `else { return ${sizeInConcatAxis[i]}; }`);\n    } else {\n      codeLines.push('\\t' + `else if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);\n    }\n  }\n  codeLines.push('\\t' + '}');\n\n  return codeLines.join('\\n');\n};\n\nexport const parseConcatAttributes: OperatorInitialization<ConcatAttributes> = (node: Graph.Node): ConcatAttributes =>\n  createAttributeWithCacheKey({ axis: node.attributes.getInt('axis') });\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length < 1) {\n    throw new Error('too few inputs');\n  }\n\n  const inputType = inputs[0].type;\n  const inputDimensionality = inputs[0].dims.length;\n\n  // TODO: Support string concat\n  if (inputType === 'string') {\n    throw new Error('string tensor is not supported yet');\n  }\n\n  for (const input of inputs) {\n    // make sure types of all inputs match\n    if (input.type !== inputType) {\n      throw new Error('input tensors should be one type');\n    }\n\n    // make sure the dimensionality of all inputs are the same\n    if (input.dims.length !== inputDimensionality) {\n      throw new Error('input tensors should have the same shape');\n    }\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { Tensor } from '../../../tensor';\nimport { MAX_CLIP, MIN_CLIP } from '../../../util';\nimport { FunctionType, GlslValueFunction } from '../glsl-definitions';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nexport function glslAbs(): GlslValueFunction {\n  return glslBuiltinUnary('abs');\n}\nexport function glslAcos(): GlslValueFunction {\n  return glslBuiltinUnary('acos');\n}\nexport function glslAsin(): GlslValueFunction {\n  return glslBuiltinUnary('asin');\n}\nexport function glslAtan(): GlslValueFunction {\n  return glslBuiltinUnary('atan');\n}\nexport function glslCeil(): GlslValueFunction {\n  return glslBuiltinUnary('ceil');\n}\nexport function glslCos(): GlslValueFunction {\n  return glslBuiltinUnary('cos');\n}\nexport function glslElu(alpha: number): GlslValueFunction {\n  const name = 'elu';\n  const body = `\n  const float alpha = float(${alpha});\n\n  float ${name}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(${name}_(v.x), ${name}_(v.y), ${name}_(v.z), ${name}_(v.w));\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslExp(): GlslValueFunction {\n  return glslBuiltinUnary('exp');\n}\nexport function glslFloor(): GlslValueFunction {\n  return glslBuiltinUnary('floor');\n}\nexport function glslClip(min: number, max: number): GlslValueFunction {\n  const name = 'clip';\n  const body = `\n  const float min = float(${min});\n  const float max = float(${max});\n\n  float ${name}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${name}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslIdentity(): GlslValueFunction {\n  const name = 'indentity';\n  const body = `\n  float ${name}_(float a) {\n    return a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return v;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslLeakyRelu(alpha: number): GlslValueFunction {\n  const name = 'leakyRelu';\n  const body = `\n  const float alpha = float(${alpha});\n\n  float ${name}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(${name}_(v.x), ${name}_(v.y), ${name}_(v.z), ${name}_(v.w));\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslLog(): GlslValueFunction {\n  return glslBuiltinUnary('log');\n}\nexport function glslNeg(): GlslValueFunction {\n  const name = 'neg';\n  const body = `\n  float ${name}_(float a) {\n    return -a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return -v;\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslNot(): GlslValueFunction {\n  const name = 'not';\n  const body = `\n  float ${name}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${name}_(bool a) {\n    return !a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${name}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslSin(): GlslValueFunction {\n  return glslBuiltinUnary('sin');\n}\nexport function glslRelu(): GlslValueFunction {\n  const name = 'relu';\n  const body = `\n  float ${name}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${name}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslSigmoid(): GlslValueFunction {\n  const name = 'sigmoid';\n  const body = `\n  float ${name}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${name}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nexport function glslSqrt(): GlslValueFunction {\n  return glslBuiltinUnary('sqrt');\n}\nexport function glslTan(): GlslValueFunction {\n  return glslBuiltinUnary('tan');\n}\nexport function glslTanh(): GlslValueFunction {\n  const name = 'tanh';\n  const body = `\n  float ${name}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${name}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\nfunction glslBuiltinUnary(name: string): GlslValueFunction {\n  const body = `\n  float ${name}_(float a) {\n    return ${name}(a);\n  }\n  vec4 ${name}_(vec4 v) {\n    return ${name}(v);\n  }\n  `;\n  return { body, name, type: FunctionType.ValueBased };\n}\n\n/////\n/////\n/////\n\nconst createElementwiseProgramInfo = (\n  handler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  input: Tensor,\n  glslFunc: GlslValueFunction,\n): ProgramInfo => {\n  const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  return {\n    ...metadata,\n    output: { dims: input.dims, type: input.type, textureType },\n    shaderSource: `\n     ${glslFunc.body}\n     void main() {\n       vec4 v = ${glsl.texture2D}(A, TexCoords);\n       v = ${glslFunc.name}_(v);\n       ${glsl.output} = v;\n     }\n     `,\n    hasMain: true,\n  };\n};\n\nconst createElementwiseProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  input: Tensor,\n  glslFunc: GlslValueFunction,\n  cacheKey?: string,\n): ProgramInfoLoader => {\n  const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n  const metadata = { name: glslFunc.name, inputTypes: [textureType], inputNames: ['A'], cacheHint: cacheKey };\n  return { ...metadata, get: () => createElementwiseProgramInfo(handler, metadata, input, glslFunc) };\n};\n\nexport const abs = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAbs()), inputs),\n];\n\nexport const acos = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAcos()), inputs),\n];\n\nexport const asin = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAsin()), inputs),\n];\n\nexport const atan = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAtan()), inputs),\n];\n\nexport interface ClipAttributes extends AttributeWithCacheKey {\n  readonly min: number;\n  readonly max: number;\n}\n\nexport const clip = (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ClipAttributes): Tensor[] => [\n  handler.run(\n    createElementwiseProgramInfoLoader(\n      handler,\n      inputs[0],\n      glslClip(attributes.min, attributes.max),\n      attributes.cacheKey,\n    ),\n    inputs,\n  ),\n];\n\nexport const parseClipAttributes = (node: Graph.Node): ClipAttributes =>\n  createAttributeWithCacheKey({\n    min: node.attributes.getFloat('min', MIN_CLIP),\n    max: node.attributes.getFloat('max', MAX_CLIP),\n  });\n\nexport const clipV11 = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  const attributes = generateClipAttributesFromInputs(handler, inputs);\n  return clip(handler, [inputs[0]], attributes);\n};\n\nconst generateClipAttributesFromInputs = (handler: WebGLInferenceHandler, inputs: Tensor[]): ClipAttributes => {\n  if (\n    inputs.length >= 3 &&\n    (!handler.session.isInitializer(inputs[1].dataId) || !handler.session.isInitializer(inputs[2].dataId))\n  ) {\n    throw new Error('dynamic clip attributes are not allowed');\n  }\n\n  const min = inputs.length >= 3 ? inputs[1].numberData[0] : MIN_CLIP;\n  const max = inputs.length >= 3 ? inputs[2].numberData[0] : MAX_CLIP;\n  return createAttributeWithCacheKey({ min, max });\n};\n\nexport const ceil = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCeil()), inputs),\n];\n\nexport const cos = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCos()), inputs),\n];\n\nexport interface EluAttributes extends AttributeWithCacheKey {\n  readonly alpha: number;\n}\n\nexport const elu = (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: EluAttributes): Tensor[] => [\n  handler.run(\n    createElementwiseProgramInfoLoader(handler, inputs[0], glslElu(attributes.alpha), attributes.cacheKey),\n    inputs,\n  ),\n];\n\nexport const parseEluAttributes = (node: Graph.Node): EluAttributes =>\n  createAttributeWithCacheKey({ alpha: node.attributes.getFloat('alpha', 1.0) });\n\nexport const exp = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslExp()), inputs),\n];\n\nexport const floor = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslFloor()), inputs),\n];\n\nexport const identity = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslIdentity()), inputs),\n];\n\nexport interface LeakyReluAttributes extends AttributeWithCacheKey {\n  readonly alpha: number;\n}\n\nexport const leakyRelu = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: LeakyReluAttributes,\n): Tensor[] => [\n  handler.run(\n    createElementwiseProgramInfoLoader(handler, inputs[0], glslLeakyRelu(attributes.alpha), attributes.cacheKey),\n    inputs,\n  ),\n];\n\nexport const parseLeakyReluAttributes = (node: Graph.Node): LeakyReluAttributes =>\n  createAttributeWithCacheKey({ alpha: node.attributes.getFloat('alpha', 0.01) });\n\nexport const log = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslLog()), inputs),\n];\n\nexport const neg = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNeg()), inputs),\n];\n\nexport const not = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNot()), inputs),\n];\n\nexport const relu = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslRelu()), inputs),\n];\n\nexport const sigmoid = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSigmoid()), inputs),\n];\n\nexport const sin = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSin()), inputs),\n];\n\nexport const sqrt = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSqrt()), inputs),\n];\n\nexport const tan = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTan()), inputs),\n];\n\nexport const tanh = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => [\n  handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTanh()), inputs),\n];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Attribute } from '../../../attribute';\nimport { MAX_CLIP, MIN_CLIP } from '../../../util';\nimport { GlslValueFunction } from '../glsl-definitions';\n\nimport { glslClip, glslRelu, glslSigmoid } from './unary-op';\n\nexport interface InternalActivationAttributes {\n  readonly activation: string;\n  readonly clipMin?: number;\n  readonly clipMax?: number;\n  readonly activationCacheKey: string;\n}\n\nexport function getActivationSnippet(attributes: InternalActivationAttributes) {\n  let func: GlslValueFunction;\n  switch (attributes.activation) {\n    case 'Relu':\n      func = glslRelu();\n      break;\n    case 'Sigmoid':\n      func = glslSigmoid();\n      break;\n    case 'Clip':\n      func = glslClip(attributes.clipMin!, attributes.clipMax!);\n      break;\n    // TODO: adding other activations that can be fused.\n    default:\n      return { activationFunction: '', applyActivation: '' };\n  }\n\n  const activationName = func.name;\n  const activationFunction = func.body;\n  const applyActivation = `value = ${activationName}_(value);`;\n  return { activationFunction, applyActivation };\n}\n\nexport const parseInternalActivationAttributes = (attributes: Attribute): InternalActivationAttributes => {\n  const activation = attributes.getString('activation', '');\n\n  if (activation === 'Clip') {\n    const [clipMin, clipMax] = attributes.getFloats('activation_params', [MIN_CLIP, MAX_CLIP]);\n    return { activation, clipMax, clipMin, activationCacheKey: `${activation}:${clipMin},${clipMax}` };\n  }\n  return { activation, activationCacheKey: activation };\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Logger } from '../../../instrument';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { calculateOutputShape, ConvAttributes } from './conv';\nimport { getActivationSnippet } from './fuse-utils';\n\nconst createUnpackedGroupedConvProgramMetadata = (hasBias: boolean, cacheHint: string): ProgramMetadata => ({\n  name: 'GroupedConv',\n  inputNames: hasBias ? ['X', 'W', 'Bias'] : ['X', 'W'],\n  inputTypes: hasBias\n    ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked]\n    : [TextureType.unpacked, TextureType.unpacked],\n  cacheHint,\n});\n\nconst createUnpackedGroupedConvProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  metadata: ProgramMetadata,\n  attributes: ConvAttributes,\n): ProgramInfo => {\n  const hasBias = inputs.length > 2;\n  const processBias = hasBias ? 'value += getBias(output_channel);' : '';\n  const xShape = inputs[0].dims.slice();\n  const wShape = inputs[1].dims.slice();\n  const outputChannelsPerGroup = wShape[0] / attributes.group;\n  Logger.verbose(\n    'GroupedConv',\n    `autpPad:${attributes.autoPad}, dilations:${attributes.dilations}, group:${attributes.group}, kernelShape:${\n      attributes.kernelShape\n    }, pads:${attributes.pads}, strides:${attributes.strides}`,\n  );\n  const outputShape = calculateOutputShape(xShape, wShape, attributes.dilations, attributes.pads, attributes.strides);\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const { activationFunction, applyActivation } = getActivationSnippet(attributes);\n\n  const shaderSource = `\n  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});\n  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});\n  ${activationFunction}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${outputChannelsPerGroup};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${wShape[1]}; wInChannel++) {\n      int input_channel = group_id * ${wShape[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${wShape[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${attributes.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${xShape[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${wShape[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${attributes.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${xShape[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${processBias}\n    ${applyActivation}\n    ${glsl.output} = vec4(value, .0, .0, .0);\n  }\n`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const createUnpackedGroupedConvProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvAttributes,\n): ProgramInfoLoader => {\n  const metadata = createUnpackedGroupedConvProgramMetadata(inputs.length > 2, attributes.cacheKey);\n  return {\n    ...metadata,\n    get: () => createUnpackedGroupedConvProgramInfo(inferenceHandler, inputs, metadata, attributes),\n  };\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { ConvAttributes } from './conv';\nimport { unpackFromChannel } from './packing-utils';\n\nconst createPackedIm2ColProgramMetadata = (cacheHint: string) => ({\n  name: 'Im2Col (packed)',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed],\n  cacheHint,\n});\n\nconst createPackedIm2ColProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  x: Tensor,\n  w: Tensor,\n  outputShape: readonly number[],\n  attributes: ConvAttributes,\n): ProgramInfo => {\n  const xshape = x.dims;\n  const wshape = w.dims;\n  const rowDim = 2;\n  const colDim = 3;\n  const rank = outputShape.length;\n  const im2colShape = [wshape[1] * wshape[2] * wshape[3], outputShape[2] * outputShape[3]];\n  const kernelSize = wshape[2] * wshape[3];\n  const unpackChannel = unpackFromChannel();\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  let unrolled = '';\n\n  for (let row = 0; row <= 1; row++) {\n    for (let col = 0; col <= 1; col++) {\n      unrolled += `\n            blockIndex = rc.x + ${col};\n            pos = rc.y + ${row};\n\n            if(blockIndex < ${im2colShape[1]} && pos < ${im2colShape[0]}) {\n              offsetY = int(blockIndex / (${outputShape[rank - 1]})) * ${attributes.strides[0]} -\n                ${attributes.pads[0]};\n              d0 = offsetY + ${attributes.dilations[0]} * (imod(pos, ${kernelSize}) / ${wshape[2]});\n\n              if(d0 < ${xshape[rowDim]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${outputShape[rank - 1]}) * ${attributes.strides[1]} -\n                  ${attributes.pads[1]};\n                d1 = offsetX + ${attributes.dilations[1]} * imod(imod(pos, ${kernelSize}), ${wshape[2]});\n\n                if(d1 < ${xshape[colDim]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${kernelSize}.);\n                    innerDims = vec2(d0, d1);\n                    result[${row * 2 + col}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;\n    }\n  }\n\n  const shaderSource = `\n      ${unpackChannel}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${unrolled}\n          ${glsl.output} = result;\n      }\n            `;\n  return {\n    ...metadata,\n    output: { dims: im2colShape, type: x.type, textureType: TextureType.packed },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const createPackedIm2ColProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  x: Tensor,\n  w: Tensor,\n  outputShape: readonly number[],\n  attributes: ConvAttributes,\n): ProgramInfoLoader => {\n  const metadata = createPackedIm2ColProgramMetadata(attributes.cacheKey);\n  return {\n    ...metadata,\n    get: () => createPackedIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes),\n  };\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { BroadcastUtil, ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\nimport { getCoordsDataType, getGlChannels } from '../utils';\n\nimport { getActivationSnippet, InternalActivationAttributes, parseInternalActivationAttributes } from './fuse-utils';\nimport { createPackedMatmulProgramInfoLoader } from './matmul-pack';\n\nexport const matMul: OperatorImplementation<InternalActivationAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: InternalActivationAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  if (inferenceHandler.session.pack) {\n    return [inferenceHandler.run(createPackedMatmulProgramInfoLoader(inferenceHandler, inputs, attributes), inputs)];\n  } else {\n    return [inferenceHandler.run(createMatmulProgramInfoLoader(inputs, attributes), inputs)];\n  }\n};\n\nexport const parseMatMulAttributes: OperatorInitialization<InternalActivationAttributes> = (\n  node: Graph.Node,\n): InternalActivationAttributes => parseInternalActivationAttributes(node.attributes);\n\nconst createMatmulProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'MatMul',\n  inputNames: hasBias ? ['A', 'B', 'Bias'] : ['A', 'B'],\n  inputTypes: hasBias\n    ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked]\n    : [TextureType.unpacked, TextureType.unpacked],\n  cacheHint,\n});\n\nfunction createMatmulProgramInfo(\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  activationAttributes: InternalActivationAttributes,\n): ProgramInfo {\n  const aShape = inputs[0].dims;\n  const bShape = inputs[1].dims;\n  const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);\n  if (!outputShape) {\n    throw new Error(\"Can't use matmul on the given tensors\");\n  }\n  const coordsDataType = getCoordsDataType(outputShape.length);\n  const allGlChannels = getGlChannels();\n  const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);\n\n  const hasBias = inputs.length > 2;\n  const processBias = hasBias ? 'value += getBiasForMatmul();' : '';\n  const getBiasForMatmulSnippet = hasBias\n    ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, false)}`\n    : '';\n\n  const rank = outputShape.length;\n  const arank = aShape.length;\n  const brank = bShape.length;\n  const sharedDim = aShape[aShape.length - 1];\n  const shaderSource = `\n    ${activationFunction}\n    ${getBiasForMatmulSnippet}\n    float process(int indices[${rank}]) {\n        int a[${arank}];\n        int b[${brank}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${sharedDim}; ++k) {\n            a[${arank - 1}] = k;\n            b[${brank - 2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${processBias}\n        ${applyActivation}\n        return value;\n    }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n}\n\nexport function createMatmulProgramInfoLoader(\n  inputs: Tensor[],\n  activationAttributes: InternalActivationAttributes,\n): ProgramInfoLoader {\n  const metadata = createMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);\n  return { ...metadata, get: () => createMatmulProgramInfo(metadata, inputs, activationAttributes) };\n}\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('MatMul requires 2 inputs.');\n  }\n\n  if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {\n    throw new Error('shared dimension does not match.');\n  }\n\n  if (\n    (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') ||\n    (inputs[1].type !== 'float32' && inputs[1].type !== 'float64')\n  ) {\n    throw new Error('inputs should be float type');\n  }\n\n  if (inputs[0].type !== inputs[1].type) {\n    throw new Error('inputs types should match');\n  }\n};\n\nexport function getBiasForMatmul(\n  coordsDataType: string,\n  allGlChannels: readonly string[],\n  inShape: readonly number[],\n  outShape: readonly number[],\n  isPacked: boolean,\n): string {\n  let unpackedCoordsSnippet = '';\n  const inRank = inShape.length;\n  const outRank = outShape.length;\n  const rankDiff = outRank - inRank;\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${allGlChannels[i + rankDiff]}`).join(', ');\n  }\n  const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n  const coordsSnippet = broadcastDims.map((d) => `coords.${allGlChannels[d + rankDiff]} = 0;`).join('\\n');\n  const inSize = ShapeUtil.size(inShape);\n  const isInputScalar = inSize === 1;\n  let output = 'vec4(outputValue.xx, outputValue.yy)';\n  if (isInputScalar) {\n    output = 'vec4(outputValue.x)';\n  }\n  const getBiasForMatmulSource = isPacked\n    ? `\nvec4 getBiasForMatmul() {\n  ${coordsDataType} coords = getOutputCoords();\n  ${coordsSnippet}\n  vec4 outputValue = getBias(${unpackedCoordsSnippet});\n  return ${output};\n}`\n    : `\nfloat getBiasForMatmul() {\n  ${coordsDataType} coords = getOutputCoords();\n  ${coordsSnippet}\n  return getBias(coords.x);\n}`;\n\n  return getBiasForMatmulSource;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { BroadcastUtil, ShapeUtil } from '../../../util';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\nimport { getCoordsDataType, getGlChannels } from '../utils';\n\nimport { getActivationSnippet, InternalActivationAttributes } from './fuse-utils';\nimport { getBiasForMatmul } from './matmul';\n\nconst createPackedMatmulProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'MatMul (packed)',\n  inputNames: hasBias ? ['A', 'B', 'Bias'] : ['A', 'B'],\n  inputTypes: hasBias\n    ? [TextureType.packed, TextureType.packed, TextureType.packed]\n    : [TextureType.packed, TextureType.packed],\n  cacheHint,\n});\n\nconst createPackedMatmulProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  activationAttributes: InternalActivationAttributes,\n): ProgramInfo => {\n  const hasBias = inputs.length > 2;\n  const processBias = hasBias ? 'value += getBiasForMatmul();' : '';\n  const aShape = inputs[0].dims;\n  const bShape = inputs[1].dims;\n  const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);\n  const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);\n\n  if (!outputShape) {\n    throw new Error(\"Can't use matmul on the given tensors\");\n  }\n  const sharedDim = aShape[aShape.length - 1];\n  const sharedDimIndex = Math.ceil(sharedDim / 2);\n  const aRank = aShape.length;\n  const bRank = bShape.length;\n\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const coordsDataType = getCoordsDataType(outputShape.length);\n  const outRank = outputShape.length;\n  const allGlChannels = getGlChannels();\n  const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);\n\n  const getBiasForMatmulSnippet = hasBias\n    ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, true)}`\n    : '';\n\n  const getBcastedSamplerForMatmulSnippet = isBroadcast\n    ? `${getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outputShape)}`\n    : '';\n\n  const getSamplerAInLoopSnippet = isBroadcast ? 'getAAtOutCoordsMatmul(i)' : `getA(${getA(allGlChannels, aRank)})`;\n  const getSamplerBInLoopSnippet = isBroadcast ? 'getBAtOutCoordsMatmul(i)' : `getB(${getB(allGlChannels, bRank)})`;\n  const getOutputCoordsSnippet = isBroadcast\n    ? ''\n    : `${coordsDataType} rc =\n          getOutputCoords(); int lastDim = rc.${allGlChannels[outRank - 1]}; rc.${allGlChannels[outRank - 1]} =\n          rc.${allGlChannels[outRank - 2]}; rc.${allGlChannels[outRank - 2]} = lastDim;\n      `;\n  const shaderSource = `\n            ${getBcastedSamplerForMatmulSnippet}\n            ${getBiasForMatmulSnippet}\n            ${activationFunction}\n            void main() {\n              ${getOutputCoordsSnippet}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${sharedDimIndex}; i++) {\n                vec4 a = ${getSamplerAInLoopSnippet};\n                vec4 b = ${getSamplerBInLoopSnippet};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${processBias}\n              ${applyActivation}\n              ${glsl.output} = value;\n            }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.packed },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nexport const createPackedMatmulProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  activationAttributes: InternalActivationAttributes,\n): ProgramInfoLoader => {\n  const metadata = createPackedMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);\n  return {\n    ...metadata,\n    get: () => createPackedMatmulProgramInfo(inferenceHandler, metadata, inputs, activationAttributes),\n  };\n};\n\nfunction getBcastSamplerForMatmul(\n  coordsDataType: string,\n  allGlChannels: readonly string[],\n  inputs: Tensor[],\n  outShape: readonly number[],\n): string {\n  let unpackedACoordsSnippet = [];\n  let unpackedBCoordsSnippet = [];\n\n  const inAShape = inputs[0].dims;\n  const inBShape = inputs[1].dims;\n\n  const inARank = inAShape.length;\n  const inBRank = inBShape.length;\n\n  const outRank = outShape.length;\n  const rankADiff = outRank - inARank;\n  const rankBDiff = outRank - inBRank;\n\n  unpackedACoordsSnippet = inAShape.map((_s, i) => `coords.${allGlChannels[i + rankADiff]}`);\n  unpackedACoordsSnippet[inARank - 1] = 'i*2';\n  unpackedACoordsSnippet.join(', ');\n  unpackedBCoordsSnippet = inBShape.map((_s, i) => `coords.${allGlChannels[i + rankBDiff]}`);\n  unpackedBCoordsSnippet[inBRank - 2] = 'i*2';\n  unpackedBCoordsSnippet.join(', ');\n\n  const broadcastADims = BroadcastUtil.getBroadcastDims(inAShape, outShape);\n  const broadcastBDims = BroadcastUtil.getBroadcastDims(inBShape, outShape);\n\n  const coordsASnippet = broadcastADims.map((d) => `coords.${allGlChannels[d + rankADiff]} = 0;`).join('\\n');\n  const coordsBSnippet = broadcastBDims.map((d) => `coords.${allGlChannels[d + rankBDiff]} = 0;`).join('\\n');\n  const swapDimSnippet = `int lastDim = coords.${allGlChannels[outRank - 1]};\n  coords.${allGlChannels[outRank - 1]} = coords.${allGlChannels[outRank - 2]};\n  coords.${allGlChannels[outRank - 2]} = lastDim;`;\n\n  const getBcastSamplerMatmulSource = `\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${coordsDataType} coords = getOutputCoords();\n  ${swapDimSnippet}\n  ${coordsASnippet}\n  vec4 outputValue = getA(${unpackedACoordsSnippet});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${coordsDataType} coords = getOutputCoords();\n  ${swapDimSnippet}\n  ${coordsBSnippet}\n  vec4 outputValue = getB(${unpackedBCoordsSnippet});\n  return outputValue;\n}`;\n\n  return getBcastSamplerMatmulSource;\n}\n\nfunction getA(allGlChannels: string[], rank: number): string {\n  let res = '';\n  for (let i = 0; i < rank - 2; i++) {\n    res += `rc.${allGlChannels[i]}, `;\n  }\n  res += `rc.${allGlChannels[rank - 2]}, ` + 'i*2';\n  return res;\n}\n\nfunction getB(allGlChannels: string[], rank: number): string {\n  let res = '';\n  for (let i = 0; i < rank - 2; i++) {\n    res += `rc.${allGlChannels[i]}, `;\n  }\n  res += 'i*2, ' + `rc.${allGlChannels[rank - 1]}`;\n  return res;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nimport { calculateOutputShape, ConvAttributes } from './conv';\nimport { createPackedIm2ColProgramInfoLoader } from './im2col-pack';\nimport { createPackedMatmulProgramInfoLoader } from './matmul-pack';\n\nexport const conv2DPackedPointwise = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvAttributes,\n): Tensor => {\n  const xshape = inputs[0].dims;\n  const kshape = inputs[1].dims;\n  const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n  const reshapedX = inferenceHandler.reshapePacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);\n  const reshapedK = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1]]);\n\n  const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];\n  const matmulOutput = inferenceHandler.run(\n    createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes),\n    matmulInputs,\n  );\n  return inferenceHandler.reshapePacked(matmulOutput, outputShape);\n};\n\nexport const conv2DPacked = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvAttributes,\n): Tensor => {\n  const xshape = inputs[0].dims;\n  const kshape = inputs[1].dims;\n  const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n\n  // run im2col\n  const im2colOutput = inferenceHandler.run(\n    createPackedIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),\n    [inputs[0]],\n  );\n\n  // reshape kernel\n  const kernelReshaped = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1] * kshape[2] * kshape[3]]);\n\n  // run matmul\n  const matmulInputs = inputs.length === 3 ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput];\n  const matmulOutput = inferenceHandler.run(\n    createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes),\n    matmulInputs,\n  );\n\n  // reshape output\n  const outputReshaped = inferenceHandler.reshapePacked(matmulOutput, outputShape);\n  return outputReshaped;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { ConvAttributes } from './conv';\n\nconst createIm2ColProgramMetadata = (cacheHint: string) => ({\n  name: 'Im2Col',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n  cacheHint,\n});\n\nconst createIm2ColProgramInfo = (\n  _inferenceHandler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  x: Tensor,\n  w: Tensor,\n  outputShape: readonly number[],\n  attributes: ConvAttributes,\n): ProgramInfo => {\n  const xshape = x.dims;\n  const wshape = w.dims;\n\n  const rank = outputShape.length;\n  const im2colDims = calculateIm2ColDims(xshape, wshape, outputShape, 4);\n\n  const shaderSource = `\n        const int XC = ${xshape[1]};\n        const int XH = ${xshape[2]};\n        const int XW = ${xshape[3]};\n        const int KH = ${attributes.kernelShape[0]};\n        const int KW = ${attributes.kernelShape[1]};\n        const int dilationH = ${attributes.dilations[0]};\n        const int dilationW = ${attributes.dilations[1]};\n        const int strideH = ${attributes.strides[0]};\n        const int strideW = ${attributes.strides[1]};\n        const int padH = ${attributes.pads[0]};\n        const int padW = ${attributes.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${rank}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${xshape.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;\n  return {\n    ...metadata,\n    output: { dims: im2colDims, type: x.type, textureType: TextureType.packedLastDimension },\n    shaderSource,\n  };\n};\n\nexport const createIm2ColProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  x: Tensor,\n  w: Tensor,\n  outputShape: readonly number[],\n  attributes: ConvAttributes,\n): ProgramInfoLoader => {\n  const metadata = createIm2ColProgramMetadata(attributes.cacheKey);\n  return {\n    ...metadata,\n    get: () => createIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes),\n  };\n};\n\nexport const calculateIm2ColDims = (\n  inputShape: readonly number[],\n  kernelShape: readonly number[],\n  outputShape: readonly number[],\n  channels = 4,\n): number[] => [\n  outputShape[0],\n  outputShape[2],\n  outputShape[3],\n  Math.ceil((inputShape[1] * kernelShape[2] * kernelShape[3]) / channels),\n];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { getActivationSnippet, InternalActivationAttributes } from './fuse-utils';\nimport { calculateIm2ColDims } from './im2col';\n\nconst createDotProductProgramMetadata = (hasBias: boolean, attributes: InternalActivationAttributes) => ({\n  name: 'ConvDotProduct',\n  inputNames: hasBias ? ['Im2Col', 'K', 'B'] : ['Im2Col', 'K'],\n  inputTypes: hasBias\n    ? [TextureType.unpacked, TextureType.packedLastDimension, TextureType.unpacked]\n    : [TextureType.unpacked, TextureType.packedLastDimension],\n  cacheKey: attributes.activationCacheKey,\n});\n\nconst createDotProductProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: readonly Tensor[],\n  outputShape: number[],\n  attributes: InternalActivationAttributes,\n): ProgramInfo => {\n  const xshape = inputs[0].dims;\n  const kshape = inputs[1].dims;\n  const adjustedKernelShape = [kshape[0], Math.ceil((xshape[1] * kshape[2] * kshape[3]) / 4)];\n  const im2colShape = calculateIm2ColDims(xshape, kshape, outputShape);\n  const [kWidth, kHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    adjustedKernelShape,\n    TextureType.packedLastDimension,\n  );\n\n  const im2colStrides = ShapeUtil.computeStrides(im2colShape);\n  const [im2colWidth, im2colHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    im2colShape,\n    TextureType.packedLastDimension,\n  );\n  const rank = outputShape.length;\n\n  const initValue = inputs.length < 3 ? '0.0' : '_B(b)';\n  const sharedDim = Math.ceil((xshape[1] * kshape[2] * kshape[3]) / 4);\n  const { activationFunction, applyActivation } = getActivationSnippet(attributes);\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const shaderSource = `\n${activationFunction}\nfloat process(int indices[${rank}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${im2colStrides[0]} + im2col[1] * ${im2colStrides[1]} + im2col[2] * ${\n    im2colStrides[2]\n  };\n  int kernelOffset = indices[1] * ${adjustedKernelShape[1]};\n  float value = ${initValue};\n  for (int i = 0; i < ${sharedDim}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${im2colWidth}, ${im2colHeight});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${kWidth}, ${kHeight});\n    value += dot(${glsl.texture2D}(Im2Col, im2colCoords), ${glsl.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${applyActivation}\n  return value;\n}`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nexport const createDotProductProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  outputShape: number[],\n  attributes: InternalActivationAttributes,\n): ProgramInfoLoader => {\n  const metadata = createDotProductProgramMetadata(inputs.length > 2, attributes);\n  return {\n    ...metadata,\n    get: () => createDotProductProgramInfo(inferenceHandler, metadata, inputs, outputShape, attributes),\n  };\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { InferenceHandler } from '../../../backend';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { PoolConvUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nimport { createUnpackedGroupedConvProgramInfoLoader } from './conv-grouped';\nimport { conv2DPacked } from './conv-pack';\nimport { createDotProductProgramInfoLoader } from './dot-product';\nimport { InternalActivationAttributes, parseInternalActivationAttributes } from './fuse-utils';\nimport { createIm2ColProgramInfoLoader } from './im2col';\nimport { createMatmulProgramInfoLoader } from './matmul';\n\nexport const calculateOutputShape = (\n  inputShape: readonly number[],\n  kernelShape: readonly number[],\n  dilations: readonly number[],\n  adjustPads: readonly number[],\n  strides: readonly number[],\n): number[] => {\n  const batchSize = inputShape[0];\n  const inputSpatialShape = inputShape.slice(2);\n  const spatialRank = inputSpatialShape.length;\n  const outChannels = kernelShape[0];\n  const kernelSpatialShape = kernelShape.slice(2);\n  const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));\n  const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);\n  const outputSpatialShape = inputSpatialShapeWithPad.map((v, i) =>\n    Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]),\n  );\n  const outputShape = [batchSize, outChannels].concat(...outputSpatialShape);\n  return outputShape;\n};\n\nexport interface ConvAttributes extends InternalActivationAttributes, AttributeWithCacheKey {\n  readonly autoPad: string;\n  readonly dilations: readonly number[];\n  readonly group: number;\n  readonly kernelShape: readonly number[];\n  readonly pads: readonly number[];\n  readonly strides: readonly number[];\n}\n\nexport const conv: OperatorImplementation<ConvAttributes> = (\n  inferenceHandler: InferenceHandler,\n  inputs: Tensor[],\n  attributes: ConvAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes); // currently will fail if not conv2D\n  return conv2d(inferenceHandler, inputs, attributes);\n};\n\nconst conv2d: OperatorImplementation<ConvAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ConvAttributes,\n): Tensor[] => {\n  const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);\n  const packMode = inferenceHandler.session.pack;\n  const isPointwise = adjustedAttributes.kernelShape[0] === 1 && adjustedAttributes.kernelShape[1] === 1;\n  if (adjustedAttributes.group > 1) {\n    const result = inferenceHandler.run(\n      createUnpackedGroupedConvProgramInfoLoader(inferenceHandler, inputs, adjustedAttributes),\n      inputs,\n    );\n    return [result];\n  } else if (isPointwise && packMode) {\n    return [conv2DUnpackedPointwise(inferenceHandler, inputs, adjustedAttributes)];\n  } else if (packMode && inputs[0].dims.length === 4 && inputs[0].dims[0] === 1 && !isPointwise) {\n    return [conv2DPacked(inferenceHandler, inputs, adjustedAttributes)];\n  } else {\n    return [conv2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];\n  }\n};\n\nconst conv2DUnpackedPointwise = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvAttributes,\n): Tensor => {\n  const xshape = inputs[0].dims;\n  const kshape = inputs[1].dims;\n  const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n  const reshapedX = inferenceHandler.reshapeUnpacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);\n  const reshapedK = inferenceHandler.reshapeUnpacked(inputs[1], [kshape[0], kshape[1]]);\n\n  const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];\n  const matmulOutput = inferenceHandler.run(createMatmulProgramInfoLoader(matmulInputs, attributes), matmulInputs);\n  return inferenceHandler.reshapeUnpacked(matmulOutput, outputShape);\n};\n\nconst conv2DUnpacked = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvAttributes,\n): Tensor => {\n  const xshape = inputs[0].dims;\n  const kshape = inputs[1].dims;\n  const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n  const xIm2Col = inferenceHandler.run(\n    createIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),\n    [inputs[0]],\n  );\n\n  const dotProductInputs = inputs.length === 3 ? [xIm2Col, inputs[1], inputs[2]] : [xIm2Col, inputs[1]];\n  const output = inferenceHandler.run(\n    createDotProductProgramInfoLoader(inferenceHandler, inputs, outputShape, attributes),\n    dotProductInputs,\n  );\n  return output;\n};\n\nconst getAdjustedConvAttributes = <T extends ConvAttributes>(attributes: T, inputs: Tensor[]): T => {\n  const kernelShape = attributes.kernelShape.slice();\n  // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims\n  if (attributes.kernelShape.length === 0) {\n    for (let i = 2; i < inputs[1].dims.length; ++i) {\n      kernelShape.push(inputs[1].dims[i]);\n    }\n  }\n  const pads = attributes.pads.slice();\n  PoolConvUtil.adjustPadsBasedOnAutoPad(\n    inputs[0].dims,\n    attributes.strides,\n    attributes.dilations,\n    kernelShape,\n    pads,\n    attributes.autoPad,\n  );\n\n  // always return a new object so does not modify the original attributes\n  const newAttributes: T = Object.assign({}, attributes);\n  Object.assign(newAttributes, { kernelShape, pads, cacheKey: attributes.cacheKey });\n  return newAttributes;\n};\n\nexport const parseConvAttributes: OperatorInitialization<ConvAttributes> = (node: Graph.Node): ConvAttributes => {\n  const attributes = node.attributes;\n  const activationAttributes = parseInternalActivationAttributes(attributes);\n  // TODO : Make this generic enough to compute default attributes for multi-dimensional conv\n  const autoPad = attributes.getString('auto_pad', 'NOTSET');\n  const dilations = attributes.getInts('dilations', [1, 1]);\n  const group = attributes.getInt('group', 1);\n  const kernelShape = attributes.getInts('kernel_shape', []);\n  const pads = attributes.getInts('pads', [0, 0, 0, 0]);\n  const strides = attributes.getInts('strides', [1, 1]);\n\n  return createAttributeWithCacheKey({\n    autoPad,\n    dilations,\n    group,\n    kernelShape,\n    pads,\n    strides,\n    ...activationAttributes,\n  });\n};\n\nconst validateInputs = (inputs: Tensor[], attributes: ConvAttributes): void => {\n  // Refer to the below link for all input checks\n  // https://github.com/onnx/onnx/blob/main/docs/Operators.md#Conv\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Conv requires 2 or 3 inputs');\n  }\n\n  // TODO : Need to add support for multi-dimensional conv\n  if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {\n    throw new Error('currently only support 2-dimensional conv');\n  }\n\n  // FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\n  const dataChannel = inputs[0].dims[1];\n  const filterInChannel = inputs[1].dims[1] * attributes.group;\n  if (dataChannel !== filterInChannel) {\n    throw new Error('FILTER_IN_CHANNEL should be equal to DATA_CHANNEL');\n  }\n\n  // if bias is provided it should be 1D and the number of elements should be equal to the number of feature maps\n  if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {\n    throw new Error('invalid bias');\n  }\n\n  const spatialRank = inputs[0].dims.length - 2;\n  // wrong dilations dimension\n  if (attributes.dilations.length !== spatialRank) {\n    throw new Error(`dilations should be ${spatialRank}D`);\n  }\n\n  // Wrong strides dimension\n  if (attributes.strides.length !== spatialRank) {\n    throw new Error(`strides should be ${spatialRank}D`);\n  }\n\n  // Wrong pads dimension\n  if (attributes.pads.length !== spatialRank * 2) {\n    throw new Error(`pads should be ${spatialRank * 2}D`);\n  }\n\n  // if kernelShape is specified, it's data length must be 2 less than dims length of the weights tensor\n  // (the first 2 dims are batch_size and channels)\n  if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {\n    throw new Error('invalid kernel shape');\n  }\n\n  // TODO : Need to add support for float64\n  if (inputs[0].type !== 'float32' || inputs[1].type !== 'float32') {\n    throw new Error('Conv input(X,W) should be float tensor');\n  }\n\n  if (inputs.length === 3 && inputs[2].type !== 'float32') {\n    throw new Error('Conv input(bias) should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { InferenceHandler } from '../../../backend';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nimport { ConvAttributes } from './conv';\nimport { getActivationSnippet, parseInternalActivationAttributes } from './fuse-utils';\n\nconst computeTotalPad = (\n  inDim: number,\n  stride: number,\n  adj: number,\n  kernel: number,\n  dilation: number,\n  outSize: number,\n) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;\n\nconst distributePadding = (totalPad: number, autoPad: string, pads: number[], head: number, tail: number) => {\n  const smallPad = Math.floor(totalPad / 2);\n  if (autoPad === 'SAME_UPPER') {\n    pads[head] = smallPad;\n    pads[tail] = totalPad - smallPad;\n  } else if (autoPad === 'SAME_LOWER') {\n    pads[head] = totalPad - smallPad;\n    pads[tail] = smallPad;\n  }\n};\n\nconst calculateOutputShapeAndPads = (\n  inputShape: readonly number[],\n  kernelShape: readonly number[],\n  dilations: readonly number[],\n  autoPad: string,\n  pads: number[],\n  strides: readonly number[],\n  outputPadding: readonly number[],\n  outputShape: number[],\n) => {\n  const spatialRank = inputShape.length - 2;\n  const updateShape = outputShape.length === 0;\n  for (let i = 0; i < spatialRank; ++i) {\n    const outSize = updateShape ? inputShape[i + 2] * strides[i] : outputShape[i];\n    const totalPad = computeTotalPad(inputShape[i + 2], strides[i], pads[i], kernelShape[i], dilations[i], outSize);\n    distributePadding(totalPad, autoPad, pads, i, i + spatialRank);\n    if (updateShape) {\n      outputShape.push(\n        strides[i] * (inputShape[i + 2] - 1) +\n          outputPadding[i] +\n          (kernelShape[i] - 1) * dilations[i] +\n          1 -\n          pads[i] -\n          pads[i + spatialRank],\n      );\n    }\n  }\n};\n\nexport interface ConvTransposeAttributes extends ConvAttributes {\n  readonly outputPadding: readonly number[];\n  readonly outputShape: readonly number[];\n}\n\nexport const convTranspose: OperatorImplementation<ConvTransposeAttributes> = (\n  inferenceHandler: InferenceHandler,\n  inputs: Tensor[],\n  attributes: ConvTransposeAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes); // currently will fail if not convTranspose2D\n  return convTranspose2d(inferenceHandler, inputs, attributes);\n};\n\nconst convTranspose2d: OperatorImplementation<ConvTransposeAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ConvTransposeAttributes,\n): Tensor[] => {\n  const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);\n  return [convTranspose2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];\n};\n\nconst createConvTransposeProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'ConvTranspose',\n  inputNames: hasBias ? ['X', 'W', 'B'] : ['X', 'W'],\n  inputTypes: hasBias\n    ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked]\n    : [TextureType.unpacked, TextureType.unpacked],\n  cacheHint,\n});\n\nconst createUnpackedConvTransposeProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  metadata: ProgramMetadata,\n  attributes: ConvTransposeAttributes,\n): ProgramInfo => {\n  const hasBias = inputs.length > 2;\n  const valueInit = hasBias ? 'getB(output_channel)' : '0.0';\n  const xShape = inputs[0].dims;\n  const wShape = inputs[1].dims;\n  const outputChannelsPerGroup = wShape[1];\n  const inputChannelsPerGroup = wShape[0] / attributes.group;\n  const outputShape = [inputs[0].dims[0], inputs[1].dims[1] * attributes.group, ...attributes.outputShape];\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const { activationFunction, applyActivation } = getActivationSnippet(attributes);\n\n  const shaderSource = `\n  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});\n  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});\n  ${activationFunction}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${outputChannelsPerGroup};\n    int wOutChannel = output_channel - group_id * ${outputChannelsPerGroup};\n\n    float value = ${valueInit};\n    for (int inChannelOffset = 0; inChannelOffset < ${inputChannelsPerGroup}; inChannelOffset++) {\n      int input_channel = group_id * ${inputChannelsPerGroup} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${wShape[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${wShape[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${attributes.dilations[0]}, wHOff * ${attributes.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${xShape[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${xShape[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${applyActivation}\n    ${glsl.output} = vec4(value, .0, .0, .0);\n  }\n`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n    hasMain: true,\n  };\n};\n\nconst createUnpackedConvTransposeProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvTransposeAttributes,\n): ProgramInfoLoader => {\n  const metadata = createConvTransposeProgramMetadata(inputs.length > 2, attributes.cacheKey);\n  return {\n    ...metadata,\n    get: () => createUnpackedConvTransposeProgramInfo(inferenceHandler, inputs, metadata, attributes),\n  };\n};\n\nconst convTranspose2DUnpacked = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: readonly Tensor[],\n  attributes: ConvTransposeAttributes,\n): Tensor => {\n  const result = inferenceHandler.run(\n    createUnpackedConvTransposeProgramInfoLoader(inferenceHandler, inputs, attributes),\n    inputs,\n  );\n  return result;\n};\n\nconst getAdjustedConvTransposeAttributes = <T extends ConvTransposeAttributes>(attributes: T, inputs: Tensor[]): T => {\n  const kernelShape = attributes.kernelShape.slice();\n  // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims\n  if (attributes.kernelShape.length === 0) {\n    for (let i = 2; i < inputs[1].dims.length; ++i) {\n      kernelShape.push(inputs[1].dims[i]);\n    }\n  }\n\n  const pads = attributes.pads.slice();\n  const outputShape = attributes.outputShape.slice();\n  const inputShape = inputs[0].dims;\n  // If outputShape is not specified in the attributes of this op, infer it from the parameters\n  // Similarly, automatically infer pads if not specified\n  calculateOutputShapeAndPads(\n    inputShape,\n    kernelShape,\n    attributes.dilations,\n    attributes.autoPad,\n    pads,\n    attributes.strides,\n    attributes.outputPadding,\n    outputShape,\n  );\n\n  // always return a new object so does not modify the original attributes\n  const newAttributes: T = Object.assign({}, attributes);\n  Object.assign(newAttributes, { kernelShape, pads, outputShape, cacheKey: attributes.cacheKey });\n  return newAttributes;\n};\n\nexport const parseConvTransposeAttributes: OperatorInitialization<ConvTransposeAttributes> = (\n  node: Graph.Node,\n): ConvTransposeAttributes => {\n  const attributes = node.attributes;\n  const activationAttributes = parseInternalActivationAttributes(attributes);\n  // TODO : Make this generic enough to compute default attributes for multi-dimensional conv\n  const autoPad = attributes.getString('auto_pad', 'NOTSET');\n  const dilations = attributes.getInts('dilations', [1, 1]);\n  const group = attributes.getInt('group', 1);\n  const kernelShape = attributes.getInts('kernel_shape', []);\n  const outputPadding = attributes.getInts('output_padding', [0, 0]);\n  const outputShape = attributes.getInts('output_shape', []);\n  const pads = attributes.getInts('pads', [0, 0, 0, 0]);\n  const strides = attributes.getInts('strides', [1, 1]);\n\n  return createAttributeWithCacheKey({\n    autoPad,\n    dilations,\n    group,\n    kernelShape,\n    outputPadding,\n    outputShape,\n    pads,\n    strides,\n    ...activationAttributes,\n  });\n};\n\nconst validateInputs = (inputs: Tensor[], attributes: ConvTransposeAttributes): void => {\n  // Refer to the below link for all input checks\n  // https://github.com/onnx/onnx/blob/main/docs/Operators.md#Conv\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Conv requires 2 or 3 inputs');\n  }\n\n  // TODO : Need to add support for multi-dimensional conv\n  if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {\n    throw new Error('currently only support 2-dimensional conv');\n  }\n\n  // FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\n  const dataChannel = inputs[0].dims[1];\n  const filterInChannel = inputs[1].dims[0];\n  if (dataChannel !== filterInChannel) {\n    throw new Error('FILTER_IN_CHANNEL should be equal to DATA_CHANNEL');\n  }\n\n  const featureMaps = inputs[1].dims[1] * attributes.group;\n\n  // if bias is provided it should be 1D and the number of elements should be equal to the number of feature maps\n  if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {\n    throw new Error('invalid bias');\n  }\n\n  const spatialRank = inputs[0].dims.length - 2;\n  // wrong dilations dimension\n  if (attributes.dilations.length !== spatialRank) {\n    throw new Error(`dilations should be ${spatialRank}D`);\n  }\n\n  // Wrong strides dimension\n  if (attributes.strides.length !== spatialRank) {\n    throw new Error(`strides should be ${spatialRank}D`);\n  }\n\n  // Wrong pads dimension\n  if (attributes.pads.length !== spatialRank * 2) {\n    throw new Error(`pads should be ${spatialRank * 2}D`);\n  }\n\n  // Wrong output padding dimension\n  if (attributes.outputPadding.length !== spatialRank) {\n    throw new Error(`output_padding should be ${spatialRank}D`);\n  }\n\n  // if kernelShape is specified, it's data length must be 2 less than dims length of the weights tensor\n  // (the first 2 dims are batch_size and channels)\n  if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {\n    throw new Error('invalid kernel shape');\n  }\n\n  // as with kernelShape, must have same number of spatial dims as input\n  if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {\n    throw new Error('invalid output shape');\n  }\n\n  // TODO : Need to add support for float64\n  if (inputs[0].type !== 'float32' || inputs[1].type !== 'float32') {\n    throw new Error('ConvTranspose input(X,W) should be float tensor');\n  }\n\n  if (inputs.length === 3 && inputs[2].type !== 'float32') {\n    throw new Error('ConvTranspose input(bias) should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface TransposeAttributes extends AttributeWithCacheKey {\n  readonly perm: number[];\n}\n\nconst transposeProgramMetadata = {\n  name: 'Transpose',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const transpose: OperatorImplementation<TransposeAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: TransposeAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(\n    {\n      ...transposeProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createTransposeProgramInfo(inferenceHandler, inputs[0], attributes.perm),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseTransposeAttributes: OperatorInitialization<TransposeAttributes> = (\n  node: Graph.Node,\n): TransposeAttributes => createAttributeWithCacheKey({ perm: node.attributes.getInts('perm', []) });\n\nconst createTransposeProgramInfo = (\n  _inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  perm: number[],\n): ProgramInfo => {\n  const inputShape = input.dims;\n  perm = getAdjustedPerm(inputShape, perm);\n  const unpackedOutputShape = getOutputShape(inputShape, perm);\n  const rank = inputShape.length;\n  // A dims=[${inputs[0].dims.toString()}]\n  // out Dims=[${unpackedOutputShape.toString()}]\n  // based on perm=[${perm.toString()}]\n  const shaderSource = `\n      ${getPermFunctionBody('perm', perm, rank)}\n      float process(int indices[${rank}]) {\n        int a[${rank}];\n        perm(a, indices);\n        return _A(a);\n      }`;\n  return {\n    ...transposeProgramMetadata,\n    output: { dims: unpackedOutputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst getAdjustedPerm = (inputShape: readonly number[], perm: number[]): number[] => {\n  if (perm && perm.length !== inputShape.length) {\n    perm = [...inputShape.keys()].reverse();\n  }\n  return perm;\n};\n\nconst getOutputShape = (inputShape: readonly number[], perm: number[]): readonly number[] => {\n  perm = getAdjustedPerm(inputShape, perm);\n  return ShapeUtil.sortBasedOnPerm(inputShape, perm);\n};\n\nconst getPermFunctionBody = (name: string, perm: number[], rank: number): string => {\n  const reverseFunc = [];\n  reverseFunc.push(`void ${name}(out int a[${rank}], int src[${rank}]) {`);\n  for (let i = 0; i < rank; ++i) {\n    reverseFunc.push(`\\ta[${perm[i]}]=src[${i}];`);\n  }\n  reverseFunc.push('\\t}');\n  return reverseFunc.join('\\n');\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Transpose requires 1 input.');\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('input should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nimport { transpose, TransposeAttributes } from './transpose';\n\nexport interface DepthToSpaceAttributes {\n  mode: 'DCR' | 'CRD';\n  blocksize: number;\n}\n\nexport const depthToSpace: OperatorImplementation<DepthToSpaceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: DepthToSpaceAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const blocksize = attributes.blocksize;\n  const blocksizeSqr = blocksize * blocksize;\n  const transposePerm = attributes.mode === 'DCR' ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];\n  const firstReshapeShape =\n    attributes.mode === 'DCR'\n      ? [\n          inputs[0].dims[0],\n          blocksize,\n          blocksize,\n          inputs[0].dims[1] / blocksizeSqr,\n          inputs[0].dims[2],\n          inputs[0].dims[3],\n        ]\n      : [\n          inputs[0].dims[0],\n          inputs[0].dims[1] / blocksizeSqr,\n          blocksize,\n          blocksize,\n          inputs[0].dims[2],\n          inputs[0].dims[3],\n        ];\n\n  // const transpose = new WebGLTranspose();\n  // const attributes = new Attribute(undefined);\n  // attributes.set('perm', 'ints', transposePerm);\n  // transpose.initialize(attributes);\n\n  // First reshape\n  const firstReshapedTensor = inferenceHandler.reshapeUnpacked(inputs[0], firstReshapeShape);\n\n  // transpose\n  const transposeAttributes: TransposeAttributes = { perm: transposePerm, cacheKey: `${transposePerm}` };\n  const [transposeOutput] = transpose(inferenceHandler, [firstReshapedTensor], transposeAttributes);\n\n  // Second reshape\n  const secondReshapeShape = [\n    inputs[0].dims[0],\n    inputs[0].dims[1] / blocksizeSqr,\n    inputs[0].dims[2] * blocksize,\n    inputs[0].dims[3] * blocksize,\n  ];\n  const result = inferenceHandler.reshapeUnpacked(transposeOutput, secondReshapeShape);\n  return [result];\n};\n\nexport const parseDepthToSpaceAttributes: OperatorInitialization<DepthToSpaceAttributes> = (\n  node: Graph.Node,\n): DepthToSpaceAttributes => {\n  // processing node attributes\n  const blocksize = node.attributes.getInt('blocksize');\n  if (blocksize < 1) {\n    throw new Error(`blocksize must be >= 1, but got : ${blocksize} for DepthToSpace`);\n  }\n  const mode = node.attributes.getString('mode', 'DCR');\n  if (mode !== 'DCR' && mode !== 'CRD') {\n    throw new Error(`unrecognized mode: ${mode} for DepthToSpace`);\n  }\n  return { mode, blocksize };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (inputs.length !== 1) {\n    throw new Error(`DepthToSpace expect 1 inputs, but got ${inputs.length}`);\n  }\n\n  // Input has to be a 4-D tensor\n  // TODO: Support string depth-to-space.\n  if (inputs[0].type === 'string' || inputs[0].dims.length !== 4) {\n    throw new TypeError('DepthToSpace input should be a 4-D numeric tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const flatten: OperatorImplementation<number> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  axis: number,\n): Tensor[] => {\n  validateInputs(inputs, axis);\n\n  const outputDims = ShapeUtil.flattenShape(inputs[0].dims, axis);\n  return [inferenceHandler.reshapeUnpacked(inputs[0], outputDims)];\n};\n\nexport const parseFlattenAttributes: OperatorInitialization<number> = (node: Graph.Node): number =>\n  node.attributes.getInt('axis', 1); // default axis is 1\n\nconst validateInputs = (inputs: Tensor[], axis: number): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Flatten requires 1 input.');\n  }\n\n  const r = inputs[0].dims.length;\n  if (r === 0) {\n    throw new Error('scalar tensor is not supported.');\n  }\n\n  if (axis < -r || axis > r) {\n    throw new Error('Invalid axis');\n  }\n\n  // TODO: Support string type\n  if (inputs[0].type === 'string') {\n    throw new Error('string tensor is not supported.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceHandler } from './backend';\nimport { Graph } from './graph';\nimport { Tensor } from './tensor';\n\nexport type OperatorImplementation<T> = (inferenceHandler: InferenceHandler, inputs: Tensor[], context: T) => Tensor[];\nexport type OperatorInitialization<T> = (node: Graph.Node, graph: Graph) => T;\n\nexport interface Operator {\n  readonly impl: OperatorImplementation<unknown>;\n  readonly context: Graph.Node | unknown;\n}\n\nexport const NUMBER_TYPES: readonly Tensor.DataType[] = [\n  'float32',\n  'float64',\n  'int32',\n  'int16',\n  'int8',\n  'uint16',\n  'uint32',\n  'uint8',\n];\nexport const INT_TYPES: readonly Tensor.DataType[] = ['int32', 'int16', 'int8', 'uint16', 'uint32', 'uint8'];\nexport const FLOAT_TYPES: readonly Tensor.DataType[] = ['float32', 'float64'];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { NUMBER_TYPES, OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\ninterface GatherAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nexport const gather: OperatorImplementation<GatherAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: GatherAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes.axis);\n  const output = inferenceHandler.run(createGatherProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n  return [output];\n};\n\nexport const parseGatherAttributes: OperatorInitialization<GatherAttributes> = (node: Graph.Node): GatherAttributes =>\n  createAttributeWithCacheKey({ axis: node.attributes.getInt('axis', 0) });\n\nconst gatherProgramMetadata = {\n  name: 'Gather',\n  inputNames: ['A', 'B'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked],\n};\n\nconst createGatherProgramInfo = (\n  _handler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  axis: number,\n): ProgramInfo => {\n  const inputShape = inputs[0].dims.slice();\n  const indexDataShape = inputs[1].dims.slice();\n  const outputShape = new Array(inputShape.length + indexDataShape.length - 1);\n\n  axis = ShapeUtil.normalizeAxis(axis, inputShape.length);\n  const indexCopyOps: string[] = [];\n  for (let i = 0; i < outputShape.length; i++) {\n    // outputShape is divided into three parts: A, B, C\n    // |0        axis|  axis + indexDataShape.length |          end|\n    // |     A       |             B                 |      C      |\n    //\n    // inputIdx: [A, inputs[1][B], C]\n    if (i < axis) {\n      // A\n      outputShape[i] = inputShape[i];\n      indexCopyOps.push(`inputIdx[${i}] = outputIdx[${i}];`);\n    } else {\n      if (i < axis + indexDataShape.length) {\n        // B\n        outputShape[i] = indexDataShape[i - axis];\n        indexCopyOps.push(`indexDataIdx[${i - axis}] = outputIdx[${i}];`);\n      } else {\n        // C\n        outputShape[i] = inputShape[i - indexDataShape.length + 1]; // skip 1 for axis\n        indexCopyOps.push(`inputIdx[${i - indexDataShape.length + 1}] = outputIdx[${i}];`);\n      }\n    }\n  }\n\n  const orank = outputShape.length || 1;\n  const irank = inputShape.length;\n  const iDrank = indexDataShape.length || 1;\n  const shaderSource = `\n      float process(int outputIdx[${orank}]) {\n        int inputIdx[${irank}];\n        int indexDataIdx[${iDrank}];\n        indexDataIdx[0] = 0;\n        ${indexCopyOps.join('\\n        ')}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${axis}] = idx < 0 ? idx + ${inputShape[axis]} : idx;\n        return _A(inputIdx);\n      }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst createGatherProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: GatherAttributes,\n): ProgramInfoLoader => {\n  const metadata = { ...gatherProgramMetadata, cacheHint: attributes.cacheKey };\n  return { ...metadata, get: () => createGatherProgramInfo(handler, metadata, inputs, attributes.axis) };\n};\n\nconst validateInputs = (inputs: Tensor[], axis: number): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Gather requires 2 inputs.');\n  }\n  const tensorRank = inputs[0].dims.length;\n  if (tensorRank < 1) {\n    throw new Error('Invalid input shape.');\n  }\n  if (axis < -tensorRank || axis > tensorRank - 1) {\n    throw new Error('Invalid axis.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invaid input type.');\n  }\n  if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {\n    throw new Error('Invaid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { GemmUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nexport interface GemmAttributes extends AttributeWithCacheKey {\n  transA: boolean;\n  transB: boolean;\n  alpha: number;\n  beta: number;\n  isOptionalC: boolean; // in opset 11, C becomes optional\n}\n\nexport const gemm: OperatorImplementation<GemmAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: GemmAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes);\n  const output = inferenceHandler.run(createGemmProgramInfoLoader(inputs, attributes), inputs);\n  return [output];\n};\n\nconst parseGemmAttributes = (node: Graph.Node, isOptionalC: boolean): GemmAttributes => {\n  const transA = node.attributes.getInt('transA', 0) !== 0;\n  const transB = node.attributes.getInt('transB', 0) !== 0;\n  const alpha = node.attributes.getFloat('alpha', 1.0);\n  const beta = node.attributes.getFloat('beta', 1.0);\n  return createAttributeWithCacheKey({ transA, transB, alpha, beta, isOptionalC });\n};\n\nexport const parseGemmAttributesV7: OperatorInitialization<GemmAttributes> = (node: Graph.Node): GemmAttributes =>\n  parseGemmAttributes(node, false);\n\nexport const parseGemmAttributesV11: OperatorInitialization<GemmAttributes> = (node: Graph.Node): GemmAttributes =>\n  parseGemmAttributes(node, true);\n\nconst createGemmProgramInfoLoader = (inputs: Tensor[], attributes: GemmAttributes): ProgramInfoLoader => {\n  const metadata = {\n    name: 'Gemm',\n    inputNames: inputs.length === 3 ? ['A', 'B', 'C'] : ['A', 'B'],\n    inputTypes:\n      inputs.length === 3\n        ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked]\n        : [TextureType.unpacked, TextureType.unpacked],\n    key: attributes.cacheKey,\n  };\n\n  return { ...metadata, get: () => createGemmProgramInfo(metadata, inputs, attributes) };\n};\n\nconst createGemmProgramInfo = (\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  attributes: GemmAttributes,\n): ProgramInfo => {\n  const aShape = inputs[0].dims.slice();\n  const bShape = inputs[1].dims.slice();\n  const [M, N] = GemmUtil.getShapeOfGemmResult(\n    aShape,\n    attributes.transA,\n    bShape,\n    attributes.transB,\n    inputs.length === 3 ? inputs[2].dims : undefined,\n  );\n  const outputShape = [M, N];\n  if (!outputShape) {\n    throw new Error(\"Can't use gemm on the given tensors\");\n  }\n  let sharedDim = aShape[aShape.length - 1];\n  let line = '';\n  if (attributes.transA) {\n    sharedDim = aShape[0];\n  }\n  if (attributes.transA && attributes.transB) {\n    line = 'value += _A_T(a) * _B_T(b);';\n  } else if (attributes.transA && !attributes.transB) {\n    line = 'value += _A_T(a) * _B(b);';\n  } else if (!attributes.transA && attributes.transB) {\n    line = 'value += _A(a) * _B_T(b);';\n  } else if (!attributes.transA && !attributes.transB) {\n    line = 'value += _A(a) * _B(b);';\n  }\n  const rank = outputShape.length;\n  const declareC = inputs.length === 3 ? `int c[${inputs[2].dims.length}];` : '';\n  const broadcastC = inputs.length === 3 ? 'bcastIndices_C(indices, c);' : '';\n  const calculateC = inputs.length === 3 ? 'value += beta * _C(c);' : '';\n  const shaderSource = `\n      float process(int indices[${rank}]) {\n          int a[${rank}];\n          int b[${rank}];\n          ${declareC}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${broadcastC}\n\n          float value = 0.0;\n          for (int k=0; k<${sharedDim}; ++k) {\n              a[${rank - 1}] = k;\n              b[${rank - 2}] = k;\n              ${line}\n          }\n\n          value = value * alpha;\n          ${calculateC}\n          return value;\n      }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    variables: [\n      { name: 'alpha', type: 'float', data: attributes.alpha },\n      { name: 'beta', type: 'float', data: attributes.beta },\n    ],\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[], attributes: GemmAttributes): void => {\n  if (!inputs) {\n    throw new Error('Input is missing');\n  }\n  if (attributes.isOptionalC && (inputs.length < 2 || inputs.length > 3)) {\n    throw new Error('Invaid input shape.');\n  }\n  if (!attributes.isOptionalC && inputs.length !== 3) {\n    throw new Error('Gemm requires 3 inputs');\n  }\n\n  // 'C' can be of dimensionality 1 or 2 only\n  if (inputs.length === 3 && inputs[2].dims.length !== 1 && inputs[2].dims.length !== 2) {\n    throw new Error('Invalid input shape of C');\n  }\n\n  if (\n    (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') ||\n    (inputs[1].type !== 'float32' && inputs[1].type !== 'float64') ||\n    (inputs.length === 3 && inputs[2].type !== 'float32' && inputs[2].type !== 'float64')\n  ) {\n    throw new Error('Invalid input type.');\n  }\n\n  if (inputs[0].type !== inputs[1].type || (inputs.length === 3 && inputs[0].type !== inputs[2].type)) {\n    throw new Error('Input types are mismatched');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nexport interface ImageScalerAttributes extends AttributeWithCacheKey {\n  scale: number;\n  bias: number[];\n}\n\nexport const imageScaler: OperatorImplementation<ImageScalerAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ImageScalerAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(createImageScalerProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n  return [output];\n};\n\nexport const parseImageScalerAttributes: OperatorInitialization<ImageScalerAttributes> = (\n  node: Graph.Node,\n): ImageScalerAttributes => {\n  const scale = node.attributes.getFloat('scale');\n  const bias = node.attributes.getFloats('bias');\n  return createAttributeWithCacheKey({ scale, bias });\n};\n\nconst imageScalerProgramMetadata = {\n  name: 'ImageScaler',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst createImageScalerProgramInfo = (\n  _handler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  inputs: Tensor[],\n  attributes: ImageScalerAttributes,\n): ProgramInfo => {\n  const outputShape = inputs[0].dims.slice();\n  const rank = outputShape.length;\n  const getBiasMethod = createGetBiasMethod(attributes.bias.length);\n  const shaderSource = `\n      ${getBiasMethod}\n      float process(int indices[${rank}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    variables: [\n      { name: 'bias', type: 'float', arrayLength: attributes.bias.length, data: attributes.bias },\n      { name: 'scale', type: 'float', data: attributes.scale },\n    ],\n    shaderSource,\n  };\n};\n\nconst createImageScalerProgramInfoLoader = (\n  handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ImageScalerAttributes,\n): ProgramInfoLoader => {\n  const metadata = { ...imageScalerProgramMetadata, cacheHint: attributes.cacheKey };\n  return { ...metadata, get: () => createImageScalerProgramInfo(handler, metadata, inputs, attributes) };\n};\n\nconst createGetBiasMethod = (numChannels: number): string => {\n  const codeLines: string[] = [`float getBias(float bias[${numChannels}], int channel) {`];\n  for (let i = 0; i < numChannels; ++i) {\n    if (i === 0) {\n      codeLines.push('\\t' + `if (channel == ${i}) { return bias[${i}]; }`);\n    } else if (i === numChannels - 1) {\n      codeLines.push('\\t' + `else { return bias[${i}]; }`);\n    } else {\n      codeLines.push('\\t' + `else if (channel == ${i}) { return bias[${i}]; }`);\n    }\n  }\n  codeLines.push('\\t' + '}');\n  return codeLines.join('\\n');\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('ImageScaler requires 1 input.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('Invalid input shape.');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType } from '../types';\n\nexport const instanceNormalization: OperatorImplementation<number> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  epsilon: number,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  const meanAndVariance = inferenceHandler.run(createMeanAndVarianceProgramInfoLoader(inputs[0]), inputs);\n  const output = inferenceHandler.run(\n    createComputeOutputProgramInfoLoader(inferenceHandler, inputs[0], epsilon, meanAndVariance.dims),\n    [inputs[0], meanAndVariance, inputs[1], inputs[2]],\n  );\n  return [output];\n};\n\nexport const parseInstanceNormalizationAttributes: OperatorInitialization<number> = (node: Graph.Node): number =>\n  node.attributes.getFloat('epsilon', 1e-5);\n\nconst meanAndVarianceProgramMetadata = {\n  name: 'InstanceNormalization_MeanAndVariance',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst createMeanAndVarianceProgramInfo = (metadata: ProgramMetadata, input: Tensor): ProgramInfo => {\n  const xDims = input.dims.slice();\n  const channel = xDims[1];\n  const channelSize = xDims[2] * xDims[3];\n  const outputShape = [xDims[0], channel];\n\n  const shaderSource = `\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${xDims[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${xDims[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${channelSize});\n        temp = 0.0;\n        for(int a2=0; a2<${xDims[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${xDims[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${channelSize});\n\n        return v;\n      }`;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: input.type, textureType: TextureType.packedLastDimension },\n    shaderSource,\n  };\n};\n\nconst createMeanAndVarianceProgramInfoLoader = (input: Tensor): ProgramInfoLoader => ({\n  ...meanAndVarianceProgramMetadata,\n  get: () => createMeanAndVarianceProgramInfo(meanAndVarianceProgramMetadata, input),\n});\n\nconst computeOutputProgramMetadata = {\n  name: 'InstanceNormalization_ComputeOutput',\n  inputNames: ['X', 'MeanAndVariance', 'Scale', 'B'],\n  inputTypes: [TextureType.unpacked, TextureType.packedLastDimension, TextureType.unpacked, TextureType.unpacked],\n};\n\nconst createComputeOutputProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  metadata: ProgramMetadata,\n  input: Tensor,\n  epsilon: number,\n  meanAndVarianceShape: readonly number[],\n): ProgramInfo => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    meanAndVarianceShape,\n    TextureType.packedLastDimension,\n  );\n  const [meanAndVarianceWidth, meanAndVarianceHeight] = [textureWidth / 4, textureHeight];\n  const shaderSource = `\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${meanAndVarianceWidth}, ${meanAndVarianceHeight});\n        return ${glsl.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;\n  return {\n    ...metadata,\n    output: { dims: input.dims, type: input.type, textureType: TextureType.unpacked },\n    variables: [{ name: 'epsilon', type: 'float', data: epsilon }],\n    shaderSource,\n  };\n};\n\nconst createComputeOutputProgramInfoLoader = (\n  inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  epsilon: number,\n  meanAndVarianceShape: readonly number[],\n): ProgramInfoLoader => {\n  const metadata = { ...computeOutputProgramMetadata, cacheHint: `${epsilon}` };\n  return {\n    ...metadata,\n    get: () => createComputeOutputProgramInfo(inferenceHandler, metadata, input, epsilon, meanAndVarianceShape),\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 3) {\n    throw new Error('InstanceNormalization requires 3 inputs.');\n  }\n\n  const X = inputs[0];\n  const scale = inputs[1];\n  const B = inputs[2];\n\n  // input should at least have three dimensions - N,C,dim1,...,dimn\n  // other inputs can have only one dimensions\n  if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1) {\n    throw new Error('Invalid input shape.');\n  }\n  if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1]) {\n    throw new Error('Input shapes are mismatched.');\n  }\n  if (\n    (X.type !== 'float32' && X.type !== 'float64') ||\n    (scale.type !== 'float32' && scale.type !== 'float64') ||\n    (B.type !== 'float32' && B.type !== 'float64')\n  ) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('Only support 4-D input shape.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramInfoLoader, TextureType } from '../types';\n\nexport interface LrnAttributes extends AttributeWithCacheKey {\n  alpha: number;\n  beta: number;\n  bias: number;\n  size: number;\n}\n\nexport const lrn: OperatorImplementation<LrnAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: LrnAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  // if (inferenceHandler.session.pack) {\n  //   return [inferenceHandler.run(createPackedLrnProgramInfoLoader(inferenceHandler, inputs, attributes),\n  //   inputs)];\n  // } else {\n  return [inferenceHandler.run(createLrnProgramInfoLoader(inputs, attributes), inputs)];\n  //}\n};\n\nexport const parseLrnAttributes: OperatorInitialization<LrnAttributes> = (node: Graph.Node): LrnAttributes => {\n  const alpha = node.attributes.getFloat('alpha', 0.0001);\n  const beta = node.attributes.getFloat('beta', 0.75);\n  const bias = node.attributes.getFloat('bias', 1.0);\n  const size = node.attributes.getInt('size');\n\n  return createAttributeWithCacheKey({ alpha, beta, bias, size });\n};\n\nconst lrnProgramMetadata = {\n  name: 'LRN',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nfunction createLrnProgramInfo(inputs: Tensor[], attributes: LrnAttributes): ProgramInfo {\n  const C = inputs[0].dims[1];\n  const rank = inputs[0].dims.length;\n  const from = -Math.floor((attributes.size - 1) / 2);\n  const to = Math.ceil((attributes.size - 1) / 2);\n  const alpha = `float(${attributes.alpha}) / float(${attributes.size})`;\n  const bias = `float(${attributes.bias})`;\n  const beta = `float(${attributes.beta})`;\n\n  const shaderSource = `\n    float process(int indices[${rank}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${from}; i <= ${to}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${C}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(${bias} + ${alpha} * square_sum, ${beta});\n    }`;\n  return {\n    ...lrnProgramMetadata,\n    cacheHint: attributes.cacheKey,\n    output: { dims: inputs[0].dims, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n}\n\nexport function createLrnProgramInfoLoader(inputs: Tensor[], attributes: LrnAttributes): ProgramInfoLoader {\n  return { ...lrnProgramMetadata, cacheHint: attributes.cacheKey, get: () => createLrnProgramInfo(inputs, attributes) };\n}\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('LRN requires 1 input.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('currently only support LRN for input with \"NCHW\" format');\n  }\n  if (inputs[0].type !== 'float32') {\n    throw new Error('input should be float type');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { getGlsl, Glsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface PadAttributes extends AttributeWithCacheKey {\n  readonly mode: string;\n  readonly pads: number[];\n  readonly value: number;\n}\n\nconst padProgramMetadata = {\n  name: 'Pad',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const padV2: OperatorImplementation<PadAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: PadAttributes,\n): Tensor[] => {\n  validateInputsV2(inputs);\n  const output = inferenceHandler.run(\n    {\n      ...padProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createPadProgramInfo(inferenceHandler, inputs[0], attributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parsePadAttributesV2: OperatorInitialization<PadAttributes> = (node: Graph.Node): PadAttributes => {\n  const mode = node.attributes.getString('mode', 'constant');\n  const value = node.attributes.getFloat('value', 0.0);\n  const pads = node.attributes.getInts('pads');\n  return createAttributeWithCacheKey({ mode, value, pads });\n};\n\nexport const padV11: OperatorImplementation<string> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  mode: string,\n): Tensor[] => {\n  validateInputsV11(inputs);\n  const attrubutes = generatePadAttributesFromInputs(inferenceHandler, inputs, mode);\n  return padV2(inferenceHandler, [inputs[0]], attrubutes);\n};\n\nexport const parsePadAttributesV11: OperatorInitialization<string> = (node: Graph.Node): string =>\n  node.attributes.getString('mode', 'constant');\n\nconst generatePadAttributesFromInputs = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  mode: string,\n): PadAttributes => {\n  if (\n    !inferenceHandler.session.isInitializer(inputs[1].dataId) ||\n    (inputs.length >= 3 && !inferenceHandler.session.isInitializer(inputs[2].dataId))\n  ) {\n    throw new Error('dynamic pad attributes are not allowed');\n  }\n\n  const pads = Array.from(inputs[1].integerData);\n  const value = inputs.length >= 3 ? inputs[2].floatData[0] : 0.0;\n\n  return createAttributeWithCacheKey({ mode, pads, value });\n};\n\nconst createPadProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  attributes: PadAttributes,\n): ProgramInfo => {\n  const outputShape = ShapeUtil.padShape(input.dims.slice(), attributes.pads);\n  const rank = outputShape.length;\n  const padFunction = getPadFunction(inferenceHandler, input, attributes);\n  const shaderSource = `\n      ${padFunction}\n      float process(int[${rank}] indices) {\n          return padA(indices);\n      }`;\n  return {\n    name: 'Pad',\n    inputNames: ['A'],\n    inputTypes: [TextureType.unpacked],\n    output: { dims: outputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputsV2 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Pad requires 1 input');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst validateInputsV11 = (inputs: Tensor[]): void => {\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Pad requires 2 or 3 inputs');\n  }\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 3 && inputs[2].type === 'string') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst getPadFunction = (inferenceHandler: WebGLInferenceHandler, input: Tensor, attributes: PadAttributes): string => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const [width, height] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, TextureType.unpacked);\n  const strides = ShapeUtil.computeStrides(input.dims);\n\n  switch (attributes.mode) {\n    case 'constant':\n      return getPadConstant(glsl, input.dims, strides, width, height, attributes.pads, attributes.value);\n    case 'reflect':\n      return getPadReflect(glsl, input.dims, strides, width, height, attributes.pads);\n    case 'edge':\n      return getPadEdge(glsl, input.dims, strides, width, height, attributes.pads);\n    default:\n      throw new Error('Invalid mode');\n  }\n};\n\nconst getPadConstant = (\n  glsl: Glsl,\n  shape: readonly number[],\n  strides: readonly number[],\n  width: number,\n  height: number,\n  pads: number[],\n  value: number,\n): string => {\n  const rank = shape.length;\n  let block = '';\n  for (let i = rank - 1; i >= 0; --i) {\n    block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0)  return constant;\n        if (k >= ${shape[i]}) return constant;\n        offset += k * ${strides[i]};\n        `;\n  }\n  return `\n      float padA(int m[${rank}]) {\n        const float constant = float(${value});\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n};\n\nconst getPadReflect = (\n  glsl: Glsl,\n  shape: readonly number[],\n  strides: readonly number[],\n  width: number,\n  height: number,\n  pads: number[],\n): string => {\n  const rank = shape.length;\n\n  let block = '';\n  for (let i = rank - 1; i >= 0; --i) {\n    block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2 * (shape[i] - 1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${shape[i]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${strides[i]};\n        `;\n  }\n  return `\n      float padA(int m[${rank}]) {\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n};\n\nconst getPadEdge = (\n  glsl: Glsl,\n  shape: readonly number[],\n  strides: readonly number[],\n  width: number,\n  height: number,\n  pads: number[],\n): string => {\n  const rank = shape.length;\n\n  let block = '';\n  for (let i = rank - 1; i >= 0; --i) {\n    block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0)  k = 0;\n        if (k >= ${shape[i]}) k = ${shape[i] - 1};\n        offset += k * ${strides[i]};\n      `;\n  }\n  return `\n      float padA(int m[${rank}]) {\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { PoolConvUtil, ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramMetadata, TextureType } from '../types';\n\nexport interface AveragePoolAttributes extends AttributeWithCacheKey {\n  readonly autoPad: string;\n  readonly ceilMode: number;\n  readonly countIncludePad: boolean;\n  readonly kernelShape: readonly number[];\n  readonly strides: readonly number[];\n  readonly pads: readonly number[];\n}\n\nexport const averagePool: OperatorImplementation<AveragePoolAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: AveragePoolAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const metadata = {\n    name: 'AveragePool',\n    inputNames: ['X'],\n    inputTypes: [TextureType.unpacked],\n    cacheHint: attributes.cacheKey,\n  };\n  const output = inferenceHandler.run(\n    { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, false, attributes) },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseAveragePoolAttributes: OperatorInitialization<AveragePoolAttributes> = (\n  node: Graph.Node,\n): AveragePoolAttributes => {\n  const autoPad = node.attributes.getString('auto_pad', 'NOTSET');\n  const ceilMode = node.attributes.getInt('ceil_mode', 0);\n  const countIncludePad = node.attributes.getInt('count_include_pad', 0) === 0 ? false : true;\n  const kernelShape = node.attributes.getInts('kernel_shape');\n  const strides = node.attributes.getInts('strides', []);\n  const pads = node.attributes.getInts('pads', []);\n\n  // TODO: support attribute 'ceil_mode'\n  if (ceilMode !== 0) {\n    throw new Error('using ceil() in shape computation is not yet supported for AveragePool');\n  }\n\n  return createAttributeWithCacheKey({ autoPad, ceilMode, countIncludePad, kernelShape, strides, pads });\n};\n\nconst createAveragePoolProgramInfo = (\n  inputs: Tensor[],\n  metadata: ProgramMetadata,\n  isGlobalOperator: boolean,\n  attributes: AveragePoolAttributes,\n): ProgramInfo => {\n  const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(\n    inputs,\n    attributes,\n    isGlobalOperator,\n  );\n  const kernelSize = ShapeUtil.size(adjustedAttributes.kernelShape);\n  const op1 = 'value += _X(x);';\n  let op2 = '';\n  if (adjustedAttributes.countIncludePad) {\n    op2 += `value /= float(${kernelSize});`;\n  } else {\n    op2 += `value /= float(${kernelSize} - pad);`;\n  }\n  const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, '0.0');\n  const shaderSource = `\n        ${poolingCode}\n      `;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nexport const globalAveragePool: OperatorImplementation<AveragePoolAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: AveragePoolAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const metadata = {\n    name: 'GlobalAveragePool',\n    inputNames: ['X'],\n    inputTypes: [TextureType.unpacked],\n    cacheHint: `${attributes.countIncludePad}`,\n  };\n  const output = inferenceHandler.run(\n    { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, true, attributes) },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseGlobalAveragePoolAttributes: OperatorInitialization<AveragePoolAttributes> = (\n  node: Graph.Node,\n): AveragePoolAttributes => {\n  const countIncludePad = node.attributes.getInt('count_include_pad', 0) === 0 ? false : true;\n  return createAttributeWithCacheKey({\n    autoPad: '',\n    ceilMode: 0,\n    countIncludePad,\n    kernelShape: [],\n    strides: [],\n    pads: [],\n  });\n};\n\nexport interface MaxPoolAttributes extends AveragePoolAttributes {\n  readonly storageOrder: number;\n  readonly dilations: number[];\n}\n\nexport const maxPool: OperatorImplementation<MaxPoolAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: MaxPoolAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const metadata = {\n    name: 'MaxPool',\n    inputNames: ['X'],\n    inputTypes: [TextureType.unpacked],\n    cacheHint: attributes.cacheKey,\n  };\n  const output = inferenceHandler.run(\n    { ...metadata, get: () => createMaxPoolProgramInfo(inputs, metadata, false, attributes) },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseMaxPoolAttributes: OperatorInitialization<MaxPoolAttributes> = (\n  node: Graph.Node,\n): MaxPoolAttributes => {\n  const autoPad = node.attributes.getString('auto_pad', 'NOTSET');\n  const ceilMode = node.attributes.getInt('ceil_mode', 0);\n  const kernelShape = node.attributes.getInts('kernel_shape');\n  const strides = node.attributes.getInts('strides', []);\n  const pads = node.attributes.getInts('pads', []);\n  const storageOrder = node.attributes.getInt('storage_order', 0);\n  const dilations = node.attributes.getInts('dilations', []);\n\n  // TODO: support attribute 'ceil_mode' and 'storage_order'\n  if (storageOrder !== 0) {\n    throw new Error('column major storage order is not yet supported for MaxPool');\n  }\n  if (ceilMode !== 0) {\n    throw new Error('using ceil() in shape computation is not yet supported for MaxPool');\n  }\n\n  return createAttributeWithCacheKey({\n    autoPad,\n    ceilMode,\n    countIncludePad: false,\n    kernelShape,\n    strides,\n    pads,\n    storageOrder,\n    dilations,\n  });\n};\n\nconst createMaxPoolProgramInfo = (\n  inputs: Tensor[],\n  metadata: ProgramMetadata,\n  isGlobalOperator: boolean,\n  attributes: MaxPoolAttributes,\n): ProgramInfo => {\n  const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(\n    inputs,\n    attributes,\n    isGlobalOperator,\n  );\n  const op1 = `\n      value = max(_X(x), value);\n    `;\n  const op2 = '';\n  const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, '-1e5');\n  const shaderSource = `\n      ${poolingCode}\n    `;\n  return {\n    ...metadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst getAdjustedPoolAttributesAndOutputShape = (\n  inputs: Tensor[],\n  attributes: AveragePoolAttributes | MaxPoolAttributes,\n  isGlobalOperator: boolean,\n): [AveragePoolAttributes | MaxPoolAttributes, number[]] => {\n  const inputShape = inputs[0].dims.slice();\n  const hasDilations = Object.hasOwnProperty.call(attributes, 'dilations');\n  const kernelShape = attributes.kernelShape.slice();\n  const strides = attributes.strides.slice();\n  const dilations: number[] = hasDilations ? (attributes as MaxPoolAttributes).dilations.slice() : [];\n  const pads = attributes.pads.slice();\n  PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, dilations, pads);\n\n  const outputShape = PoolConvUtil.computePoolOutputShape(\n    isGlobalOperator,\n    inputShape,\n    strides,\n    dilations,\n    kernelShape,\n    pads,\n    attributes.autoPad,\n  );\n\n  const newAttributes = Object.assign({}, attributes);\n  if (hasDilations) {\n    Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });\n  } else {\n    Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });\n  }\n  return [newAttributes, outputShape];\n};\n\nconst globalMaxPoolAttributes = {\n  autoPad: '',\n  ceilMode: 0,\n  countIncludePad: false,\n  kernelShape: [],\n  strides: [],\n  pads: [],\n  storageOrder: 0,\n  dilations: [],\n  cacheKey: '',\n};\n\nconst globalMaxPoolMetadata = {\n  name: 'GlobalMaxPool',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const globalMaxPool = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(\n    {\n      ...globalMaxPoolMetadata,\n      get: () => createMaxPoolProgramInfo(inputs, globalMaxPoolMetadata, true, globalMaxPoolAttributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Pool ops requires 1 input.');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst generatePoolingCode = (\n  inputDims: readonly number[],\n  attributes: AveragePoolAttributes,\n  op1: string,\n  op2: string,\n  start: string,\n): string => {\n  const rank = inputDims.length;\n  if (attributes.kernelShape.length <= 2) {\n    const kw = attributes.kernelShape[attributes.kernelShape.length - 1];\n    const sw = attributes.strides[attributes.strides.length - 1];\n    const pwStart = attributes.pads[attributes.pads.length / 2 - 1];\n    const pwEnd = attributes.pads[attributes.pads.length - 1];\n    const dimW = inputDims[rank - 1];\n    let codeW = '';\n    let codeH = '';\n    let codeHEnd = '';\n    if (pwStart + pwEnd !== 0) {\n      codeW = `\n          for (int i = 0; i < ${kw}; i++) {\n            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;\n            if (x[${rank} - 1] < 0 || x[${rank} - 1] >= ${dimW}) {\n              pad++;\n              continue;\n            }\n            ${op1}\n          }`;\n    } else {\n      codeW = `\n          for (int i = 0; i < ${kw}; i++) {\n            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;\n            ${op1}\n          }`;\n    }\n\n    if (attributes.kernelShape.length === 2) {\n      const kh = attributes.kernelShape[attributes.kernelShape.length - 2];\n      const sh = attributes.strides[attributes.strides.length - 2];\n      const phStart = attributes.pads[attributes.pads.length / 2 - 2];\n      const phEnd = attributes.pads[attributes.pads.length - 2];\n      const dimH = inputDims[rank - 2];\n      if (phStart + phEnd !== 0) {\n        codeH = `\n            for (int j = 0; j < ${kh}; j++) {\n              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;\n              if (x[${rank} - 2] < 0 || x[${rank} - 2] >= ${dimH}) {\n                pad+= ${kw};\n                continue;\n              }\n          `;\n      } else {\n        codeH = `\n            for (int j = 0; j < ${kh}; j++) {\n              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;\n            `;\n      }\n      codeHEnd = `\n          }\n        `;\n    }\n\n    const poolingCode = `\n        float process(int indices[${rank}]) {\n          int x[${rank}];\n          copyVec(indices, x);\n\n          float value = ${start};\n          int pad = 0;\n          ${codeH}\n          ${codeW}\n          ${codeHEnd}\n          ${op2}\n          return value;\n        }\n      `;\n    return poolingCode;\n  } else {\n    const kernelSize = ShapeUtil.size(attributes.kernelShape);\n    const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);\n    const stridesRank = kernelStrides.length;\n    const padsRank = attributes.pads.length;\n    const offsetToIndicesFunction = offsetToIndices(stridesRank);\n    const copyInputDims = copyArray(inputDims, 'inputDims');\n    const copyPads = copyArray(attributes.pads, 'pads');\n    const copyKernelStrides = copyArray(kernelStrides, 'kernelStrides');\n    const copyStrides = copyArray(attributes.strides, 'strides');\n    const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);\n    let padCode = '';\n    if (hasPads) {\n      padCode = `\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${op1}\n          }`;\n    } else {\n      padCode = `\n          }\n          ${op1}\n        `;\n    }\n    const poolingCode = `\n        ${offsetToIndicesFunction}\n        float process(int indices[${rank}]) {\n          int x[${rank}];\n          copyVec(indices, x);\n          int offset[${stridesRank}];\n          int pads[${padsRank}];\n          int inputDims[${rank}];\n          int kernelStrides[${stridesRank}];\n          int strides[${stridesRank}];\n          ${copyPads}\n          ${copyInputDims}\n          ${copyStrides}\n          ${copyKernelStrides}\n\n          float value = ${start};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${kernelSize}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${rank} - ${stridesRank}; j < ${rank}; j++) {\n              x[j] = indices[j] * strides[j - ${rank} + ${stridesRank}]\n                + offset[j - ${rank} + ${stridesRank}] - pads[j - 2];\n              ${padCode}\n          }\n          ${op2}\n\n          return value;\n        }\n      `;\n    return poolingCode;\n  }\n};\n\nconst copyArray = (array: readonly number[], arrayName: string): string => {\n  let block = '';\n  for (let i = 0; i < array.length; i++) {\n    block += `\n      ${arrayName}[${i}] = ${array[i]};\n    `;\n  }\n  return block;\n};\n\nconst offsetToIndices = (rank: number): string => `\n  void offsetToIndices(int offset, int[${rank}] strides, out int[${rank}] indices) {\n    if (${rank} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${rank} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${rank} - 1] = offset;\n  }`;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { NUMBER_TYPES, OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramMetadata, TextureType } from '../types';\n\nexport interface ReduceAttributes extends AttributeWithCacheKey {\n  readonly axes: number[];\n  readonly keepDims: boolean;\n}\n\n// return [init ops, reduce ops, final ops]\ntype ReduceOp = (inputs: Tensor[], axes: number[]) => string[];\n\nconst reduce = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n  name: string,\n  reduceOp: ReduceOp,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  const reduceProgramMetadata = {\n    name,\n    inputNames: ['A'],\n    inputTypes: [TextureType.unpacked],\n  };\n\n  const output = inferenceHandler.run(\n    {\n      ...reduceProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createReduceProgramInfo(inferenceHandler, inputs, attributes, name, reduceOp, reduceProgramMetadata),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseReduceAttributes: OperatorInitialization<ReduceAttributes> = (node: Graph.Node): ReduceAttributes => {\n  const axes = node.attributes.getInts('axes', []);\n  const keepDims = node.attributes.getInt('keepdims', 1) === 1;\n  return createAttributeWithCacheKey({ axes, keepDims });\n};\n\nconst createReduceProgramInfo = (\n  _handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n  _name: string,\n  reduceOp: ReduceOp,\n  reduceProgramMetadata: ProgramMetadata,\n): ProgramInfo => {\n  const outputShape: number[] = [];\n  const iRank = inputs[0].dims.length || 1;\n\n  const idxCopy = []; // copy output indexes to input indexes\n\n  const axes = ShapeUtil.normalizeAxes(attributes.axes, inputs[0].dims.length);\n  const ops = reduceOp(inputs, axes);\n  let reduceOps = ops[1];\n\n  for (let k = 0; k < inputs[0].dims.length; k++) {\n    // if this axis is reduced\n    if (axes.indexOf(k) >= 0 || axes.length === 0) {\n      if (attributes.keepDims) {\n        outputShape.push(1);\n      } // else { remove the axis from outputShape; }\n\n      // loop over the d-th axis\n      reduceOps = `\n          for(int j${k} = 0; j${k} < ${inputs[0].dims[k]}; j${k}++) {\n            inputIdx[${k}] = j${k};\n            ${reduceOps}\n          }`;\n    } else {\n      idxCopy.push(`inputIdx[${k}] = outputIdx[${outputShape.length}];`);\n\n      outputShape.push(inputs[0].dims[k]);\n    }\n  }\n\n  const oRank = outputShape.length || 1;\n\n  const shaderSource = `\n      float process(int outputIdx[${oRank}]) {\n        float value;                 // final result\n        int inputIdx[${iRank}];      // addressing input data\n        ${idxCopy.join('\\n')}\n        ${ops[0]}       // init ops for reduce max/min\n        ${reduceOps}\n        ${ops[2]}       // final computation for reduce mean\n        return value;\n      }`;\n\n  return {\n    ...reduceProgramMetadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  // TODO: support Reduce* operators with 2 inputs.\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Reduce op requires 1 input.');\n  }\n\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n};\n\nexport const reduceSum: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (): string[] => ['value = 0.0;', 'value += _A(inputIdx);', ''];\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceSum', reduceOp);\n};\n\nexport const reduceMean: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n    let size = 1.0;\n    for (let k = 0; k < inputs[0].dims.length; k++) {\n      if (axes.indexOf(k) >= 0 || axes.length === 0) {\n        size *= inputs[0].dims[k];\n      }\n    }\n\n    return ['value = 0.0;', 'value += _A(inputIdx);', `value /= ${size}.;`]; // ensure real number with `.`\n  };\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceMean', reduceOp);\n};\n\nexport const reduceMax: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n    const idxZero = [];\n    for (let k = 0; k < inputs[0].dims.length; k++) {\n      if (axes.indexOf(k) >= 0 || axes.length === 0) {\n        idxZero.push(`inputIdx[${k}] = 0;`); // first element\n      }\n    }\n\n    return [`${idxZero.join('\\n')}\\nvalue = _A(inputIdx);`, 'value = max(value, _A(inputIdx));', ''];\n  };\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceMax', reduceOp);\n};\n\nexport const reduceMin: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n    const idxZero = [];\n    for (let k = 0; k < inputs[0].dims.length; k++) {\n      if (axes.indexOf(k) >= 0 || axes.length === 0) {\n        idxZero.push(`inputIdx[${k}] = 0;`); // first element\n      }\n    }\n\n    return [`${idxZero.join('\\n')}\\nvalue = _A(inputIdx);`, 'value = min(value, _A(inputIdx));', ''];\n  };\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceMin', reduceOp);\n};\n\nexport const reduceProd: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (): string[] => ['value = 1.0;', 'value *= _A(inputIdx);', ''];\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceProd', reduceOp);\n};\n\nexport const reduceLogSum: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (): string[] => ['value = 0.0;', 'value += _A(inputIdx);', 'value = log(value);'];\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceLogSum', reduceOp);\n};\n\nexport const reduceLogSumSquare: OperatorImplementation<ReduceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: ReduceAttributes,\n): Tensor[] => {\n  const reduceOp: ReduceOp = (): string[] => ['float t; value = 0.0;', 't = _A(inputIdx); value += t * t;', ''];\n  return reduce(inferenceHandler, inputs, attributes, 'ReduceLogSumSquare', reduceOp);\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const reshape = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  const reshapedDims = ShapeUtil.calculateReshapedDims(inputs[0].dims, inputs[1].integerData);\n  if (handler.session.pack) {\n    return [handler.reshapePacked(inputs[0], reshapedDims)];\n  } else {\n    return [handler.reshapeUnpacked(inputs[0], reshapedDims)];\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface UpsampleAttributes extends AttributeWithCacheKey {\n  readonly opset: number;\n  readonly isResize: boolean;\n  readonly mode: string;\n  readonly scales: number[];\n  readonly extrapolationValue: number;\n  readonly coordinateTransformMode: string;\n  readonly useExtrapolation: boolean;\n  readonly needRoiInput: boolean;\n  readonly nearestMode: string;\n  readonly cubicCoefficientA: number;\n  readonly excludeOutside: boolean;\n  readonly useNearest2xOptimization: boolean;\n  readonly roiInputIdx: number;\n  readonly scalesInputIdx: number;\n  readonly sizesInputIdx: number;\n}\n\nconst upsampleProgramMetadata = {\n  name: 'Upsample',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const upsample: OperatorImplementation<UpsampleAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: UpsampleAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes);\n  const output = inferenceHandler.run(\n    {\n      ...upsampleProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createUpsampleProgramInfo(inferenceHandler, inputs, attributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseUpsampleAttributesV7: OperatorInitialization<UpsampleAttributes> = (\n  node: Graph.Node,\n): UpsampleAttributes => parseUpsampleAttributes(node, 7);\n\nexport const parseUpsampleAttributesV9: OperatorInitialization<UpsampleAttributes> = (\n  node: Graph.Node,\n): UpsampleAttributes => parseUpsampleAttributes(node, 9);\n\nexport const parseUpsampleAttributes = (node: Graph.Node, opset: number): UpsampleAttributes => {\n  const isResize = opset >= 10;\n\n  // processing node attributes\n  const mode = node.attributes.getString('mode', 'nearest');\n  if (mode !== 'nearest' && mode !== 'linear' && (opset < 11 || mode !== 'cubic')) {\n    throw new Error(`unrecognized mode: ${mode}`);\n  }\n\n  let scales: number[] = [];\n  if (opset < 9) {\n    scales = node.attributes.getFloats('scales');\n    scalesValidation(scales, mode, isResize);\n  }\n\n  const extrapolationValue = node.attributes.getFloat('extrapolation_value', 0.0);\n\n  const coordinateTransformMode =\n    opset > 10 ? node.attributes.getString('coordinate_transformation_mode', 'half_pixel') : 'asymmetric';\n  if (\n    [\n      'asymmetric',\n      'pytorch_half_pixel',\n      'tf_half_pixel_for_nn',\n      'align_corners',\n      'tf_crop_and_resize',\n      'half_pixel',\n    ].indexOf(coordinateTransformMode) === -1\n  ) {\n    throw new Error(`coordinate_transform_mode '${coordinateTransformMode}' is not supported`);\n  }\n  const needRoiInput = coordinateTransformMode === 'tf_crop_and_resize';\n  const useExtrapolation = needRoiInput;\n\n  const nearestMode =\n    mode === 'nearest' && opset >= 11 ? node.attributes.getString('nearest_mode', 'round_prefer_floor') : '';\n  if (['round_prefer_floor', 'round_prefer_ceil', 'floor', 'ceil', ''].indexOf(nearestMode) === -1) {\n    throw new Error(`nearest_mode '${nearestMode}' is not supported`);\n  }\n\n  const cubicCoefficientA = node.attributes.getFloat('cubic_coeff_a', -0.75);\n  const excludeOutside = node.attributes.getInt('exclude_outside', 0) !== 0;\n  if (excludeOutside && mode !== 'cubic') {\n    throw new Error('exclude_outside can be set to 1 only when mode is CUBIC.');\n  }\n\n  const useNearest2xOptimization =\n    opset < 11 ? true : mode === 'nearest' && coordinateTransformMode === 'asymmetric' && nearestMode === 'floor';\n\n  let roiInputIdx = 0;\n  let scalesInputIdx = 0;\n  let sizesInputIdx = 0;\n\n  if (opset > 10) {\n    // handle when roiInput is not given\n    if (node.inputs.length > 2) {\n      roiInputIdx = 1;\n      scalesInputIdx = 2;\n      sizesInputIdx = 3;\n    } else {\n      scalesInputIdx = 1;\n      sizesInputIdx = 2;\n    }\n  } else if (opset === 9) {\n    scalesInputIdx = 1;\n  }\n\n  return createAttributeWithCacheKey({\n    opset,\n    isResize,\n    mode,\n    scales,\n    extrapolationValue,\n    coordinateTransformMode,\n    useExtrapolation,\n    needRoiInput,\n    nearestMode,\n    cubicCoefficientA,\n    excludeOutside,\n    useNearest2xOptimization,\n    roiInputIdx,\n    scalesInputIdx,\n    sizesInputIdx,\n  });\n};\n\nconst createUpsampleProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: UpsampleAttributes,\n): ProgramInfo => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const [inputWidth, inputHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    inputs[0].dims,\n    TextureType.unpacked,\n  );\n\n  const outputShape = inputs[0].dims.map((dim, i) => Math.floor(dim * attributes.scales[i]));\n  const [outputWidth, outputHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    outputShape,\n    TextureType.unpacked,\n  );\n  const dim = outputShape.length;\n\n  const outputPitches = new Array<number>(dim);\n  const inputPitches = new Array<number>(dim);\n  let precalculatedPitches = `\n      int output_pitches[${dim}];\n      int input_pitches[${dim}];\n      `;\n  for (let d = dim - 1; d >= 0; d--) {\n    outputPitches[d] = d === dim - 1 ? 1 : outputPitches[d + 1] * outputShape[d + 1];\n    inputPitches[d] = d === dim - 1 ? 1 : inputPitches[d + 1] * inputs[0].dims[d + 1];\n\n    precalculatedPitches += `\n        output_pitches[${d}] = ${outputPitches[d]};\n        input_pitches[${d}] = ${inputPitches[d]};\n        `;\n  }\n  const getInputFloatFunction = `\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${inputWidth}, ${inputHeight});\n        float value = getColorAsFloat(${glsl.texture2D}(X, coords));\n        return value;\n      }\n      `;\n\n  const shaderSource =\n    attributes.mode === 'nearest'\n      ? // nearest\n        `\n    ${getInputFloatFunction}\n    float process(int indices[${dim}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int d, m;\n      for (int dim = 0; dim < ${dim}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`\n      : dim === 4\n        ? // bilinear 4D\n          `\n    ${getInputFloatFunction}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${inputs[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`\n        : // bilinear 2D\n          `\n    ${getInputFloatFunction}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${inputs[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;\n  return {\n    ...upsampleProgramMetadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n    variables: [\n      {\n        name: 'scales',\n        type: 'int',\n        arrayLength: attributes.scales.length,\n        data: attributes.scales.map((x) => Math.ceil(x)),\n      },\n    ],\n  };\n};\n\nexport const validateInputs = (inputs: Tensor[], attribute: UpsampleAttributes): void => {\n  if (\n    !inputs ||\n    (attribute.opset < 9 && inputs.length !== 1) ||\n    (attribute.opset >= 9 && attribute.opset < 11 && inputs.length !== 2) ||\n    (attribute.opset >= 11 && inputs.length < 2)\n  ) {\n    throw new Error('invalid inputs.');\n  }\n\n  if (attribute.scales.length > 0 && inputs[0].dims.length !== attribute.scales.length) {\n    throw new Error('Invalid input shape.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('Invalid input tensor types.');\n  }\n};\n\nexport const scalesValidation = (scales: number[], mode: string, isResize: boolean): void => {\n  if (!isResize) {\n    for (const scale of scales) {\n      if (scale < 1) {\n        throw new Error('Scale value should be greater than or equal to 1.');\n      }\n    }\n  } else {\n    for (const scale of scales) {\n      if (scale <= 0) {\n        throw new Error('Scale value should be greater than 0.');\n      }\n    }\n  }\n  if (mode === 'linear' || mode === 'cubic') {\n    if (scales.length !== 2 && (scales.length !== 4 || scales[0] !== 1 || scales[1] !== 1)) {\n      throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic') \\\n        or 4-D inputs with the corresponding outermost 2 scale values being 1 \\\n        in the ${isResize ? 'Resize' : 'Upsample'} opeartor.`);\n    }\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\nimport { getCoordsDataType } from '../utils';\n\nimport { unpackFromChannel } from './packing-utils';\nimport { parseUpsampleAttributes, scalesValidation, UpsampleAttributes, validateInputs } from './upsample';\n\nconst resizeProgramMetadata = {\n  name: 'Resize',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed],\n};\n\nexport const resize: OperatorImplementation<UpsampleAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: UpsampleAttributes,\n): Tensor[] => {\n  validateInputs(inputs, attributes);\n  const output = inferenceHandler.run(\n    {\n      ...resizeProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createPackedResizeProgramInfo(inferenceHandler, inputs, attributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseResizeAttributesV10: OperatorInitialization<UpsampleAttributes> = (\n  node: Graph.Node,\n): UpsampleAttributes => parseUpsampleAttributes(node, 10);\n\nexport const parseResizeAttributesV11: OperatorInitialization<UpsampleAttributes> = (\n  node: Graph.Node,\n): UpsampleAttributes => parseUpsampleAttributes(node, 11);\n\nconst createPackedResizeProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: UpsampleAttributes,\n): ProgramInfo => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const [scales, outputShape] = prepareInputs(inputs, attributes);\n\n  const isSame = scales.every((s: number) => s === 1) && attributes.coordinateTransformMode !== 'tf_crop_and_resize';\n  if (isSame) {\n    return {\n      ...resizeProgramMetadata,\n      output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.packed },\n      hasMain: true,\n      shaderSource: `void main() {\n                    vec4 v = ${glsl.texture2D}(X, TexCoords);\n                    ${glsl.output} = v;\n                }`,\n    };\n  }\n\n  const dim = outputShape.length;\n  if (dim < 2) {\n    throw new Error(`output dimension should be at least 2, but got ${dim}`);\n  }\n\n  const outputHeight = outputShape[dim - 2];\n  const outputWidth = outputShape[dim - 1];\n\n  const inputShape = inputs[0].dims;\n  if (dim !== inputShape.length) {\n    throw new Error(`output dimension should match input ${inputShape.length}, but got ${dim}`);\n  }\n  const inputHeight = inputShape[dim - 2];\n  const inputWidth = inputShape[dim - 1];\n\n  const scalesHeight = scales[dim - 2];\n  const scalesWidth = scales[dim - 1];\n\n  let getSourceFracIndex = '';\n\n  if (attributes.mode !== 'linear') {\n    // TODO: support other modes\n    throw new Error(`resize (packed) does not support mode: '${attributes.mode}'`);\n  }\n  switch (attributes.coordinateTransformMode) {\n    case 'asymmetric':\n      getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                `;\n      break;\n    case 'half_pixel':\n      getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                `;\n      break;\n    case 'pytorch_half_pixel':\n      getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${outputWidth}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${outputHeight}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${outputWidth}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${outputHeight}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;\n      break;\n    case 'align_corners':\n      getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0, ${outputWidth}.0 - 1.0,\n                            ${outputHeight}.0 - 1.0);\n                        vec4 original = vec4(${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0, ${inputWidth}.0 - 1.0,\n                            ${inputHeight}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;\n      break;\n    default:\n      // TODO:supporting other coordinateTransformModes\n      throw new Error(`resize (packed) does not support coordinateTransformMode: \\\n                                '${attributes.coordinateTransformMode}'`);\n  }\n\n  const coordsDataType = getCoordsDataType(dim);\n  const unpackChannel = unpackFromChannel();\n  const shaderSource = `\n            const vec2 inputWH = vec2(${inputHeight}.0, ${inputWidth}.0);\n            const vec4 scaleWHWH = vec4(float(${scalesHeight}), float(${scalesWidth}), float(${scalesHeight}), float(${\n              scalesWidth\n            }));\n            ${unpackChannel}\n            ${getSourceFracIndex}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${coordsDataType} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${outputHeight - 1};\n                bool hasNextCol = rc.z < ${outputWidth - 1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${glsl.output} = vec4(newValue);\n            }\n        `;\n  return {\n    ...resizeProgramMetadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.packed },\n    hasMain: true,\n    shaderSource,\n  };\n};\n\nconst prepareInputs = (inputs: Tensor[], attributes: UpsampleAttributes): [readonly number[], readonly number[]] => {\n  const x = inputs[0];\n  const xDims = x.dims;\n\n  let scales = attributes.scales;\n  let outputSizes: number[] | undefined;\n  if (scales.length === 0) {\n    const scalesTensor = inputs[attributes.scalesInputIdx];\n    if (scalesTensor && scalesTensor.size !== 0) {\n      if (inputs[attributes.sizesInputIdx]) {\n        throw new Error('Only one of scales or sizes must be provided as input.');\n      }\n      scales = parseScalesData(scalesTensor, attributes.mode, attributes.isResize);\n    } else {\n      const sizesTensor = inputs[attributes.sizesInputIdx];\n      if (!sizesTensor || sizesTensor.size === 0) {\n        throw new Error('Either scales or sizes MUST be provided as input.');\n      }\n\n      outputSizes = Array.from(sizesTensor.integerData);\n      scales = parseScalesDataFromOutputSize(outputSizes, xDims, attributes.mode, attributes.isResize);\n    }\n  } else {\n    if (inputs[attributes.sizesInputIdx]) {\n      throw new Error('Only one of scales or sizes must be provided as input.');\n    }\n  }\n\n  const yDims = outputSizes || xDims.map((dim, i) => Math.floor(dim * scales[i]));\n\n  return [scales, yDims];\n};\n\nconst parseScalesData = (scale: Tensor, mode: string, isResize: boolean): number[] => {\n  const scales = Array.from(scale.floatData);\n  scalesValidation(scales, mode, isResize);\n  return scales;\n};\n\nconst parseScalesDataFromOutputSize = (\n  yDims: readonly number[],\n  xDims: readonly number[],\n  mode: string,\n  isResize: boolean,\n): number[] => {\n  const length = xDims.length;\n  const scales = new Array<number>(length);\n\n  for (let i = 0, end = length; i < end; i++) {\n    if (xDims[i] === 0) {\n      if (yDims[i] !== 0) {\n        throw new Error('Input dim is zero but required output dim is non-zero.');\n      }\n      scales[i] = 1;\n    } else {\n      scales[i] = yDims[i] / xDims[i];\n    }\n  }\n  scalesValidation(scales, mode, isResize);\n  return scales;\n};\n\n// roi data is not used yet. but leave here for future usage.\n// const getRoi = (inputs: Tensor[], attributes: UpsampleAttributes) : number[] => {\n//     let roi: number[] = [];\n//     if (attributes.needRoiInput) {\n//         if (attributes.roiInputIdx <= 0) {\n//             throw new Error('Invalid roi input index.');\n//         }\n//         const roiTensor = inputs[attributes.roiInputIdx];\n//         roi = roiTensor.size > 0 ? Array.from(roiTensor.floatData) : [];\n//     } else {\n//         roi = new Array(inputs[0].dims.length * 2).fill(0);\n//     }\n//     return roi;\n// };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const shape = (_inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n  return [new Tensor([inputs[0].dims.length], 'int32', undefined, undefined, new Int32Array(inputs[0].dims))];\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Shape requires 1 input.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { NUMBER_TYPES, OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface SliceAttributes extends AttributeWithCacheKey {\n  readonly axes: number[];\n  readonly ends: number[];\n  readonly starts: number[];\n}\n\nconst sliceProgramMetadata = {\n  name: 'Slice',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const slice: OperatorImplementation<SliceAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: SliceAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(\n    {\n      ...sliceProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes),\n    },\n    inputs,\n  );\n  return [output];\n};\n\nexport const parseSliceAttributes: OperatorInitialization<SliceAttributes> = (node: Graph.Node): SliceAttributes => {\n  const starts = node.attributes.getInts('starts');\n  const ends = node.attributes.getInts('ends');\n  const axes = node.attributes.getInts('axes', []);\n  return createAttributeWithCacheKey({ starts, ends, axes });\n};\n\nconst createSliceProgramInfo = (\n  _inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  attributes: SliceAttributes,\n): ProgramInfo => {\n  const axes = attributes.axes.length === 0 ? input.dims.slice(0).map((_val, i) => i) : attributes.axes;\n  const normalizedAxes = ShapeUtil.normalizeAxes(axes, input.dims.length);\n  const starts = attributes.starts.map((start, i) => {\n    if (start > input.dims[normalizedAxes[i]] - 1) {\n      return input.dims[normalizedAxes[i]];\n    }\n    return ShapeUtil.normalizeAxis(start, input.dims[normalizedAxes[i]]);\n  });\n  const ends = attributes.ends.map((end, i) => {\n    if (end > input.dims[normalizedAxes[i]] - 1) {\n      return input.dims[normalizedAxes[i]];\n    }\n    return ShapeUtil.normalizeAxis(end, input.dims[normalizedAxes[i]]);\n  });\n\n  const outputShape = input.dims.slice();\n\n  const sliceOps: string[] = [];\n  for (let i = 0; i < normalizedAxes.length; i++) {\n    outputShape[normalizedAxes[i]] = ends[i] - starts[i];\n    if (starts[i] > 0) {\n      sliceOps.push(`outputIdx[${normalizedAxes[i]}] += ${starts[i]};`);\n    } // else { sliceOps.push(`outputIdx[${normalizedAxes[i]}] += 0;`); }\n  }\n\n  const rank = outputShape.length;\n  const shaderSource = `\n      float process(int outputIdx[${rank}]) {\n        ${sliceOps.join('\\n      ')}\n        return _A(outputIdx);\n      }`;\n  return {\n    ...sliceProgramMetadata,\n    output: { dims: outputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Slice requires 1 input.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n};\n\nexport const sliceV10 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV10(inputs);\n  const attributes = generateSliceAttributesFromInputs(inferenceHandler, inputs);\n  const output = inferenceHandler.run(\n    {\n      ...sliceProgramMetadata,\n      cacheHint: attributes.cacheKey,\n      get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes),\n    },\n    [inputs[0]],\n  );\n  return [output];\n};\n\nconst generateSliceAttributesFromInputs = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n): SliceAttributes => {\n  if (\n    !inferenceHandler.session.isInitializer(inputs[1].dataId) ||\n    !inferenceHandler.session.isInitializer(inputs[2].dataId) ||\n    (inputs.length >= 4 && !inferenceHandler.session.isInitializer(inputs[3].dataId)) ||\n    (inputs.length >= 5 && !inferenceHandler.session.isInitializer(inputs[4].dataId))\n  ) {\n    throw new Error('dynamic slice attributes are not allowed');\n  }\n\n  if (inputs.length >= 5 && inputs[4].integerData.some((i: number) => i !== 1)) {\n    throw new Error('currently non-1 steps is not supported for Slice');\n  }\n\n  const starts = Array.from(inputs[1].integerData);\n  const ends = Array.from(inputs[2].integerData);\n  const axes = inputs.length >= 4 ? Array.from(inputs[3].integerData) : [];\n  const cacheKey = `${axes};${starts};${ends}`;\n  return { starts, ends, axes, cacheKey };\n};\n\nconst validateInputsV10 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length < 3 || inputs.length > 5) {\n    throw new Error('Invalid input number.');\n  }\n  if (inputs[1].type !== 'int32' || inputs[1].dims.length !== 1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[2].type !== 'int32' || inputs[2].dims.length !== 1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 4 && (inputs[3].type !== 'int32' || inputs[3].dims.length !== 1)) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 5 && (inputs[4].type !== 'int32' || inputs[4].dims.length !== 1)) {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nimport { transpose, TransposeAttributes } from './transpose';\n\nexport interface SoftmaxAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nconst softmaxComputeMaxProgramMetadata = {\n  name: 'SoftmaxComputeMax',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst softmaxComputeScaleProgramMetadata = {\n  name: 'SoftmaxComputeScale',\n  inputNames: ['A', 'Max'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked],\n};\n\nconst softmaxProgramMetadata = {\n  name: 'SoftMax',\n  inputNames: ['A', 'Max', 'Norm'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked],\n};\n\nexport const softmax: OperatorImplementation<SoftmaxAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: SoftmaxAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  const inputShape = inputs[0].dims.slice();\n  const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);\n  const logicalRowCount = ShapeUtil.sizeToDimension(inputShape, axis);\n  const featureCount = ShapeUtil.sizeFromDimension(inputShape, axis);\n\n  const output = computeSoftmax(inferenceHandler, inputs, attributes, logicalRowCount, featureCount);\n  return output;\n};\n\nexport const parseSoftmaxAttributes: OperatorInitialization<SoftmaxAttributes> = (\n  node: Graph.Node,\n): SoftmaxAttributes => createAttributeWithCacheKey({ axis: node.attributes.getInt('axis', 1) });\n\nexport const parseSoftmaxAttributesV13: OperatorInitialization<SoftmaxAttributes> = (\n  node: Graph.Node,\n): SoftmaxAttributes => createAttributeWithCacheKey({ axis: node.attributes.getInt('axis', -1) });\n\n// The \"semantic\" meaning of axis has changed in opset-13.\n// Please compare: https://github.com/onnx/onnx/blob/main/docs/Operators.md#Softmax\n// with https://github.com/onnx/onnx/blob/main/docs/Changelog.md#Softmax-11 for detailed explanations\n// To account for the opset-13 behavior, our plan will be to transpose the \"axis\" dim to the innermost dim\n// and perform softmax and then reverse the transpose. We can skip the transposing aspect if the axis is already\n// the innermost dim\nexport const softmaxV13: OperatorImplementation<SoftmaxAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: SoftmaxAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  const inputShape = inputs[0].dims.slice();\n  const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);\n  const rank = inputShape.length;\n\n  const isTransposeRequired = axis !== rank - 1 ? true : false;\n  const transposedInputShape: number[] = [];\n  let perm: number[] = [];\n  let transposedInputs: Tensor[] = [];\n  let transposeAttribute: TransposeAttributes;\n\n  if (isTransposeRequired) {\n    perm = Array.from({ length: rank }).map((_, i) => i);\n\n    // swap the innermost dim with the dim corresponding to axis\n    perm[axis] = rank - 1;\n    perm[rank - 1] = axis;\n\n    perm.map((p) => transposedInputShape.push(inputShape[p]));\n\n    transposeAttribute = createAttributeWithCacheKey({ perm });\n    transposedInputs = transpose(inferenceHandler, inputs, transposeAttribute);\n  }\n\n  const logicalRowCount = isTransposeRequired\n    ? ShapeUtil.sizeToDimension(transposedInputShape, rank - 1)\n    : ShapeUtil.sizeToDimension(inputShape, rank - 1);\n  const featureCount = isTransposeRequired\n    ? ShapeUtil.sizeFromDimension(transposedInputShape, rank - 1)\n    : ShapeUtil.sizeFromDimension(inputShape, rank - 1);\n\n  const output = computeSoftmax(\n    inferenceHandler,\n    isTransposeRequired ? transposedInputs : inputs,\n    attributes,\n    logicalRowCount,\n    featureCount,\n  );\n\n  if (isTransposeRequired) {\n    const reversedOutput = transpose(inferenceHandler, output, transposeAttribute!);\n    return reversedOutput;\n  } else {\n    return output;\n  }\n};\n\nconst computeSoftmax = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: SoftmaxAttributes,\n  logicalRowCount: number,\n  featureCount: number,\n): Tensor[] => {\n  const computeMaxProgramInfo = createComputeMaxProgramInfo(\n    inferenceHandler,\n    inputs[0],\n    logicalRowCount,\n    featureCount,\n    [logicalRowCount],\n  );\n  const max = inferenceHandler.run(\n    { ...softmaxComputeMaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeMaxProgramInfo },\n    inputs,\n  );\n\n  const computeScaleProgramInfo = createComputScaleProgramInfo(\n    inferenceHandler,\n    inputs[0],\n    logicalRowCount,\n    featureCount,\n    computeMaxProgramInfo.output.dims,\n    [logicalRowCount],\n  );\n  const scale = inferenceHandler.run(\n    { ...softmaxComputeScaleProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeScaleProgramInfo },\n    [inputs[0], max],\n  );\n\n  const softMaxProgramInfo = createSoftMaxProgramInfo(\n    inferenceHandler,\n    inputs[0],\n    logicalRowCount,\n    featureCount,\n    computeMaxProgramInfo.output.dims,\n    computeScaleProgramInfo.output.dims,\n  );\n  const output = inferenceHandler.run(\n    { ...softmaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => softMaxProgramInfo },\n    [inputs[0], max, scale],\n  );\n  return [output];\n};\n\n/**\n * Create a texture that contains the maximum value of each of the 'N' rows\n */\nconst createComputeMaxProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  logicalRowCount: number,\n  featureCount: number,\n  outputShape: number[],\n): ProgramInfo => {\n  const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    input.dims,\n    TextureType.unpacked,\n  );\n  const rank = outputShape.length;\n\n  if (logicalRowCount < 1 || featureCount < 1) {\n    throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n  }\n\n  if (outputShape.length !== 1) {\n    throw new Error('Dimensionality of the output should be 1');\n  }\n\n  if (outputShape[0] !== logicalRowCount) {\n    throw new Error('Shape of the output should be equal to logical row count');\n  }\n\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const shaderSource = `\n      float process(int[${rank}] indices) {\n        int logical_row_start_offset = indices[0] * ${featureCount};\n\n        float max = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset, ${textureWidth},\n        ${textureHeight} )));\n        for(int i=1; i<${featureCount}; ++i)\n        {\n          float current = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${textureWidth}, ${textureHeight})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;\n  return {\n    ...softmaxComputeMaxProgramMetadata,\n    output: { dims: outputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\n/**\n * Create a texture that contains the normalization factor for each of the 'N' rows\n */\nconst createComputScaleProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  logicalRowCount: number,\n  featureCount: number,\n  maxElementPerLogicalRow: readonly number[],\n  outputShape: number[],\n): ProgramInfo => {\n  const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    input.dims,\n    TextureType.unpacked,\n  );\n  const rank = outputShape.length;\n\n  if (logicalRowCount < 1 || featureCount < 1) {\n    throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n  }\n\n  if (outputShape.length !== 1) {\n    throw new Error('Dimensionality of the output should be 1');\n  }\n\n  if (outputShape[0] !== logicalRowCount) {\n    throw new Error('Shape of the output should be equal to logical row count');\n  }\n\n  if (maxElementPerLogicalRow.length !== 1) {\n    throw new Error('Dimensionality of the intermediate results should be 1');\n  }\n\n  if (maxElementPerLogicalRow[0] !== logicalRowCount) {\n    throw new Error('Shape of the intermediate results should be equal to logical row count');\n  }\n\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const shaderSource = `\n      float process(int[${rank}] indices) {\n        int logical_row_start_offset = indices[0] * ${featureCount};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${featureCount}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${textureWidth}, ${textureHeight}))) - max);\n        }\n\n        return norm_factor;\n      }`;\n  return {\n    ...softmaxComputeScaleProgramMetadata,\n    output: { dims: outputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst createSoftMaxProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  logicalRowCount: number,\n  featureCount: number,\n  maxElementPerLogicalRow: readonly number[],\n  normalizationPerLogicalRow: readonly number[],\n): ProgramInfo => {\n  const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(\n    input.dims,\n    TextureType.unpacked,\n  );\n  const rank = input.dims.length;\n\n  if (logicalRowCount < 1 || featureCount < 1) {\n    throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n  }\n\n  if (maxElementPerLogicalRow.length !== 1 || normalizationPerLogicalRow.length !== 1) {\n    throw new Error('Dimensionality of the intermediate results should be 1');\n  }\n\n  if (maxElementPerLogicalRow[0] !== logicalRowCount || normalizationPerLogicalRow[0] !== logicalRowCount) {\n    throw new Error('Shape of the intermediate results should be equal to logical row count');\n  }\n\n  const shaderSource = `\n      float process(int[${rank}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${textureWidth}, ${textureHeight});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${featureCount};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;\n  return {\n    ...softmaxProgramMetadata,\n    output: { dims: input.dims, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Softmax requires 1 input.');\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { AttributeWithCacheKey, createAttributeWithCacheKey } from '../../../attribute-with-cache-key';\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil, SplitUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, TextureType } from '../types';\n\nexport interface SplitAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n  readonly split: number[];\n  readonly numOutputs: number;\n}\n\nconst splitProgramMetadata = {\n  name: 'Split',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const split: OperatorImplementation<SplitAttributes> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  attributes: SplitAttributes,\n): Tensor[] => {\n  validateInputs(inputs);\n\n  const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);\n  const count = getProgramCount(inferenceHandler, inputs, axis, attributes);\n  const output: Tensor[] = [];\n  for (let i = 0; i < count; ++i) {\n    output.push(\n      inferenceHandler.run(\n        {\n          ...splitProgramMetadata,\n          cacheHint: `${attributes.cacheKey};${i}`,\n          get: () => createSplitProgramInfo(inferenceHandler, inputs[0], attributes, axis, i),\n        },\n        inputs,\n      ),\n    );\n  }\n\n  return output;\n};\n\nexport const parseSplitAttributes: OperatorInitialization<SplitAttributes> = (node: Graph.Node): SplitAttributes => {\n  const axis = node.attributes.getInt('axis', 0);\n  const split = node.attributes.getInts('split', []);\n  const numOutputs = node.outputs.length;\n  return createAttributeWithCacheKey({ axis, split, numOutputs });\n};\n\nconst getProgramCount = (\n  _inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  axis: number,\n  attributes: SplitAttributes,\n): number => {\n  const [, offsets] = SplitUtil.splitShape(inputs[0].dims, axis, attributes.split, attributes.numOutputs);\n  return offsets.length;\n};\n\nconst createSplitProgramInfo = (\n  _inferenceHandler: WebGLInferenceHandler,\n  input: Tensor,\n  attributes: SplitAttributes,\n  axis: number,\n  index: number,\n): ProgramInfo => {\n  const [shapes, offsets] = SplitUtil.splitShape(input.dims, axis, attributes.split, attributes.numOutputs);\n  const offset = offsets[index];\n  const outputShape = shapes[index];\n  const rank = outputShape.length;\n  const shaderSource = `\n      float process(int indices[${rank}]) {\n        indices[${axis}] += ${offset};\n        return _A(indices);\n      }\n    `;\n  return {\n    ...splitProgramMetadata,\n    cacheHint: `${attributes.cacheKey}:${index}`,\n    output: { dims: outputShape, type: input.type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Split requires one input.');\n  }\n\n  if (\n    inputs[0].type !== 'int8' &&\n    inputs[0].type !== 'uint8' &&\n    inputs[0].type !== 'int16' &&\n    inputs[0].type !== 'uint16' &&\n    inputs[0].type !== 'int32' &&\n    inputs[0].type !== 'uint32' &&\n    inputs[0].type !== 'float32' &&\n    inputs[0].type !== 'float64' &&\n    inputs[0].type !== 'bool'\n  ) {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const squeeze: OperatorImplementation<number[]> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  axes: number[],\n): Tensor[] => {\n  validateInputs(inputs);\n  const outputShape = ShapeUtil.squeezeShape(inputs[0].dims, axes);\n  const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);\n  return [output];\n};\n\nexport const squeezeV13 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV13(inputs);\n  return squeeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));\n};\n\nexport const parseSqueezeAttributes: OperatorInitialization<number[]> = (node: Graph.Node): number[] =>\n  node.attributes.getInts('axes');\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Squeeze requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('invalid input tensor types.');\n  }\n};\n\nconst validateInputsV13 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Squeeze requires 2 inputs.');\n  }\n\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from '../../../tensor';\nimport { getGlsl } from '../glsl-source';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramMetadata, TextureType } from '../types';\n\nexport const sum = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n\n  const sumProgramMetadata = {\n    name: 'Sum',\n    inputNames: inputs.map((_v, i) => `X${i}`),\n    inputTypes: new Array(inputs.length).fill(TextureType.unpacked),\n  };\n\n  const output = inferenceHandler.run(\n    { ...sumProgramMetadata, get: () => createSumProgramInfo(inferenceHandler, inputs, sumProgramMetadata) },\n    inputs,\n  );\n  return [output];\n};\n\nconst createSumProgramInfo = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  sumProgramMetadata: ProgramMetadata,\n): ProgramInfo => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const outputShape = inputs[0].dims.slice();\n  const sumLine = inputs.map((_v, i) => `${glsl.texture2D}(X${i},TexCoords)`).join(' + ');\n  const shaderSource = `\n      void main() {\n        vec4 result = ${sumLine};\n        ${glsl.output} = result;\n      }\n    `;\n  return {\n    ...sumProgramMetadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    hasMain: true,\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length === 0) {\n    throw new Error('Sum requires inputs.');\n  }\n\n  const length = inputs[0].dims.length;\n  for (let i = 1; i < inputs.length; i++) {\n    if (length !== inputs[i].dims.length) {\n      throw new Error('Input shapes are mismatched.');\n    }\n\n    for (let j = 0; j < length; j++) {\n      if (inputs[0].dims[j] !== inputs[i].dims[j]) {\n        throw new Error('Input shapes are not matched.');\n      }\n    }\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n  for (let i = 1; i < inputs.length; i++) {\n    if (inputs[0].type !== inputs[i].type) {\n      throw new Error('Input types are not matched.');\n    }\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { NUMBER_TYPES } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { WebGLInferenceHandler } from '../inference-handler';\nimport { ProgramInfo, ProgramMetadata, TextureType } from '../types';\n\nexport const tile = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n\n  const tileProgramMetadata = {\n    name: 'Tile',\n    inputNames: ['A'],\n    inputTypes: [TextureType.unpacked],\n  };\n\n  const output = inferenceHandler.run(\n    { ...tileProgramMetadata, get: () => createTileProgramInfo(inferenceHandler, inputs, tileProgramMetadata) },\n    inputs,\n  );\n  return [output];\n};\n\nconst createTileProgramInfo = (\n  _handler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  tileProgramMetadata: ProgramMetadata,\n): ProgramInfo => {\n  const inputShape = inputs[0].dims.slice();\n  const outputShape = new Array(inputShape.length);\n\n  const tileOps: string[] = [];\n  for (let i = 0; i < inputShape.length; i++) {\n    outputShape[i] = inputShape[i] * inputs[1].numberData[i];\n    tileOps.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${inputShape[i]}.));`);\n  }\n\n  const rank = outputShape.length;\n  const shaderSource = `\n      float process(int outputIdx[${rank}]) {\n        int inputIdx[${rank}];\n        ${tileOps.join('\\n')}\n        return _A(inputIdx);\n      }\n    `;\n  return {\n    ...tileProgramMetadata,\n    output: { dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked },\n    shaderSource,\n  };\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Tile requires 2 input.');\n  }\n  if (inputs[1].dims.length !== 1) {\n    throw new Error('The second input shape must 1 dimension.');\n  }\n  if (inputs[1].dims[0] !== inputs[0].dims.length) {\n    throw new Error('Invalid input shape.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {\n    throw new Error('Invalid repeat type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Graph } from '../../../graph';\nimport { OperatorImplementation, OperatorInitialization } from '../../../operators';\nimport { Tensor } from '../../../tensor';\nimport { ShapeUtil } from '../../../util';\nimport { WebGLInferenceHandler } from '../inference-handler';\n\nexport const unsqueeze: OperatorImplementation<number[]> = (\n  inferenceHandler: WebGLInferenceHandler,\n  inputs: Tensor[],\n  axes: number[],\n): Tensor[] => {\n  validateInputs(inputs);\n  const outputShape = ShapeUtil.unsqueezeShape(inputs[0].dims, axes);\n  const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);\n  return [output];\n};\n\nexport const unsqueezeV13 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV13(inputs);\n  return unsqueeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));\n};\n\nexport const parseUnsqueezeAttributes: OperatorInitialization<number[]> = (node: Graph.Node): number[] =>\n  node.attributes.getInts('axes');\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Unsqueeze requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('invalid input tensor types.');\n  }\n};\n\nconst validateInputsV13 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Unsqueeze requires 2 inputs.');\n  }\n\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { OpSet } from '../../opset';\n\nimport { batchNormalization, parseBatchNormalizationAttributes } from './ops/batch-normalization';\nimport * as binaryOps from './ops/binary-op';\nimport { cast, parseCastAttributes } from './ops/cast';\nimport { concat, parseConcatAttributes } from './ops/concat';\nimport { conv, parseConvAttributes } from './ops/conv';\nimport { convTranspose, parseConvTransposeAttributes } from './ops/conv-transpose';\nimport { depthToSpace, parseDepthToSpaceAttributes } from './ops/depth-to-space';\nimport { flatten, parseFlattenAttributes } from './ops/flatten';\nimport { gather, parseGatherAttributes } from './ops/gather';\nimport { gemm, parseGemmAttributesV11, parseGemmAttributesV7 } from './ops/gemm';\nimport { imageScaler, parseImageScalerAttributes } from './ops/image-scaler';\nimport { instanceNormalization, parseInstanceNormalizationAttributes } from './ops/instance-normalization';\nimport { lrn, parseLrnAttributes } from './ops/lrn';\nimport { matMul, parseMatMulAttributes } from './ops/matmul';\nimport { padV11, padV2, parsePadAttributesV11, parsePadAttributesV2 } from './ops/pad';\nimport {\n  averagePool,\n  globalAveragePool,\n  globalMaxPool,\n  maxPool,\n  parseAveragePoolAttributes,\n  parseGlobalAveragePoolAttributes,\n  parseMaxPoolAttributes,\n} from './ops/pool';\nimport {\n  parseReduceAttributes,\n  reduceLogSum,\n  reduceLogSumSquare,\n  reduceMax,\n  reduceMean,\n  reduceMin,\n  reduceProd,\n  reduceSum,\n} from './ops/reduce';\nimport { reshape } from './ops/reshape';\nimport { parseResizeAttributesV10, parseResizeAttributesV11, resize } from './ops/resize-packed';\nimport { shape } from './ops/shape';\nimport { parseSliceAttributes, slice, sliceV10 } from './ops/slice';\nimport { parseSoftmaxAttributes, parseSoftmaxAttributesV13, softmax, softmaxV13 } from './ops/softmax';\nimport { parseSplitAttributes, split } from './ops/split';\nimport { parseSqueezeAttributes, squeeze, squeezeV13 } from './ops/squeeze';\nimport { sum } from './ops/sum';\nimport { tile } from './ops/tile';\nimport { parseTransposeAttributes, transpose } from './ops/transpose';\nimport * as unaryOps from './ops/unary-op';\nimport { parseUnsqueezeAttributes, unsqueeze, unsqueezeV13 } from './ops/unsqueeze';\nimport { parseUpsampleAttributesV7, parseUpsampleAttributesV9, upsample } from './ops/upsample';\n\nexport const WEBGL_OP_RESOLVE_RULES: readonly OpSet.ResolveRule[] = [\n  ['Abs', '', '6+', unaryOps.abs],\n  ['Acos', '', '7+', unaryOps.acos],\n  ['Add', '', '7+', binaryOps.add],\n  ['And', '', '7+', binaryOps.and],\n  ['Asin', '', '7+', unaryOps.asin],\n  ['Atan', '', '7+', unaryOps.atan],\n  // TODO: support new attributes for AveragePool-10\n  ['AveragePool', '', '7+', averagePool, parseAveragePoolAttributes],\n  ['BatchNormalization', '', '7+', batchNormalization, parseBatchNormalizationAttributes],\n  ['Cast', '', '6+', cast, parseCastAttributes],\n  ['Ceil', '', '6+', unaryOps.ceil],\n  ['Clip', '', '6-10', unaryOps.clip, unaryOps.parseClipAttributes],\n  ['Clip', '', '11+', unaryOps.clipV11],\n  ['Concat', '', '4+', concat, parseConcatAttributes],\n  ['Conv', '', '1+', conv, parseConvAttributes],\n  ['ConvTranspose', '', '1+', convTranspose, parseConvTransposeAttributes],\n  ['Cos', '', '7+', unaryOps.cos],\n  ['Div', '', '7+', binaryOps.div],\n  ['Dropout', '', '7+', unaryOps.identity],\n  ['DepthToSpace', '', '1+', depthToSpace, parseDepthToSpaceAttributes],\n  ['Equal', '', '7+', binaryOps.equal],\n  ['Elu', '', '6+', unaryOps.elu, unaryOps.parseEluAttributes],\n  ['Exp', '', '6+', unaryOps.exp],\n  ['Flatten', '', '1+', flatten, parseFlattenAttributes],\n  ['Floor', '', '6+', unaryOps.floor],\n  ['FusedConv', 'com.microsoft', '1+', conv, parseConvAttributes],\n  ['Gather', '', '1+', gather, parseGatherAttributes],\n  ['Gemm', '', '7-10', gemm, parseGemmAttributesV7],\n  ['Gemm', '', '11+', gemm, parseGemmAttributesV11],\n  ['GlobalAveragePool', '', '1+', globalAveragePool, parseGlobalAveragePoolAttributes],\n  ['GlobalMaxPool', '', '1+', globalMaxPool],\n  ['Greater', '', '7+', binaryOps.greater],\n  ['Identity', '', '1+', unaryOps.identity],\n  ['ImageScaler', '', '1+', imageScaler, parseImageScalerAttributes],\n  ['InstanceNormalization', '', '6+', instanceNormalization, parseInstanceNormalizationAttributes],\n  ['LeakyRelu', '', '6+', unaryOps.leakyRelu, unaryOps.parseLeakyReluAttributes],\n  ['Less', '', '7+', binaryOps.less],\n  ['LRN', '', '1+', lrn, parseLrnAttributes],\n  ['Log', '', '6+', unaryOps.log],\n  ['MatMul', '', '1+', matMul, parseMatMulAttributes],\n  // TODO: support new attributes for MaxPool-8 and MaxPool-10\n  ['MaxPool', '', '1+', maxPool, parseMaxPoolAttributes],\n  ['Mul', '', '7+', binaryOps.mul],\n  ['Neg', '', '6+', unaryOps.neg],\n  ['Not', '', '1+', unaryOps.not],\n  ['Or', '', '7+', binaryOps.or],\n  ['Pad', '', '2-10', padV2, parsePadAttributesV2],\n  ['Pad', '', '11+', padV11, parsePadAttributesV11],\n  ['Pow', '', '7+', binaryOps.pow],\n  ['PRelu', '', '7+', binaryOps.pRelu],\n  ['ReduceLogSum', '', '1+', reduceLogSum, parseReduceAttributes],\n  ['ReduceMax', '', '1+', reduceMax, parseReduceAttributes],\n  ['ReduceMean', '', '1+', reduceMean, parseReduceAttributes],\n  ['ReduceMin', '', '1+', reduceMin, parseReduceAttributes],\n  ['ReduceProd', '', '1+', reduceProd, parseReduceAttributes],\n  ['ReduceSum', '', '1-12', reduceSum, parseReduceAttributes],\n  ['ReduceSumSquare', '', '1+', reduceLogSumSquare, parseReduceAttributes],\n  ['Relu', '', '6+', unaryOps.relu],\n  ['Reshape', '', '5+', reshape],\n  ['Resize', '', '10', resize, parseResizeAttributesV10],\n  ['Resize', '', '11+', resize, parseResizeAttributesV11],\n  ['Shape', '', '1+', shape],\n  ['Sigmoid', '', '6+', unaryOps.sigmoid],\n  ['Sin', '', '7+', unaryOps.sin],\n  ['Slice', '', '10+', sliceV10], // TODO: support 'steps' for Slice-10\n  ['Slice', '', '1-9', slice, parseSliceAttributes],\n  // The \"semantic\" meaning of axis has changed in opset-13.\n  ['Softmax', '', '1-12', softmax, parseSoftmaxAttributes],\n  ['Softmax', '', '13+', softmaxV13, parseSoftmaxAttributesV13],\n  // 'Split' operator has an optional attribute 'split'\n  // this attribute determines how the specified axis of input data is split.\n  // When the attribute is missing, we need the count of number of outputs\n  // so that we can determine the 'split' attribute from the runtime input to the Operator\n  ['Split', '', '2-12', split, parseSplitAttributes],\n  ['Sqrt', '', '6+', unaryOps.sqrt],\n  ['Squeeze', '', '1-12', squeeze, parseSqueezeAttributes],\n  ['Squeeze', '', '13+', squeezeV13],\n  ['Sub', '', '7+', binaryOps.sub],\n  ['Sum', '', '6+', sum],\n  ['Tan', '', '7+', unaryOps.tan],\n  ['Tanh', '', '6+', unaryOps.tanh],\n  ['Tile', '', '6+', tile],\n  ['Transpose', '', '1+', transpose, parseTransposeAttributes],\n  ['Upsample', '', '7-8', upsample, parseUpsampleAttributesV7],\n  ['Upsample', '', '9', upsample, parseUpsampleAttributesV9],\n  ['Unsqueeze', '', '1-12', unsqueeze, parseUnsqueezeAttributes],\n  ['Unsqueeze', '', '13+', unsqueezeV13],\n  ['Xor', '', '7+', binaryOps.xor],\n];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nconst INLINE_FUNC_DEF_REGEX = /@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm;\nconst FUNC_CALL_REGEX = '(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;';\n/**\n * GLSL preprocessor responsible for resolving @inline directives\n */\nexport function replaceInlines(script: string): string {\n  const inlineDefs: { [name: string]: { params: Array<{ type: string; name: string } | null>; body: string } } = {};\n  let match;\n  while ((match = INLINE_FUNC_DEF_REGEX.exec(script)) !== null) {\n    const params = match[3]\n      .split(',')\n      .map((s) => {\n        const tokens = s.trim().split(' ');\n        if (tokens && tokens.length === 2) {\n          return { type: tokens[0], name: tokens[1] };\n        }\n        return null;\n      })\n      .filter((v) => v !== null);\n    inlineDefs[match[2]] = { params, body: match[4] };\n  }\n  for (const name in inlineDefs) {\n    const regexString = FUNC_CALL_REGEX.replace('__FUNC__', name);\n    const regex = new RegExp(regexString, 'gm');\n    while ((match = regex.exec(script)) !== null) {\n      const type = match[1];\n      const variable = match[2];\n      const params = match[3].split(',');\n      const declLine = type ? `${type} ${variable};` : '';\n      let newBody: string = inlineDefs[name].body;\n      let paramRedecLine = '';\n      inlineDefs[name].params.forEach((v, i) => {\n        if (v) {\n          paramRedecLine += `${v.type} ${v.name} = ${params[i]};\\n`;\n        }\n      });\n      newBody = `${paramRedecLine}\\n ${newBody}`;\n      newBody = newBody.replace('return', `${variable} = `);\n      const replacement = `\n      ${declLine}\n      {\n        ${newBody}\n      }\n      `;\n      script = script.replace(match[0], replacement);\n    }\n  }\n  script = script.replace(INLINE_FUNC_DEF_REGEX, '');\n  return script;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Logger } from '../../instrument';\nimport { assert } from '../../util';\n\n/** Layout preferences */\nexport interface WidthHeightPrefs {\n  breakAxis?: number;\n  isPacked?: boolean;\n  reverseWH?: boolean;\n}\n/**\n * TextureLayoutStrategy is an abstraction for different plans\n * for mapping n-dimensional arrays to 2D textures (and back)\n */\nexport interface TextureLayoutStrategy {\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number];\n}\n\n/**\n * This strategy try to find the minimal max(W,H) that fulfills (W * H == totalSize)\n */\nexport class AlwaysKeepOriginalSizeStrategy implements TextureLayoutStrategy {\n  constructor(public maxTextureSize: number) {}\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    // scalar tensor\n    if (shape.length === 0) {\n      return [1, 1];\n    }\n    const maxTextureSize = this.maxTextureSize;\n    if (prefs && prefs.breakAxis !== undefined) {\n      // check to see if dims fit\n      const wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce((a, b) => a * b);\n      const hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce((a, b) => a * b);\n      if (wsize > maxTextureSize || hsize > maxTextureSize) {\n        // ignore preferences\n        // continue with default layout\n        Logger.verbose(\n          'TextureLayout',\n          `Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`,\n        );\n      } else {\n        return [wsize, hsize];\n      }\n    }\n    const totalSize = shape.reduce((a, b) => a * b);\n\n    let width = Math.floor(Math.sqrt(totalSize));\n\n    for (; width < maxTextureSize && width < totalSize; width++) {\n      if (totalSize % width === 0) {\n        break;\n      }\n    }\n\n    if (width >= maxTextureSize || totalSize % width !== 0) {\n      throw new Error(`The given dimensions are outside this GPU's boundaries: ${shape}`);\n    }\n    return [width, totalSize / width];\n  }\n}\n\nexport class PreferLogicalStrategy implements TextureLayoutStrategy {\n  constructor(public maxTextureSize: number) {}\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    const wh = this.computeTexture(shape, prefs);\n    if (prefs && prefs.isPacked) {\n      wh[0] /= 2;\n      wh[1] /= 2;\n    }\n    if (prefs && prefs.reverseWH) {\n      return [wh[1], wh[0]];\n    }\n    return wh;\n  }\n\n  computeTexture(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    const isPacked = prefs && prefs.isPacked;\n    // scalar tensor\n    if (shape.length === 0) {\n      return isPacked ? [2, 2] : [1, 1];\n    }\n    let maxTextureSize = this.maxTextureSize;\n    if (prefs && prefs.breakAxis !== undefined) {\n      // check to see if dims fit\n      const wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce((a, b) => a * b);\n      const hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce((a, b) => a * b);\n      if (wsize > maxTextureSize || hsize > maxTextureSize) {\n        // ignore preferences\n        // continue with default layout\n        Logger.verbose(\n          'TextureLayout',\n          `Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`,\n        );\n      } else {\n        return [wsize, hsize];\n      }\n    }\n    let logShape = shape.slice(0);\n    if (isPacked) {\n      maxTextureSize = maxTextureSize * 2;\n\n      // This logic ensures we accurately count the number of packed texels needed\n      // to accommodate the tensor. We can only pack values in the same texel if\n      // they are from adjacent pairs of rows/cols within the same batch. So if a\n      // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n      // fact that the texels containing the third row are half empty.\n      logShape = logShape.map((_d, i) =>\n        i >= logShape.length - 2 ? (logShape[i] % 2 === 0 ? logShape[i] : logShape[i] + 1) : logShape[i],\n      );\n\n      // Packed texture height is at least 2 (the channel height of a single\n      // texel).\n      if (logShape.length === 1) {\n        logShape = [2, logShape[0]];\n      }\n    }\n\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n      const squeezeResult = squeezeShape(logShape);\n      logShape = squeezeResult.newShape;\n    }\n\n    const size = sizeFromShape(logShape);\n    if (logShape.length <= 1 && size <= maxTextureSize) {\n      return [1, size];\n    } else if (logShape.length === 2 && logShape[0] <= maxTextureSize && logShape[1] <= maxTextureSize) {\n      return logShape as [number, number];\n    } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTextureSize && logShape[2] <= maxTextureSize) {\n      return [logShape[0] * logShape[1], logShape[2]];\n    } else if (logShape.length === 3 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] <= maxTextureSize) {\n      return [logShape[0], logShape[1] * logShape[2]];\n    } else if (\n      logShape.length === 4 &&\n      logShape[0] * logShape[1] * logShape[2] <= maxTextureSize &&\n      logShape[3] <= maxTextureSize\n    ) {\n      return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    } else if (\n      logShape.length === 4 &&\n      logShape[0] <= maxTextureSize &&\n      logShape[1] * logShape[2] * logShape[3] <= maxTextureSize\n    ) {\n      return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    } else {\n      if (isPacked) {\n        // For packed textures size equals the number of channels required to\n        // accommodate the texture data. However in order to squarify such that\n        // inner dimensions stay even, we rewrite size to equal the number of\n        // texels. Then in the return statement we rehydrate the squarified\n        // dimensions to channel units.\n        return sizeToSquarishShape(size / 4).map((d) => d * 2) as [number, number];\n      }\n      return sizeToSquarishShape(size);\n    }\n  }\n}\n\nexport function squeezeShape(shape: number[], axis?: number[]): { newShape: number[]; keptDims: number[] } {\n  const newShape: number[] = [];\n  const keptDims: number[] = [];\n  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;\n  const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape).sort();\n  let j = 0;\n  for (let i = 0; i < shape.length; ++i) {\n    if (axes != null) {\n      if (axes[j] === i && shape[i] !== 1) {\n        throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);\n      }\n      if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {\n        newShape.push(shape[i]);\n        keptDims.push(i);\n      }\n      if (axes[j] <= i) {\n        j++;\n      }\n    }\n    if (shape[i] !== 1) {\n      newShape.push(shape[i]);\n      keptDims.push(i);\n    }\n  }\n  return { newShape, keptDims };\n}\n\nexport function parseAxisParam(axis: number | number[], shape: number[]): number[] {\n  const rank = shape.length;\n\n  // Normalize input\n  axis = axis == null ? shape.map((_s, i) => i) : ([] as number[]).concat(axis);\n\n  // Check for valid range\n  assert(\n    axis.every((ax) => ax >= -rank && ax < rank),\n    () => `All values in axis param must be in range [-${rank}, ${rank}) but ` + `got axis ${axis}`,\n  );\n\n  // Check for only integers\n  assert(axis.every(isInt), () => 'All values in axis param must be integers but ' + `got axis ${axis}`);\n\n  // Handle negative axis.\n  return axis.map((a) => (a < 0 ? rank + a : a));\n}\nexport function isInt(a: number): boolean {\n  return a % 1 === 0;\n}\nexport function sizeFromShape(shape: number[]): number {\n  if (shape.length === 0) {\n    // Scalar.\n    return 1;\n  }\n  let size = shape[0];\n  for (let i = 1; i < shape.length; i++) {\n    size *= shape[i];\n  }\n  return size;\n}\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\nexport function sizeToSquarishShape(size: number): [number, number] {\n  const width = Math.ceil(Math.sqrt(size));\n  return [width, Math.ceil(size / width)];\n}\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { ArrayUtil, BroadcastUtil, ShapeUtil } from '../../util';\n\nimport { GlslContext, GlslLib, GlslLibRoutine } from './glsl-definitions';\nimport { getGlsl } from './glsl-source';\nimport { squeezeShape } from './texture-layout-strategy';\nimport { TextureLayout } from './types';\nimport {\n  generateShaderFuncNameFromInputSamplerName,\n  generateShaderFuncNameFromInputSamplerNameAtOutCoords,\n  getCoordsDataType,\n  getGlChannels,\n  getSqueezedParams,\n  squeezeInputShape,\n} from './utils';\n\n/**\n * GLSL Library responsible for data types and routines for manipulating\n * coordinates and mapping to/from tensor indices\n */\nexport class CoordsGlslLib extends GlslLib {\n  returnType: string;\n\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): { [name: string]: GlslLibRoutine } {\n    return {\n      ...this.offsetToCoords(),\n      ...this.coordsToOffset(),\n      ...this.toVec(),\n      ...this.valueFrom(),\n      // TODO return these only when packing is enabled.\n      ...this.getCommonUtilFuncs(),\n      ...this.getInputsSamplingSnippets(),\n      ...this.getOutputSamplingSnippet(),\n    };\n  }\n  getCustomTypes() {\n    return {};\n  }\n  /**\n   * Produces a function that can map from\n   * 2D normalzied coordinates (s,t) to a flat offset\n   */\n  protected offsetToCoords(): { [name: string]: GlslLibRoutine } {\n    const funcName = 'offsetToCoords';\n    return {\n      offsetToCoords: new GlslLibRoutine(`\n      vec2 ${funcName}(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      `),\n    };\n  }\n\n  /**\n   * Produces a function that can map from\n   * 2D normalzied coordinates (s,t) to a flat offset\n   */\n  protected coordsToOffset(): { [name: string]: GlslLibRoutine } {\n    const funcName = 'coordsToOffset';\n    return {\n      coordsToOffset: new GlslLibRoutine(`\n      int ${funcName}(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      `),\n    };\n  }\n\n  /**\n   * Generates code for output sampler.\n   */\n\n  protected getOutputSamplingSnippet(): { [name: string]: GlslLibRoutine } {\n    const outputLayout = this.context.outputTextureLayout;\n    if (outputLayout.isPacked) {\n      return this.getPackedOutputSamplingSnippet(outputLayout);\n    } else {\n      return this.getUnpackedOutputSamplingSnippet(outputLayout);\n    }\n  }\n\n  /**\n   * Generates code for packed output sampler.\n   */\n  protected getPackedOutputSamplingSnippet(outputLayout: TextureLayout): { [name: string]: GlslLibRoutine } {\n    const outShape = outputLayout.unpackedShape;\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const result: { [name: string]: GlslLibRoutine } = {};\n    const funcName = 'getOutputCoords';\n    switch (outShape.length) {\n      case 0:\n        result[funcName] = this.getOutputScalarCoords();\n        break;\n      case 1:\n        result[funcName] = this.getOutputPacked1DCoords(outShape as [number], outTexShape as [number, number]);\n        break;\n      case 2:\n        result[funcName] = this.getOutputPacked2DCoords(outShape as [number, number], outTexShape as [number, number]);\n        break;\n      case 3:\n        result[funcName] = this.getOutputPacked3DCoords(\n          outShape as [number, number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      default:\n        result[funcName] = this.getOutputPackedNDCoords(outShape, outTexShape as [number, number]);\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    // TODO we need this to properly return a packed vec4 from kernels.\n    // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.\n    const floatTextureSetRGBASource = `\n      void setOutput(vec4 val) {\n        ${glsl.output} = val;\n      }\n    `;\n    const floatTextureSetRGBAFuncName = 'floatTextureSetRGBA';\n    result[floatTextureSetRGBAFuncName] = new GlslLibRoutine(floatTextureSetRGBASource);\n    return result;\n  }\n\n  /**\n   * Generates code for unpacked output sampler.\n   */\n  protected getUnpackedOutputSamplingSnippet(outputLayout: TextureLayout): { [name: string]: GlslLibRoutine } {\n    const outShape = outputLayout.unpackedShape;\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const result: { [name: string]: GlslLibRoutine } = {};\n    const funcName = 'getOutputCoords';\n    switch (outShape.length) {\n      case 0:\n        result[funcName] = this.getOutputScalarCoords();\n        break;\n      case 1:\n        result[funcName] = this.getOutputUnpacked1DCoords(outShape as [number], outTexShape as [number, number]);\n        break;\n      case 2:\n        result[funcName] = this.getOutputUnpacked2DCoords(\n          outShape as [number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      case 3:\n        result[funcName] = this.getOutputUnpacked3DCoords(\n          outShape as [number, number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      case 4:\n        result[funcName] = this.getOutputUnpacked4DCoords(\n          outShape as [number, number, number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      case 5:\n        result[funcName] = this.getOutputUnpacked5DCoords(\n          outShape as [number, number, number, number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      case 6:\n        result[funcName] = this.getOutputUnpacked6DCoords(\n          outShape as [number, number, number, number, number, number],\n          outTexShape as [number, number],\n        );\n        break;\n      default:\n        throw new Error(`Unsupported output dimensionality: ${outShape.length}`);\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    // TODO we need this to properly return a packed vec4 from kernels.\n    // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.\n    const floatTextureSetRSource = `\n        void setOutput(float val) {\n          ${glsl.output} = vec4(val, 0, 0, 0);\n        }\n    `;\n    const floatTextureSetRFuncName = 'floatTextureSetR';\n    result[floatTextureSetRFuncName] = new GlslLibRoutine(floatTextureSetRSource);\n    return result;\n  }\n\n  /**\n   * Scalar output coordinates.\n   */\n  protected getOutputScalarCoords(): GlslLibRoutine {\n    return new GlslLibRoutine(`\n      int getOutputCoords() {\n        return 0;\n      }\n    `);\n  }\n\n  /**\n   * 1D packed output coordinates.\n   */\n  protected getOutputPacked1DCoords(_shape: [number], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = texShape;\n    let source = '';\n    if (packedTexShape[0] === 1) {\n      source = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${packedTexShape[1]}.0);\n          }\n        `;\n      return new GlslLibRoutine(source);\n    }\n\n    if (packedTexShape[1] === 1) {\n      source = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${packedTexShape[0]}.0);\n          }\n        `;\n      return new GlslLibRoutine(source);\n    }\n\n    source = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n          return 2 * (resTexRC.y * ${packedTexShape[0]} + resTexRC.x);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * 2D packed output coordinates.\n   */\n  protected getOutputPacked2DCoords(shape: [number, number], texShape: [number, number]): GlslLibRoutine {\n    let source = '';\n    if (ArrayUtil.arraysEqual(shape, texShape)) {\n      source = `\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${texShape[0]}, ${texShape[1]}));\n        }\n      `;\n      return new GlslLibRoutine(source);\n    }\n\n    const packedTexShape = texShape;\n    // texels needed to accommodate a logical row\n    const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n\n    /**\n     * getOutputCoords\n     *\n     * resTexRC: The rows and columns of the texels. If you move over one\n     * texel to the right in the packed texture, you are moving over one column\n     * (not two).\n     *\n     * index: The texel index\n     */\n    source = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${texelsInLogicalRow}) * 2;\n          int c = 2 * (index / ${texelsInLogicalRow});\n\n          return ivec2(r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * 3D packed output coordinates.\n   */\n  protected getOutputPacked3DCoords(shape: [number, number, number], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = [texShape[0], texShape[1]];\n    const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n    const source = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n          int b = index / ${texelsInBatch};\n          index -= b * ${texelsInBatch};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${texelsInLogicalRow}) * 2;\n          int c = 2 * (index / ${texelsInLogicalRow});\n\n          return ivec3(b, r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * ND packed output coordinates.\n   */\n  protected getOutputPackedNDCoords(shape: readonly number[], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = [texShape[0], texShape[1]];\n\n    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n    let texelsInBatchN = texelsInBatch;\n    let batches = '';\n    let coords = 'b, r, c';\n\n    for (let b = 2; b < shape.length - 1; b++) {\n      texelsInBatchN *= shape[shape.length - b - 1];\n      batches =\n        `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n      coords = `b${b}, ` + coords;\n    }\n    const source = `\n      ivec${shape.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n        int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n        ${batches}\n\n        int b = index / ${texelsInBatch};\n        index -= b * ${texelsInBatch};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${texelsInLogicalRow}) * 2;\n        int c = 2 * (index / ${texelsInLogicalRow});\n\n        return ivec${shape.length}(${coords});\n      }\n    `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 1D output coordinates.\n   */\n  protected getOutputUnpacked1DCoords(_shape: [number], texShape: [number, number]): GlslLibRoutine {\n    const source = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          return resTexRC.y * ${texShape[0]} + resTexRC.x;\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 2D output coordinates.\n   */\n  protected getOutputUnpacked2DCoords(shape: [number, number], texShape: [number, number]): GlslLibRoutine {\n    const source = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          int r = index / ${shape[1]};\n          int c = index - r * ${shape[1]};\n          return ivec2(r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 3D output coordinates.\n   */\n  protected getOutputUnpacked3DCoords(shape: [number, number, number], texShape: [number, number]): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd'];\n    const coordsFromIndexSnippet = strides\n      .map((stride, i) => {\n        const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n        const line2 =\n          i === strides.length - 1\n            ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}`\n            : `index -= ${coordsToCompute[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n\n    source = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec3(r, c, d);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 4D output coordinates.\n   */\n  protected getOutputUnpacked4DCoords(\n    shape: [number, number, number, number],\n    texShape: [number, number],\n  ): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2'];\n    const coordsFromIndexSnippet = strides\n      .map((stride, i) => {\n        const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n        const line2 =\n          i === strides.length - 1\n            ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}`\n            : `index -= ${coordsToCompute[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n\n    source = `\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec4(r, c, d, d2);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 5D output coordinates.\n   */\n  protected getOutputUnpacked5DCoords(\n    shape: [number, number, number, number, number],\n    texShape: [number, number],\n  ): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2', 'd3'];\n    const coordsFromIndexSnippet = strides\n      .map((stride, i) => {\n        const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n        const line2 =\n          i === strides.length - 1\n            ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}`\n            : `index -= ${coordsToCompute[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n\n    source = `\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 6D output coordinates.\n   */\n  protected getOutputUnpacked6DCoords(\n    shape: [number, number, number, number, number, number],\n    texShape: [number, number],\n  ): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2', 'd3', 'd4'];\n    const coordsFromIndexSnippet = strides\n      .map((stride, i) => {\n        const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n        const line2 =\n          i === strides.length - 1\n            ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}`\n            : `index -= ${coordsToCompute[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n\n    source = `\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n         int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n         ${coordsFromIndexSnippet}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Generates code for common UV coords computation utility functions.\n   */\n  protected getCommonUtilFuncs(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    let funcName = 'uvFromFlat';\n    result[funcName] = new GlslLibRoutine(`\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    `);\n    funcName = 'packedUVfrom1D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'packedUVfrom2D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'packedUVfrom3D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'sampleTexture';\n    const glsl = getGlsl(this.context.glContext.version);\n    result[funcName] = new GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${glsl.texture2D}(textureSampler, uv).r;\n        }`);\n    return result;\n  }\n\n  /**\n   * Constructing snippets for inputs\n   */\n  protected getInputsSamplingSnippets(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    const outputLayout = this.context.outputTextureLayout;\n    this.context.programInfo.inputNames.forEach((samplerName, i) => {\n      const inputLayout = this.context.inputTextureLayouts[i];\n      const funcName = generateShaderFuncNameFromInputSamplerName(samplerName);\n      if (inputLayout.isPacked) {\n        result[funcName] = this.getPackedSamplerFromInput(funcName, samplerName, inputLayout);\n      } else {\n        result[funcName] = this.getUnpackedSamplerFromInput(funcName, samplerName, inputLayout);\n      }\n\n      const outCoordFuncName = generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName);\n      if (inputLayout.unpackedShape.length <= outputLayout.unpackedShape.length) {\n        if (inputLayout.isPacked) {\n          result[outCoordFuncName] = this.getPackedSamplerAtOutputCoords(\n            outCoordFuncName,\n            inputLayout,\n            outputLayout,\n            samplerName,\n          );\n        } else {\n          result[outCoordFuncName] = this.getUnpackedSamplerAtOutputCoords(\n            outCoordFuncName,\n            inputLayout,\n            outputLayout,\n            samplerName,\n          );\n        }\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Constructing snippets for output coordinates of samplers\n   */\n  protected getPackedSamplerAtOutputCoords(\n    funcName: string,\n    inputLayout: TextureLayout,\n    outputLayout: TextureLayout,\n    name: string,\n  ): GlslLibRoutine {\n    const inShape = inputLayout.unpackedShape;\n    const outShape = outputLayout.unpackedShape;\n    const texName = name;\n    const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(texName);\n\n    const inRank = inShape.length;\n    const outRank = outShape.length;\n\n    const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n\n    const type = getCoordsDataType(outRank);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet: string;\n    const fields = getGlChannels();\n\n    if (inRank === 0) {\n      coordsSnippet = '';\n    } else if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n      unpackedCoordsSnippet = 'coords';\n    } else {\n      unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(', ');\n    }\n\n    let output = 'return outputValue;';\n    const inSize = ShapeUtil.size(inShape);\n    const isInputScalar = inSize === 1;\n    const outSize = ShapeUtil.size(outShape);\n    const isOutputScalar = outSize === 1;\n\n    if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n      output = `\n        return vec4(outputValue.xy, outputValue.xy);\n      `;\n    } else if (isInputScalar && !isOutputScalar) {\n      if (outRank === 1) {\n        output = `\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        `;\n      } else {\n        output = `\n          return vec4(outputValue.x);\n        `;\n      }\n    } else if (broadcastDims.length) {\n      const rows = inRank - 2;\n      const cols = inRank - 1;\n\n      if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n        output = 'return vec4(outputValue.x);';\n      } else if (broadcastDims.indexOf(rows) > -1) {\n        output = 'return vec4(outputValue.x, outputValue.y, ' + 'outputValue.x, outputValue.y);';\n      } else if (broadcastDims.indexOf(cols) > -1) {\n        output = 'return vec4(outputValue.xx, outputValue.zz);';\n      }\n    }\n\n    const swapLastDimsSnippet = `\n        int lastDim = coords.${fields[outRank - 1]};\n        coords.${fields[outRank - 1]} = coords.${fields[outRank - 2]};\n        coords.${fields[outRank - 2]} = lastDim;\n      `;\n    const source = `\n      vec4 ${funcName}() {\n        ${type} coords = getOutputCoords();\n        ${swapLastDimsSnippet}\n        ${coordsSnippet}\n        vec4 outputValue = ${texFuncSnippet}(${unpackedCoordsSnippet});\n        ${output}\n      }\n    `;\n    return new GlslLibRoutine(source, ['coordinates.getOutputCoords']);\n  }\n\n  /**\n   * Constructing snippets for unpacked output coordinates of samplers\n   */\n  protected getUnpackedSamplerAtOutputCoords(\n    funcName: string,\n    inputLayout: TextureLayout,\n    outputLayout: TextureLayout,\n    name: string,\n  ): GlslLibRoutine {\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const inTexShape = [inputLayout.width, inputLayout.height];\n    const inRank = inputLayout.unpackedShape.length;\n    const outRank = outputLayout.unpackedShape.length;\n    const inShape = inputLayout.unpackedShape;\n    const outShape = outputLayout.unpackedShape;\n    const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(name);\n\n    if (inRank === outRank && ArrayUtil.arraysEqual(inTexShape, outTexShape)) {\n      const source = `\n          float ${funcName}() {\n            return sampleTexture(${name}, TexCoords);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const type = getCoordsDataType(outRank);\n    const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet: string;\n    const fields = getGlChannels();\n\n    if (inRank === 0) {\n      coordsSnippet = '';\n    } else if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n      unpackedCoordsSnippet = 'coords';\n    } else {\n      unpackedCoordsSnippet = inputLayout.unpackedShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(', ');\n    }\n    const source = `\n        float ${funcName}() {\n          ${type} coords = getOutputCoords();\n          ${coordsSnippet}\n          return ${texFuncSnippet}(${unpackedCoordsSnippet});\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.getOutputCoords']);\n  }\n\n  /**\n   * Constructing snippets for packed operations.\n   */\n  protected getPackedSamplerFromInput(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    switch (inputLayout.unpackedShape.length) {\n      case 0:\n        return this.getPackedSamplerScalar(funcName, name);\n      case 1:\n        return this.getPackedSampler1D(funcName, name, inputLayout);\n      case 2:\n        return this.getPackedSampler2D(funcName, name, inputLayout);\n      case 3:\n        return this.getPackedSampler3D(funcName, name, inputLayout);\n      default:\n        return this.getPackedSamplerND(funcName, name, inputLayout);\n    }\n  }\n\n  /**\n   * Constructing snippets for unpacked operations.\n   */\n  protected getUnpackedSamplerFromInput(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    switch (shape.length) {\n      case 0:\n        return this.getUnpackedSamplerScalar(funcName, name, inputLayout);\n      case 1:\n        return this.getUnpackedSampler1D(funcName, name, inputLayout);\n      case 2:\n        return this.getUnpackedSampler2D(funcName, name, inputLayout);\n      case 3:\n        return this.getUnpackedSampler3D(funcName, name, inputLayout);\n      case 4:\n        return this.getUnpackedSampler4D(funcName, name, inputLayout);\n      case 5:\n        return this.getUnpackedSampler5D(funcName, name, inputLayout);\n      case 6:\n        return this.getUnpackedSampler6D(funcName, name, inputLayout);\n      default:\n        // TODO support more dimensionalities\n        throw new Error(`Unsupported dimension ${shape.length}-D`);\n    }\n  }\n\n  /**\n   * Packed scalar snippet.\n   */\n  protected getPackedSamplerScalar(funcName: string, name: string): GlslLibRoutine {\n    const glsl = getGlsl(this.context.glContext.version);\n    const source = `\n          vec4 ${funcName}() {\n            return ${glsl.texture2D}(${name}, halfCR);\n          }\n        `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Packed 1D snippet.\n   */\n  protected getPackedSampler1D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const texShape = [inputLayout.width, inputLayout.height];\n    const packedTexShape = [texShape[1], texShape[0]];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    const packedSampler = `vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom1D']);\n  }\n\n  /**\n   * Packed 2D snippet.\n   */\n  protected getPackedSampler2D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const glsl = getGlsl(this.context.glContext.version);\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n\n    if (texShape != null && ArrayUtil.arraysEqual(shape, texShape)) {\n      const packedSampler = `vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n        return ${glsl.texture2D}(${name}, uv);\n      }`;\n\n      return new GlslLibRoutine(packedSampler);\n    }\n    const packedTexShape = texShape;\n    const valuesPerRow = Math.ceil(shape[1] / 2);\n    const packedSampler = `vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${packedTexShape[1]}, ${packedTexShape[0]}, ${valuesPerRow}, row, col);\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom2D']);\n  }\n\n  /**\n   * Packed 3D snippet.\n   */\n  protected getPackedSampler3D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const packedTexShape = [texShape[0], texShape[1]];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    if (shape[0] === 1) {\n      const squeezedShape = shape.slice(1);\n      const keptDims = [1, 2];\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      const params = ['b', 'row', 'col'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n      const samplerRoutine = this.getPackedSamplerFromInput(funcName, name, newInputLayout);\n      const packedSampler = `${samplerRoutine.routineBody}\n      vec4 ${funcName}(int b, int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      } `;\n      const source = packedSampler;\n      return new GlslLibRoutine(source, samplerRoutine.dependencies);\n    }\n    const texNumR = packedTexShape[0];\n    const texNumC = packedTexShape[1];\n\n    const valuesPerRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n\n    const packedSampler = `vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumC}, ${texNumR}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${name}, uv);}`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom3D']);\n  }\n  /*\n   * Packed ND snippet.\n   */\n  protected getPackedSamplerND(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const rank = shape.length;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    const packedTexShape = [texShape[0], texShape[1]];\n    const texNumR = packedTexShape[1];\n    const texNumC = packedTexShape[0];\n    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n    let params = 'int b, int row, int col';\n    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n    for (let b = 2; b < rank - 1; b++) {\n      params = `int b${b}, ` + params;\n      texelsInBatch *= shape[rank - b - 1];\n      index = `b${b} * ${texelsInBatch} + ` + index;\n    }\n    const packedSampler = `vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked scalar snippet.\n   */\n  protected getUnpackedSamplerScalar(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const [texNumR, texNumC] = [inputLayout.width, inputLayout.height];\n    if (texNumR === 1 && texNumC === 1) {\n      const source = `\n          float ${funcName}() {\n            return sampleTexture(${name}, halfCR);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const source = `\n        float ${funcName}() {\n          int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, offset_${name});\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, [\n      'coordinates.uvFromFlat',\n      'coordinates.sampleTexture',\n      'coordinates.coordsToOffset',\n    ]);\n  }\n\n  /**\n   * Unpacked 1D snippet.\n   */\n  protected getUnpackedSampler1D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const tNumR = inputLayout.width;\n    const tNumC = inputLayout.height;\n\n    if (tNumC === 1 && tNumR === 1) {\n      const source = `\n        float ${funcName}(int index) {\n          return sampleTexture(${name}, halfCR);\n        }\n      `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    if (tNumC === 1) {\n      const source = `\n          float ${funcName}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${tNumR}.0, 0.5);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n    if (tNumR === 1) {\n      const source = `\n          float ${funcName}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumC}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n    const source = `\n        float ${funcName}(int index) {\n          vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);\n  }\n\n  /**\n   * Unpacked 2D snippet.\n   */\n\n  protected getUnpackedSampler2D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n\n    // TODO: modify row/col order for other dimensions.\n    const texShape = [inputLayout.height, inputLayout.width];\n\n    if (texShape != null && ArrayUtil.arraysEqual(shape, texShape)) {\n      const texNumR = texShape[1];\n      const texNumC = texShape[0];\n      const source = `\n          float ${funcName}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${texNumR}.0, ${texNumC}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const { newShape, keptDims } = squeezeShape(shape as number[]);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const params = ['col', 'row'];\n      const source = `\n          ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n          float ${funcName}(int row, int col) {\n            return ${funcName}(${getSqueezedParams(params, keptDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const texNumR = texShape[1];\n    const texNumC = texShape[0];\n    if (texNumC === 1) {\n      const source = `\n          float ${funcName}(int row, int col) {\n            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    }\n\n    if (texNumR === 1) {\n      const source = `\n          float ${funcName}(int row, int col) {\n            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    }\n\n    const source = `\n        float ${funcName}(int row, int col) {\n          int index = col * ${shape[1]} + row;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, [\n      'coordinates.uvFromFlat',\n      'coordinates.sampleTexture',\n      'coordinates.coordsToOffset',\n    ]);\n  }\n\n  /**\n   * Unpacked 3D snippet.\n   */\n\n  protected getUnpackedSampler3D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride0 = shape[1] * shape[2];\n    const stride1 = shape[2];\n\n    const { newShape, keptDims } = squeezeShape(shape as number[]);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      const params = ['batch', 'col', 'row'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n      const routine = this.getUnpackedSamplerFromInput(funcName, name, newInputLayout);\n      // TODO: revisit the logic here to make it simpler\n      const revDims = keptDims.reverse();\n      const source = `\n          ${routine.routineBody}\n          float ${funcName}(int batch, int row, int col) {\n            return ${funcName}(${getSqueezedParams(params, revDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, routine.dependencies);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n          float ${funcName}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${stride0} + col * ${stride1} + row;\n            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n            return sampleTexture(${name}, uv);\n          }\n      `;\n    return new GlslLibRoutine(source, [\n      'coordinates.uvFromFlat',\n      'coordinates.sampleTexture',\n      'coordinates.coordsToOffset',\n    ]);\n  }\n\n  /**\n   * Unpacked 4D snippet.\n   */\n\n  protected getUnpackedSampler4D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride2 = shape[3];\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    //\n    // TODO: re-enable this shortcut once the index calculation bug is fixed.\n    //\n    // const {newShape, keptDims} = squeezeShape(shape as number[]);\n    // if (newShape.length < shape.length) {\n    //   const newInputShape = squeezeInputShape(shape, newShape);\n    //   const params = ['row', 'col', 'depth', 'depth2'];\n    //   // Deep copy of input texture layout.\n    //   const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n    //   newInputLayout.unpackedShape = newInputShape;\n    //   const source = `\n    //       ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n    //       float ${funcName}(int row, int col, int depth, int depth2) {\n    //         return ${funcName}(${getSqueezedParams(params, keptDims)});\n    //       }\n    //     `;\n    //   return new GlslLibRoutine(\n    //       source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    // }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n        float ${funcName}(int row, int col, int depth, int depth2) {\n          int index = row * ${stride0} + col * ${stride1} +\n              depth2 * ${stride2} + depth;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);\n  }\n\n  /**\n   * Unpacked 5D snippet.\n   */\n  protected getUnpackedSampler5D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride3 = shape[4];\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    const { newShape, keptDims } = squeezeShape(shape as number[]);\n    if (newShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, newShape);\n      const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const source = `\n          ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n          float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n            return ${funcName}(${getSqueezedParams(params, keptDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth3 * ${stride3} + depth2;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n  }\n\n  /**\n   * Unpacked 6D snippet.\n   */\n  protected getUnpackedSampler6D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride4 = shape[5];\n    const stride3 = shape[4] * stride4;\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    const { newShape, keptDims } = squeezeShape(shape as number[]);\n    if (newShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, newShape);\n      const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const source = `\n            ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n            float ${funcName}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${funcName}(${getSqueezedParams(params, keptDims)});\n            }\n          `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n          float ${funcName}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n            depth2 * ${stride3} + depth3 * ${stride4} + depth4;\n            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n    return new GlslLibRoutine(source, [\n      'coordinates.uvFromFlat',\n      'coordinates.sampleTexture',\n      'coordinates.coordsToOffset',\n    ]);\n  }\n\n  /**\n   * This is the main function to map from the given texture coordinates (s,t)\n   * to logical indices for the output\n   * There will only be one single variation of this\n   * Also see coordsToOffset and offsetToIndices for input-specific versions\n   */\n  protected toVec(): { [name: string]: GlslLibRoutine } {\n    const output = this.context.outputTextureLayout;\n    const rank = output.shape.length;\n    const strides = output.strides;\n    const xScale = output.width;\n    const yScale = output.height;\n\n    const stridesBlock = [];\n    for (let i = 0; i < rank - 1; ++i) {\n      stridesBlock.push(`\n        c[${i}] = offset / ${strides[i]};`);\n      stridesBlock.push(`\n        offset -= c[${i}] * ${strides[i]};`);\n    }\n    stridesBlock.push(`\n        c[${rank - 1}] = offset;`);\n    const body = `\n      void toVec(vec2 texCoords, out int c[${rank}]) {\n        int offset = coordsToOffset(texCoords, ${xScale}, ${yScale});\n        ${stridesBlock.join('')}\n      }\n      void toVec(int offset, out int c[${rank}]) {\n        ${stridesBlock.join('')}\n      }\n    `;\n    return { toVec: new GlslLibRoutine(body, ['coordinates.coordsToOffset']) };\n  }\n  /**\n   * These are value getter functions generated for each input\n   * Each function is hardwired to the name and dimensions of the input\n   * An '_T' variation is also produced which accesses values as if the\n   * input was transposed\n   */\n  protected valueFrom(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const layout = this.context.inputTextureLayouts[i];\n      const shape = layout.unpackedShape.length > 0 ? layout.unpackedShape : layout.shape;\n      const rank = shape.length;\n      let funcName = `_${name}`;\n      result[funcName] = new GlslLibRoutine(this.getValueFromSingle(name, rank, layout.width, layout.height, false), [\n        `shapeUtils.indicesToOffset${funcName}`,\n        'coordinates.offsetToCoords',\n        'fragcolor.getColorAsFloat',\n      ]);\n      funcName = funcName + '_T';\n      result[funcName] = new GlslLibRoutine(this.getValueFromSingle(name, rank, layout.width, layout.height, true), [\n        `shapeUtils.indicesToOffset${funcName}`,\n        'coordinates.offsetToCoords',\n        'fragcolor.getColorAsFloat',\n      ]);\n    });\n    return result;\n  }\n  /**\n   * Produces one value getter function for the name and rank given\n   * If a transpose is set proper offsetToCoords mapping will be used\n   * @param name name of the function\n   * @param rank rank of the input\n   * @param transpose whether or not should generate a transpose variation\n   */\n  protected getValueFromSingle(\n    varName: string,\n    rank: number,\n    width: number,\n    height: number,\n    transpose: boolean,\n  ): string {\n    let name = `_${varName}`;\n    if (transpose) {\n      name = name + '_T';\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    return `\n        float ${name}(int m[${rank}]) {\n          int offset = indicesToOffset${name}(m);\n          vec2 coords = offsetToCoords(offset, ${width}, ${height});\n          float value = getColorAsFloat(${glsl.texture2D}(${varName}, coords));\n          return value;\n        }\n        `;\n  }\n\n  /**\n   * Produces a packed value getter function for the name and rank given\n   * If a transpose is set proper offsetToCoords mapping will be used\n   * @param name name of the function\n   * @param rank rank of the input\n   * @param transpose whether or not should generate a transpose variation\n   */\n  protected getPackedValueFrom(\n    varName: string,\n    rank: number,\n    width: number,\n    height: number,\n    transpose: boolean,\n  ): string {\n    let name = `_${varName}_Pack`;\n    if (transpose) {\n      name = name + '_T';\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    return `\n        vec4 ${name}(int m[${rank}]) {\n          int offset = indicesToOffset_${varName}(m);\n          vec2 coords = offsetToCoords(offset, ${width}, ${height});\n          return ${glsl.texture2D}(${varName}, coords);\n        }\n        `;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { GlslContext, GlslLib, GlslLibRoutine } from './glsl-definitions';\n\n/**\n * This GLSL library handles routines converting\n * float32 to/from Unsigned byte or float 16\n */\nexport class EncodingGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): { [name: string]: GlslLibRoutine } {\n    return { ...this.encodeFloat32(), ...this.decodeFloat32() };\n  }\n  getCustomTypes(): { [name: string]: string } {\n    return {};\n  }\n  protected encodeFloat32(): { [name: string]: GlslLibRoutine } {\n    return {\n      encode: new GlslLibRoutine(`highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        `),\n    };\n  }\n  protected decodeFloat32(): { [name: string]: GlslLibRoutine } {\n    return {\n      decode: new GlslLibRoutine(`highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        `),\n    };\n  }\n  /**\n   * returns the routine to encode encode a 32bit float to a vec4 (of unsigned bytes)\n   * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float\n   */\n  protected encodeUint8(): { [name: string]: GlslLibRoutine } {\n    const endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';\n    return {\n      encode: new GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${endianness}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `),\n    };\n  }\n  /**\n   * returns the routine to encode a vec4 of unsigned bytes to float32\n   * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float\n   */\n  protected decodeUint8(): { [name: string]: GlslLibRoutine } {\n    const endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';\n    return {\n      decode: new GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${endianness}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `),\n    };\n  }\n  /**\n   * Determines if the machine is little endian or not\n   * @credit: https://gist.github.com/TooTallNate/4750953\n   */\n  static isLittleEndian(): boolean {\n    const b = new ArrayBuffer(4);\n    const a = new Uint32Array(b);\n    const c = new Uint8Array(b);\n    a[0] = 0xdeadbeef;\n    if (c[0] === 0xef) {\n      return true;\n    }\n    if (c[0] === 0xde) {\n      return false;\n    }\n    throw new Error('unknown endianness');\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { GlslContext, GlslLib, GlslLibRoutine } from './glsl-definitions';\nimport { getGlsl } from './glsl-source';\n\n/**\n * This GLSL library handles routines around reading a texlet and writing to it\n * Reading and writing could be more than just dealing with one channel\n * It may require encoding/decoding to/from 4 channels into one\n */\nexport class FragColorGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): { [name: string]: GlslLibRoutine } {\n    return { ...this.setFragColor(), ...this.getColorAsFloat() };\n  }\n  getCustomTypes(): { [name: string]: string } {\n    return {};\n  }\n  protected setFragColor(): { [name: string]: GlslLibRoutine } {\n    const glsl = getGlsl(this.context.glContext.version);\n    return {\n      setFragColor: new GlslLibRoutine(\n        `\n        void setFragColor(float value) {\n            ${glsl.output} = encode(value);\n        }\n        `,\n        ['encoding.encode'],\n      ),\n    };\n  }\n  protected getColorAsFloat(): { [name: string]: GlslLibRoutine } {\n    return {\n      getColorAsFloat: new GlslLibRoutine(\n        `\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        `,\n        ['encoding.decode'],\n      ),\n    };\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { GlslContext, GlslLib, GlslLibRoutine } from './glsl-definitions';\n\n/**\n * GLSL Library responsible for data types and routines for manipulating\n * coordinates and mapping to/from tensor indices\n */\nexport class ShapeUtilsGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): { [name: string]: GlslLibRoutine } {\n    return {\n      ...this.bcastIndex(),\n      ...this.bcastMatmulIndex(),\n      ...this.offsetToIndices(),\n      ...this.indicesToOffset(),\n      ...this.incrementIndices(),\n    };\n  }\n  getCustomTypes() {\n    return {};\n  }\n  protected bcastIndex(): { [name: string]: GlslLibRoutine } {\n    const outputRank = this.context.outputTextureLayout.shape.length;\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].unpackedShape;\n      if (shape.length <= outputRank) {\n        const rank = shape.length;\n        const dimOffset = outputRank - rank;\n        const funcName = `bcastIndices_${name}`;\n        let block = '';\n        for (let i = 0; i < rank; ++i) {\n          block += `\n          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset + i}]), ${shape[i]}.0) );\n          `;\n        }\n        const body = `\n        void ${funcName} (int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {\n          ${block}\n        }\n        `;\n        result[funcName] = new GlslLibRoutine(body);\n      }\n    });\n    return result;\n  }\n  protected bcastMatmulIndex(): { [name: string]: GlslLibRoutine } {\n    const outputRank = this.context.outputTextureLayout.shape.length;\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      if (!(shape.length < 2 || shape.length > outputRank)) {\n        const rank = shape.length;\n        const dimOffset = outputRank - rank;\n        const funcName = `bcastMatmulIndices_${name}`;\n        let block = '';\n        for (let i = 0; i < rank - 2; ++i) {\n          block += `\n          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset + i}]), ${shape[i]}.0) );\n          `;\n        }\n        const body = `\n        void ${funcName}(int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {\n          ${block}\n          realIndices[${rank - 1}] = bcastedIndices[${outputRank - 1}];\n          realIndices[${rank - 2}] = bcastedIndices[${outputRank - 2}];\n        }\n        `;\n        result[funcName] = new GlslLibRoutine(body);\n      }\n    });\n    return result;\n  }\n  protected indicesToOffset(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const strides = this.context.inputTextureLayouts[i].strides;\n      const rank = shape.length;\n      let funcName = `indicesToOffset_${name}`;\n      result[funcName] = new GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides));\n      funcName = `indicesToOffset_${name}_T`;\n      result[funcName] = new GlslLibRoutine(\n        ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides.slice().reverse()),\n      );\n    });\n    return result;\n  }\n  static indexToOffsetSingle(name: string, rank: number, strides: readonly number[]): string {\n    let block = '';\n    for (let i = rank - 1; i >= 0; --i) {\n      block += `\n        offset += indices[${i}] * ${strides[i]};\n        `;\n    }\n    return `\n      int ${name}(int indices[${rank}]) {\n        int offset = 0;\n        ${block}\n        return offset;\n      }\n      `;\n  }\n  protected offsetToIndices(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const strides = this.context.inputTextureLayouts[i].strides;\n      const rank = shape.length;\n      let funcName = `offsetToIndices_${name}`;\n      result[funcName] = new GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides));\n      funcName = `offsetToIndices_${name}_T`;\n      result[funcName] = new GlslLibRoutine(\n        ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides.slice().reverse()),\n      );\n    });\n    return result;\n  }\n  static offsetToIndicesSingle(name: string, rank: number, strides: readonly number[]): string {\n    const stridesBlock = [];\n    for (let i = 0; i < rank - 1; ++i) {\n      stridesBlock.push(`\n      indices[${i}] = offset / ${strides[i]};`);\n      stridesBlock.push(`\n        offset -= indices[${i}] * ${strides[i]};`);\n    }\n    stridesBlock.push(`\n      indices[${rank - 1}] = offset;`);\n    return `\n      void ${name}(int offset, out int indices[${rank}]) {\n        ${stridesBlock.join('')}\n      }\n      `;\n  }\n  protected incrementIndices(): { [name: string]: GlslLibRoutine } {\n    const result: { [name: string]: GlslLibRoutine } = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const rank = shape.length;\n      const funcName = `incrementIndices_${name}`;\n      let shapeInit = '';\n      for (let i = 0; i < rank; ++i) {\n        shapeInit += `\n        shape[${i}] = ${shape[i]};`;\n      }\n      const body = `\n        void ${funcName}(int axis, out int indices[${rank}]) {\n          int shape[${rank}];\n          ${shapeInit};\n          for(int i = ${rank} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;\n      result[funcName] = new GlslLibRoutine(body);\n    });\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { GlslContext, GlslLib, GlslLibRoutine } from './glsl-definitions';\n\n/**\n * GLSL Library responsible for vec routines\n * Vec is an varible length int array. The length is fixed at the time of\n * generating the library functions from the dimensions of the output.\n */\nexport class VecGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getCustomTypes(): { [name: string]: string } {\n    return {};\n  }\n  getFunctions(): { [name: string]: GlslLibRoutine } {\n    return { ...this.binaryVecFunctions(), ...this.copyVec(), ...this.setVecItem(), ...this.getVecItem() };\n  }\n  protected binaryVecFunctions(): { [name: string]: GlslLibRoutine } {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    const nameOp: { [name: string]: string } = { add: '+=', sub: '-=', mul: '*=', div: '/=' };\n    const result: { [name: string]: GlslLibRoutine } = {};\n    for (const name in nameOp) {\n      const fname = `${name}Vec`;\n      let assignmentBlock = '';\n      for (let i = 0; i < rank; ++i) {\n        assignmentBlock += `\n          dest[${i}] ${nameOp[name]} src[${i}];\n          `;\n      }\n      const body = `\n        void ${fname}(int src[${rank}], out int dest[${rank}]) {\n          ${assignmentBlock}\n        }\n        `;\n      result[fname] = new GlslLibRoutine(body);\n    }\n\n    return result;\n  }\n  protected copyVec(): { [name: string]: GlslLibRoutine } {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let assignmentBlock = '';\n    for (let i = 0; i < rank; ++i) {\n      assignmentBlock += `\n        dest[${i}] = src[${i}];\n        `;\n    }\n    const body = `\n      void copyVec(int src[${rank}], out int dest[${rank}]) {\n        ${assignmentBlock}\n      }\n      `;\n    return { copyVec: new GlslLibRoutine(body) };\n  }\n\n  protected setVecItem(): { [name: string]: GlslLibRoutine } {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let block = `\n        if(index < 0)\n            index =${rank} + index;\n        if (index == 0)\n            m[0] = value;\n        `;\n    for (let i = 1; i < rank - 1; ++i) {\n      block += `\n        else if (index == ${i})\n            m[${i}] = value;\n            `;\n    }\n    block += `\n        else\n            m[${rank - 1}] = value;\n        `;\n    const body = `\n      void setVecItem(out int m[${rank}], int index, int value) {\n        ${block}\n      }\n        `;\n    return { setVecItem: new GlslLibRoutine(body) };\n  }\n  protected getVecItem(): { [name: string]: GlslLibRoutine } {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let block = `\n        if(index < 0)\n            index = ${rank} + index;\n        if (index == 0)\n            return m[0];\n      `;\n    for (let i = 1; i < rank - 1; ++i) {\n      block += `\n        else if (index == ${i})\n            return m[${i}];\n      `;\n    }\n    block += `\n        else\n            return m[${rank - 1}];\n        `;\n    const body = `\n      int getVecItem(int m[${rank}], int index) {\n        ${block}\n      }\n    `;\n    return { getVecItem: new GlslLibRoutine(body) };\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { CoordsGlslLib } from './glsl-coordinate-lib';\nimport { GlslContext, GlslLib } from './glsl-definitions';\nimport { EncodingGlslLib } from './glsl-encoding-lib';\nimport { FragColorGlslLib } from './glsl-fragcolor-lib';\nimport { ShapeUtilsGlslLib } from './glsl-shape-utils-lib';\nimport { VecGlslLib } from './glsl-vec-lib';\n\nexport const glslRegistry: { [name: string]: new (context: GlslContext) => GlslLib } = {\n  encoding: EncodingGlslLib,\n  fragcolor: FragColorGlslLib,\n  vec: VecGlslLib,\n  shapeUtils: ShapeUtilsGlslLib,\n  coordinates: CoordsGlslLib,\n  //  'arrays': ArrayGlslSLib\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { GlslContext, GlslLib, GlslLibRoutineNode, TopologicalSortGlslRoutines } from './glsl-definitions';\nimport { replaceInlines } from './glsl-function-inliner';\nimport { glslRegistry } from './glsl-registered-libs';\nimport { getDefaultFragShaderMain, getFragShaderPreamble } from './glsl-source';\nimport { ProgramInfo, TextureLayout, VariableInfo } from './types';\nimport { WebGLContext } from './webgl-context';\n\n/**\n * Preprocessor for the additions to the GLSL language\n * It deals with:\n *  @include directives\n *  @inline\n *  Loop unrolling (not implemented)\n *  Macro resolution (not implemented)\n */\nexport class GlslPreprocessor {\n  readonly context: GlslContext;\n  readonly libs: { [name: string]: GlslLib } = {};\n  readonly glslLibRoutineDependencyGraph: { [routineName: string]: GlslLibRoutineNode } = {};\n\n  constructor(\n    glContext: WebGLContext,\n    programInfo: ProgramInfo,\n    inputTextureLayouts: TextureLayout[],\n    outputTextureLayout: TextureLayout,\n  ) {\n    this.context = new GlslContext(glContext, programInfo, inputTextureLayouts, outputTextureLayout);\n\n    // construct GlslLibs\n    Object.keys(glslRegistry).forEach((name: string) => {\n      const lib = new glslRegistry[name](this.context);\n      this.libs[name] = lib;\n    });\n\n    // construct GlslRoutineDependencyGraph\n    const map = this.glslLibRoutineDependencyGraph;\n    for (const libName in this.libs) {\n      const lib = this.libs[libName];\n      const routinesInLib = lib.getFunctions();\n      for (const routine in routinesInLib) {\n        const key = libName + '.' + routine;\n        let currentNode: GlslLibRoutineNode;\n        if (map[key]) {\n          currentNode = map[key];\n          currentNode.routineBody = routinesInLib[routine].routineBody;\n        } else {\n          currentNode = new GlslLibRoutineNode(key, routinesInLib[routine].routineBody);\n          map[key] = currentNode;\n        }\n        const dependencies = routinesInLib[routine].dependencies;\n        if (dependencies) {\n          for (let i = 0; i < dependencies.length; ++i) {\n            if (!map[dependencies[i]]) {\n              const node = new GlslLibRoutineNode(dependencies[i]);\n              map[dependencies[i]] = node;\n              currentNode.addDependency(node);\n            } else {\n              currentNode.addDependency(map[dependencies[i]]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  preprocess(): string {\n    const programInfo = this.context.programInfo;\n    let source = programInfo.shaderSource;\n\n    // append main() function\n    if (!this.context.programInfo.hasMain) {\n      source = `${source}\n      ${getDefaultFragShaderMain(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`;\n    }\n    // replace inlines\n    source = replaceInlines(source);\n\n    // concat final source string\n    return `${getFragShaderPreamble(this.context.glContext.version)}\n    ${this.getUniforms(programInfo.inputNames, programInfo.variables)}\n    ${this.getImports(source)}\n    ${source}`;\n  }\n\n  protected getImports(script: string): string {\n    const routinesIncluded = this.selectGlslLibRoutinesToBeIncluded(script);\n\n    if (routinesIncluded.length === 0) {\n      return '';\n    }\n\n    let routines = '';\n    for (let i = 0; i < routinesIncluded.length; ++i) {\n      if (routinesIncluded[i].routineBody) {\n        routines += routinesIncluded[i].routineBody + '\\n';\n      } else {\n        throw new Error(`Missing body for the Glsl Library routine: ${routinesIncluded[i].name}`);\n      }\n    }\n\n    return routines;\n  }\n  private selectGlslLibRoutinesToBeIncluded(script: string): GlslLibRoutineNode[] {\n    const nodes: GlslLibRoutineNode[] = [];\n\n    Object.keys(this.glslLibRoutineDependencyGraph).forEach((classAndRoutine) => {\n      const routine = classAndRoutine.split('.')[1];\n      if (script.indexOf(routine) !== -1) {\n        nodes.push(this.glslLibRoutineDependencyGraph[classAndRoutine]);\n      }\n    });\n\n    return TopologicalSortGlslRoutines.returnOrderedNodes(nodes);\n  }\n\n  protected getUniforms(samplers?: string[], variables?: VariableInfo[]): string {\n    const uniformLines: string[] = [];\n    if (samplers) {\n      for (const sampler of samplers) {\n        uniformLines.push(`uniform sampler2D ${sampler};`);\n      }\n    }\n    if (variables) {\n      for (const variable of variables) {\n        uniformLines.push(\n          `uniform ${variable.type} ${variable.name}${variable.arrayLength ? `[${variable.arrayLength}]` : ''};`,\n        );\n      }\n    }\n    return uniformLines.join('\\n');\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env } from 'onnxruntime-common';\n\nimport { Logger, Profiler } from '../../instrument';\n\nimport { GlslPreprocessor } from './glsl-preprocessor';\nimport { getVertexShaderSource } from './glsl-source';\nimport { TextureLayoutStrategy } from './texture-layout-strategy';\nimport { Artifact, ProgramInfo, ProgramVariable, TextureData, TextureLayout, VariableInfo } from './types';\nimport { WebGLContext } from './webgl-context';\n\n/**\n * ProgramManager is the main class behind running computations\n * It builds ProgramInfo's into Artifacts\n * It compiles given ProgramInfo's into WebGL Prorams (cached as Artifacts)\n * Uses the artifact to run the computation by calling Draw on\n * the WebGL drawing buffer\n * ProgramManager automatically maps (binds) input variables to their\n * corresponding Location's in the binary program\n */\nexport class ProgramManager {\n  repo: Map<unknown, Artifact>; // this should be per-session object\n  vertexShader: WebGLShader;\n  attributesBound: boolean;\n\n  constructor(\n    public profiler: Readonly<Profiler>,\n    public glContext: WebGLContext,\n    public textureLayoutStrategy: TextureLayoutStrategy,\n  ) {\n    this.repo = new Map();\n    this.attributesBound = false;\n  }\n  getArtifact(key: unknown): Artifact | undefined {\n    return this.repo.get(key);\n  }\n  setArtifact(key: unknown, artifact: Artifact): void {\n    this.repo.set(key, artifact);\n  }\n  run(buildArtifact: Artifact, inputs: TextureData[], output: TextureData): void {\n    this.profiler.event(\n      'op',\n      `ProgramManager.run ${buildArtifact.programInfo.name ?? 'unknown kernel'}`,\n      () => {\n        const gl = this.glContext.gl;\n        const program = buildArtifact.program;\n        gl.useProgram(program);\n        try {\n          this.bindOutput(output);\n          if (!this.attributesBound) {\n            this.bindAttributes(buildArtifact.attribLocations);\n          }\n          this.bindUniforms(buildArtifact.uniformLocations, buildArtifact.programInfo.variables ?? [], inputs);\n        } catch (err) {\n          Logger.error('ProgramManager', buildArtifact.programInfo.shaderSource);\n          throw err;\n        }\n        this.profiler.event('backend', 'GlContext.draw()', () => {\n          this.glContext.draw();\n        });\n      },\n      this.glContext,\n    );\n  }\n  dispose(): void {\n    if (this.vertexShader) {\n      this.glContext.deleteShader(this.vertexShader);\n    }\n    this.repo.forEach((a) => this.glContext.deleteProgram(a.program));\n  }\n  build(programInfo: ProgramInfo, inputTextureLayouts: TextureLayout[], outputTextureLayout: TextureLayout): Artifact {\n    return this.profiler.event('backend', 'ProgramManager.build', () => {\n      const preprocessor = new GlslPreprocessor(this.glContext, programInfo, inputTextureLayouts, outputTextureLayout);\n      const fragScript = preprocessor.preprocess();\n      const program = this.compile(fragScript);\n      const artifact = {\n        programInfo,\n        program,\n        uniformLocations: this.getUniformLocations(\n          program,\n          preprocessor.context.programInfo.inputNames,\n          preprocessor.context.programInfo.variables,\n        ),\n        attribLocations: this.getAttribLocations(program),\n      };\n      return artifact;\n    });\n  }\n  protected compile(fragShaderScript: string): WebGLProgram {\n    if (!this.vertexShader) {\n      Logger.verbose('ProrgramManager', 'Compiling and caching Vertex shader for the first time');\n      const vertexShaderScript = getVertexShaderSource(this.glContext.version);\n      this.vertexShader = this.glContext.compileShader(vertexShaderScript, this.glContext.gl.VERTEX_SHADER);\n    }\n    if (env.debug) {\n      Logger.verbose(\n        'ProrgramManager',\n        `FragShader:\n${fragShaderScript}\n`,\n      );\n    }\n    const fragShader = this.glContext.compileShader(fragShaderScript, this.glContext.gl.FRAGMENT_SHADER);\n    const program = this.glContext.createProgram(this.vertexShader, fragShader);\n    this.glContext.deleteShader(fragShader);\n    return program;\n  }\n  bindOutput(td: TextureData): void {\n    const width = td.width;\n    const height = td.height;\n    Logger.verbose(\n      'ProrgramManager',\n      `Binding output texture to Framebuffer: w/h=${width}/${height}, shape=${td.shape}, type=${td.tensor.type}`,\n    );\n    this.glContext.attachFramebuffer(td.texture, width, height);\n  }\n  bindAttributes(attribLocations: Artifact.AttribLocations): void {\n    const positionHandle = attribLocations.position;\n    const textureCoordHandle = attribLocations.textureCoord;\n    this.glContext.setVertexAttributes(positionHandle, textureCoordHandle);\n    this.attributesBound = true;\n  }\n  bindUniforms(\n    uniformLocations: Artifact.UniformLocations,\n    variables: ProgramVariable[],\n    textures: TextureData[],\n  ): void {\n    const gl = this.glContext.gl;\n    let texturePosition = 0;\n    for (const { name, type, location, arrayLength } of uniformLocations) {\n      const value = variables.find((v) => v.name === name)?.data;\n      if (type !== 'sampler2D' && !value) {\n        throw new Error(`variable '${name}' does not have data defined in program info`);\n      }\n      switch (type) {\n        case 'sampler2D':\n          this.bindTexture(textures[texturePosition], location, texturePosition);\n          texturePosition++;\n          break;\n        case 'float':\n          if (arrayLength) {\n            gl.uniform1fv(location, value as number[]);\n          } else {\n            gl.uniform1f(location, value as number);\n          }\n          break;\n        case 'int':\n          if (arrayLength) {\n            gl.uniform1iv(location, value as number[]);\n          } else {\n            gl.uniform1i(location, value as number);\n          }\n          break;\n        default:\n          throw new Error(`Uniform not implemented: ${type}`);\n      }\n    }\n  }\n  bindTexture(td: TextureData, uniformHandle: WebGLUniformLocation, position: number): void {\n    this.glContext.bindTextureToUniform(td.texture, position, uniformHandle);\n  }\n  getAttribLocations(program: WebGLProgram): Artifact.AttribLocations {\n    return {\n      position: this.getAttribLocation(program, 'position'),\n      textureCoord: this.getAttribLocation(program, 'textureCoord'),\n    };\n  }\n  getUniformLocations(\n    program: WebGLProgram,\n    samplers?: string[],\n    variables?: VariableInfo[],\n  ): Artifact.UniformLocations {\n    const uniformLocations: Artifact.UniformLocations = [];\n    if (samplers) {\n      for (const sampler of samplers) {\n        uniformLocations.push({\n          name: sampler,\n          type: 'sampler2D',\n          location: this.getUniformLocation(program, sampler),\n        });\n      }\n    }\n    if (variables) {\n      for (const variable of variables) {\n        uniformLocations.push({ ...variable, location: this.getUniformLocation(program, variable.name) });\n      }\n    }\n    return uniformLocations;\n  }\n  getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation {\n    const gl = this.glContext.gl;\n    const reference = gl.getUniformLocation(program, name);\n    if (reference === null) {\n      throw new Error(`Uniform ${name} not found.`);\n    }\n    return reference;\n  }\n  getAttribLocation(program: WebGLProgram, name: string): number {\n    const gl = this.glContext.gl;\n    const attributeLocation: number = gl.getAttribLocation(program, name);\n    return attributeLocation;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Logger, Profiler } from '../../instrument';\nimport { Tensor } from '../../tensor';\n\nimport { Encoder, EncoderUsage } from './texture-data-encoder';\nimport { TextureLayoutStrategy } from './texture-layout-strategy';\nimport { TextureData, TextureLayout } from './types';\nimport { WebGLContext } from './webgl-context';\n\nexport interface TextureManagerConfig {\n  reuseTextures?: boolean;\n}\n\n/**\n * TextureManager is the mainly responsible for caching Textures\n * Textures are cached in 2 levels:\n *   1. the texures which are associated with a dataId (from Tensor)\n *    Caching these is crucial to performance. These are In-use Textures\n *   2. textures which are not in use by any current ProgramInfo/Tensor\n *     These are called Free Textures\n * TextureManager is also used to help creating textures. For this it\n * uses WebGLContext and TextureLayoutStrategy\n */\nexport class TextureManager {\n  private readonly inUseTextures: Map<string, WebGLTexture[]>;\n  private readonly idleTextures: Map<string, WebGLTexture[]>;\n  private readonly textureLookup: Map<WebGLTexture, string>;\n  private readonly pendingRead: Map<Tensor.Id, Array<(arr: Tensor.NumberType) => void>> = new Map();\n\n  constructor(\n    public glContext: WebGLContext,\n    public layoutStrategy: TextureLayoutStrategy,\n    public profiler: Readonly<Profiler>,\n    private config: TextureManagerConfig,\n  ) {\n    if (config.reuseTextures) {\n      this.inUseTextures = new Map();\n      this.idleTextures = new Map();\n      this.textureLookup = new Map();\n    }\n  }\n  createTextureFromLayout(\n    dataType: Tensor.DataType,\n    layout: TextureLayout,\n    data?: Tensor.NumberType,\n    usage?: EncoderUsage,\n  ) {\n    const textureDataType = this.toEncoderType(dataType);\n\n    const encoder = this.glContext.getEncoder(textureDataType, layout.channels || 1, usage);\n    if (layout.isPacked && usage === EncoderUsage.UploadOnly) {\n      throw new Error('not implemented');\n    }\n    const width = layout.width;\n    const height = layout.height;\n\n    let key: string | undefined;\n    let inUseTextures: WebGLTexture[] | undefined;\n    if (this.config.reuseTextures) {\n      key = `${width}x${height}_${encoder.format}_${encoder.internalFormat}_${encoder.textureType}`;\n      inUseTextures = this.inUseTextures.get(key);\n      if (!inUseTextures) {\n        inUseTextures = [];\n        this.inUseTextures.set(key, inUseTextures);\n      }\n\n      const idleTextures = this.idleTextures.get(key);\n      if (idleTextures && idleTextures.length > 0) {\n        const texture = idleTextures.pop()!;\n        inUseTextures.push(texture);\n        if (usage === EncoderUsage.UploadOnly) {\n          this.glContext.updateTexture(texture, width, height, encoder, this.toTextureData(dataType, data)!);\n        }\n        return texture;\n      }\n    }\n\n    Logger.verbose('TextureManager', `Creating new texture of size ${layout.width}x${layout.height}`);\n    const texture = this.glContext.allocateTexture(width, height, encoder, this.toTextureData(dataType, data));\n\n    if (this.config.reuseTextures) {\n      inUseTextures!.push(texture);\n      this.textureLookup.set(texture, key!);\n    }\n    return texture;\n  }\n  readTexture(td: TextureData, dataType: Tensor.DataType, channels?: number): Tensor.NumberType {\n    if (!channels) {\n      channels = 1;\n    }\n    return this.profiler.event('backend', 'TextureManager.readTexture', () => {\n      const dataSize = td.shape.reduce((a, b) => a * b) * channels!;\n      const data = this.glContext.readTexture(\n        td.texture,\n        td.width,\n        td.height,\n        dataSize,\n        this.toEncoderType(dataType),\n        channels!,\n      );\n      return this.toTensorData(dataType, data);\n    });\n  }\n  async readTextureAsync(td: TextureData, dataType: Tensor.DataType, channels?: number): Promise<Tensor.NumberType> {\n    const dataId = td.tensor.dataId;\n    if (!channels) {\n      channels = 1;\n    }\n    if (this.pendingRead.has(dataId)) {\n      const subscribers = this.pendingRead.get(dataId);\n      return new Promise<Tensor.NumberType>((resolve) => subscribers?.push(resolve));\n    }\n    return this.profiler.event('backend', 'TextureManager.readTextureAsync', async () => {\n      this.pendingRead.set(dataId, []);\n      const dataSize = td.shape.reduce((a, b) => a * b) * channels!;\n      // add a fence waiting for the data to be ready\n      await this.glContext.createAndWaitForFence();\n      const data = this.glContext.readTexture(\n        td.texture,\n        td.width,\n        td.height,\n        dataSize,\n        this.toEncoderType(dataType),\n        channels!,\n      );\n      const tensorData = this.toTensorData(dataType, data);\n      const subscribers = this.pendingRead.get(dataId);\n      this.pendingRead.delete(dataId);\n      subscribers?.forEach((resolve) => resolve(tensorData));\n      return tensorData;\n    });\n  }\n  readUint8TextureAsFloat(td: TextureData): Float32Array {\n    return this.profiler.event('backend', 'TextureManager.readUint8TextureAsFloat', () => {\n      const dataSize = td.shape.reduce((a, b) => a * b);\n      const data = this.glContext.readTexture(td.texture, td.width, td.height, dataSize * 4, 'byte', 4);\n      return new Float32Array(data.buffer, data.byteOffset, dataSize);\n    });\n  }\n  releaseTexture(textureData: TextureData, deleteTexture?: boolean): void {\n    let key: string | undefined;\n    if (this.config.reuseTextures) {\n      key = this.textureLookup.get(textureData.texture);\n      if (key) {\n        if (deleteTexture) {\n          this.textureLookup.delete(key);\n        }\n        const inUseTextures = this.inUseTextures.get(key);\n        if (inUseTextures) {\n          const index = inUseTextures.indexOf(textureData.texture);\n          if (index !== -1) {\n            inUseTextures.splice(index, 1);\n            let idleTextures = this.idleTextures.get(key);\n            if (!idleTextures) {\n              idleTextures = [];\n              this.idleTextures.set(key, idleTextures);\n            }\n            idleTextures.push(textureData.texture);\n          }\n        }\n      }\n    }\n\n    if (!key || deleteTexture) {\n      Logger.verbose('TextureManager', `Deleting texture of size ${textureData.width}x${textureData.height}`);\n      this.glContext.deleteTexture(textureData.texture);\n    }\n  }\n  toTensorData(dataType: Tensor.DataType, data: Encoder.DataArrayType): Tensor.NumberType {\n    switch (dataType) {\n      case 'int16':\n        return data instanceof Int16Array ? data : Int16Array.from(data);\n      case 'int32':\n        return data instanceof Int32Array ? data : Int32Array.from(data);\n      case 'int8':\n        return data instanceof Int8Array ? data : Int8Array.from(data);\n      case 'uint16':\n        return data instanceof Uint16Array ? data : Uint16Array.from(data);\n      case 'uint32':\n        return data instanceof Uint32Array ? data : Uint32Array.from(data);\n      case 'uint8':\n      case 'bool':\n        return data instanceof Uint8Array ? data : Uint8Array.from(data);\n      case 'float32':\n        return data instanceof Float32Array ? data : Float32Array.from(data);\n      case 'float64':\n        return data instanceof Float64Array ? data : Float64Array.from(data);\n      default:\n        throw new Error(`TensorData type ${dataType} is not supported`);\n    }\n  }\n  toTextureData(_dataType: Tensor.DataType, data: Tensor.NumberType | undefined): Encoder.DataArrayType | undefined {\n    if (!data) {\n      return undefined;\n    }\n    return data instanceof Float32Array ? data : new Float32Array(data);\n    /*\n    switch (dataType) {\n      case 'int16':\n      case 'int32':\n      case 'uint16':\n      case 'uint32':\n        return (data.constructor === Uint32Array) ? data as Uint32Array : new Uint32Array(data);\n      case 'int8':\n      case 'uint8':\n      case 'bool':\n        return (data.constructor === Uint8Array) ? data as Uint8Array : new Uint8Array(data);\n      case 'float32':\n      case 'float64':\n        return (data.constructor === Float32Array) ? data as Float32Array : new Float32Array(data);\n      default:\n        throw new Error(`TensorData type ${dataType} is not supported`);\n    }\n    */\n  }\n  toEncoderType(_dataType: Tensor.DataType): Encoder.DataType {\n    return 'float';\n    // switch (dataType) {\n    //   case 'int16':\n    //   case 'int32':\n    //   case 'uint16':\n    //   case 'uint32':\n    //     return 'int';\n    //   case 'uint8':\n    //   case 'bool':\n    //     return 'byte';\n    //   case 'float32':\n    //   case 'float64':\n    //     return 'float';\n    //   default:\n    //     throw new Error(`TensorData type ${dataType} is not supported`);\n    // }\n  }\n  clearActiveTextures(): void {\n    this.glContext.clearActiveTextures();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { SessionHandler } from '../../backend';\nimport { Graph } from '../../graph';\nimport { Logger } from '../../instrument';\nimport { Operator } from '../../operators';\nimport { OpSet, resolveOperator } from '../../opset';\nimport { Session } from '../../session';\nimport { Tensor } from '../../tensor';\nimport { WebGLBackend } from '../backend-webgl';\n\nimport { WebGLInferenceHandler } from './inference-handler';\nimport { WEBGL_OP_RESOLVE_RULES } from './op-resolve-rules';\nimport { ProgramManager } from './program-manager';\nimport { PreferLogicalStrategy, TextureLayoutStrategy } from './texture-layout-strategy';\nimport { TextureManager } from './texture-manager';\nimport { TextureData } from './types';\n\nexport class WebGLSessionHandler implements SessionHandler {\n  programManager: ProgramManager;\n  textureManager: TextureManager;\n  layoutStrategy: TextureLayoutStrategy;\n  packedTextureDataCache: Map<Tensor.Id, TextureData>;\n  unpackedTextureDataCache: Map<Tensor.Id, TextureData>;\n  pack2unpackMap: Map<Tensor.Id, Tensor.Id>;\n  unpack2packMap: Map<Tensor.Id, Tensor.Id>;\n  initializers: Set<Tensor.Id>;\n  pack?: boolean;\n\n  constructor(\n    public readonly backend: WebGLBackend,\n    public readonly context: Session.Context,\n  ) {\n    this.layoutStrategy = new PreferLogicalStrategy(backend.glContext.maxTextureSize);\n    this.programManager = new ProgramManager(this.context.profiler, backend.glContext, this.layoutStrategy);\n    this.textureManager = new TextureManager(backend.glContext, this.layoutStrategy, this.context.profiler, {\n      reuseTextures: backend.textureCacheMode === 'full',\n    });\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache = new Map();\n    this.pack = backend.pack;\n    this.pack2unpackMap = new Map();\n    this.unpack2packMap = new Map();\n  }\n\n  createInferenceHandler() {\n    return new WebGLInferenceHandler(this);\n  }\n  onGraphInitialized(graph: Graph): void {\n    const initializers = graph\n      .getValues()\n      .filter((v) => v.from === -1 && v.tensor)\n      .map((v) => v.tensor!.dataId);\n    this.initializers = new Set(initializers);\n  }\n  isInitializer(tensorId: Tensor.Id): boolean {\n    return this.initializers ? this.initializers.has(tensorId) : false;\n  }\n  addInitializer(tensorId: Tensor.Id): void {\n    this.initializers.add(tensorId);\n  }\n  getTextureData(tensorId: Tensor.Id, isPacked: boolean): TextureData | undefined {\n    if (isPacked) {\n      return this.packedTextureDataCache.get(tensorId);\n    } else {\n      return this.unpackedTextureDataCache.get(tensorId);\n    }\n  }\n  setTextureData(tensorId: Tensor.Id, textureData: TextureData, isPacked = false): void {\n    Logger.verbose('WebGLSessionHandler', 'Storing Texture data in cache');\n    if (isPacked) {\n      this.packedTextureDataCache.set(tensorId, textureData);\n    } else {\n      this.unpackedTextureDataCache.set(tensorId, textureData);\n    }\n  }\n  dispose(): void {\n    this.programManager.dispose();\n    this.textureManager.clearActiveTextures();\n    this.packedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));\n    this.unpackedTextureDataCache = new Map();\n  }\n  resolve(node: Graph.Node, opsets: readonly OpSet[], graph: Graph): Operator {\n    const op = resolveOperator(node, opsets, WEBGL_OP_RESOLVE_RULES);\n    return { impl: op.opImpl, context: op.opInit ? op.opInit(node, graph) : node };\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env } from 'onnxruntime-common';\n\nimport * as DataEncoders from './texture-data-encoder';\nimport { DataEncoder, Encoder, EncoderUsage } from './texture-data-encoder';\nimport { repeatedTry } from './utils';\n\nexport interface FenceContext {\n  query: WebGLSync | null;\n  isFencePassed(): boolean;\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean;\n  resolveFn: () => void;\n};\n\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n\n/**\n * Abstraction and wrapper around WebGLRenderingContext and its operations\n */\nexport class WebGLContext {\n  gl: WebGLRenderingContext;\n  version: 1 | 2;\n\n  private vertexbuffer: WebGLBuffer;\n  private framebuffer: WebGLFramebuffer;\n\n  // WebGL flags and vital parameters\n  private isFloatTextureAttachableToFrameBuffer: boolean;\n  isFloat32DownloadSupported: boolean;\n  isRenderFloat32Supported: boolean;\n  isBlendSupported: boolean;\n  maxTextureSize: number;\n  // private maxCombinedTextureImageUnits: number;\n  private maxTextureImageUnits: number;\n  // private maxCubeMapTextureSize: number;\n  // private shadingLanguageVersion: string;\n  // private webglVendor: string;\n  // private webglVersion: string;\n\n  // WebGL2 flags and vital parameters\n  // private max3DTextureSize: number;\n  // private maxArrayTextureLayers: number;\n  // private maxColorAttachments: number;\n  // private maxDrawBuffers: number;\n\n  // WebGL extensions\n  // eslint-disable-next-line camelcase\n  textureFloatExtension: OES_texture_float | null;\n  // eslint-disable-next-line camelcase\n  textureHalfFloatExtension: OES_texture_half_float | null;\n\n  // WebGL2 extensions\n  colorBufferFloatExtension: unknown | null;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  disjointTimerQueryWebgl2Extension: { TIME_ELAPSED_EXT: GLenum; GPU_DISJOINT_EXT: GLenum } | null;\n\n  private disposed: boolean;\n  private frameBufferBound = false;\n\n  constructor(gl: WebGLRenderingContext, version: 1 | 2) {\n    this.gl = gl;\n    this.version = version;\n\n    this.getExtensions();\n    this.vertexbuffer = this.createVertexbuffer();\n    this.framebuffer = this.createFramebuffer();\n    this.queryVitalParameters();\n  }\n\n  allocateTexture(width: number, height: number, encoder: DataEncoder, data?: Encoder.DataArrayType): WebGLTexture {\n    const gl = this.gl;\n    // create the texture\n    const texture = gl.createTexture();\n    // bind the texture so the following methods effect this texture.\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    const buffer = data ? encoder.encode(data, width * height) : null;\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0, // Level of detail.\n      encoder.internalFormat,\n      width,\n      height,\n      0, // Always 0 in OpenGL ES.\n      encoder.format,\n      encoder.textureType,\n      buffer,\n    );\n    this.checkError();\n    return texture as WebGLTexture;\n  }\n  updateTexture(\n    texture: WebGLTexture,\n    width: number,\n    height: number,\n    encoder: DataEncoder,\n    data: Encoder.DataArrayType,\n  ): void {\n    const gl = this.gl;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const buffer = encoder.encode(data, width * height);\n    gl.texSubImage2D(\n      gl.TEXTURE_2D,\n      0, // level\n      0, // xoffset\n      0, // yoffset\n      width,\n      height,\n      encoder.format,\n      encoder.textureType,\n      buffer,\n    );\n    this.checkError();\n  }\n  attachFramebuffer(texture: WebGLTexture, width: number, height: number): void {\n    const gl = this.gl;\n    // Make it the target for framebuffer operations - including rendering.\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // 0, we aren't using MIPMAPs\n    this.checkError();\n    gl.viewport(0, 0, width, height);\n    gl.scissor(0, 0, width, height);\n  }\n  readTexture(\n    texture: WebGLTexture,\n    width: number,\n    height: number,\n    dataSize: number,\n    dataType: Encoder.DataType,\n    channels: number,\n  ): Encoder.DataArrayType {\n    const gl = this.gl;\n    if (!channels) {\n      channels = 1;\n    }\n    if (!this.frameBufferBound) {\n      this.attachFramebuffer(texture, width, height);\n    }\n    const encoder = this.getEncoder(dataType, channels);\n    const buffer = encoder.allocate(width * height);\n    // bind texture to framebuffer\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // 0, we aren't using MIPMAPs\n    // TODO: Check if framebuffer is ready\n    gl.readPixels(0, 0, width, height, gl.RGBA, encoder.textureType, buffer);\n    this.checkError();\n    // unbind FB\n    return encoder.decode(buffer, dataSize);\n  }\n\n  isFramebufferReady(): boolean {\n    // TODO: Implement logic to check if the framebuffer is ready\n    return true;\n  }\n  getActiveTexture(): string {\n    const gl = this.gl;\n    const n = gl.getParameter(this.gl.ACTIVE_TEXTURE);\n    return `TEXTURE${n - gl.TEXTURE0}`;\n  }\n  getTextureBinding(): WebGLTexture {\n    return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n  }\n  getFramebufferBinding(): WebGLFramebuffer {\n    return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n  }\n  setVertexAttributes(positionHandle: number, textureCoordHandle: number): void {\n    const gl = this.gl;\n    gl.vertexAttribPointer(positionHandle, 3, gl.FLOAT, false, 20, 0);\n    gl.enableVertexAttribArray(positionHandle);\n    if (textureCoordHandle !== -1) {\n      gl.vertexAttribPointer(textureCoordHandle, 2, gl.FLOAT, false, 20, 12);\n      gl.enableVertexAttribArray(textureCoordHandle);\n    }\n    this.checkError();\n  }\n  createProgram(vertexShader: WebGLShader, fragShader: WebGLShader): WebGLProgram {\n    const gl = this.gl;\n    const program = gl.createProgram()!;\n\n    // the program consists of our shaders\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragShader);\n    gl.linkProgram(program);\n    return program;\n  }\n  compileShader(shaderSource: string, shaderType: number): WebGLShader {\n    const gl = this.gl;\n    const shader = gl.createShader(shaderType);\n    if (!shader) {\n      throw new Error(`createShader() returned null with type ${shaderType}`);\n    }\n\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {\n      throw new Error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}\nShader source:\n${shaderSource}`);\n    }\n    return shader;\n  }\n  deleteShader(shader: WebGLShader): void {\n    this.gl.deleteShader(shader);\n  }\n  bindTextureToUniform(texture: WebGLTexture, position: number, uniformHandle: WebGLUniformLocation): void {\n    const gl = this.gl;\n    gl.activeTexture(gl.TEXTURE0 + position);\n    this.checkError();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    this.checkError();\n    gl.uniform1i(uniformHandle, position);\n    this.checkError();\n  }\n  draw(): void {\n    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n    this.checkError();\n  }\n  checkError(): void {\n    if (env.debug) {\n      const gl = this.gl;\n      const error = gl.getError();\n      let label = '';\n      switch (error) {\n        case gl.NO_ERROR:\n          return;\n        case gl.INVALID_ENUM:\n          label = 'INVALID_ENUM';\n          break;\n        case gl.INVALID_VALUE:\n          label = 'INVALID_VALUE';\n          break;\n        case gl.INVALID_OPERATION:\n          label = 'INVALID_OPERATION';\n          break;\n        case gl.INVALID_FRAMEBUFFER_OPERATION:\n          label = 'INVALID_FRAMEBUFFER_OPERATION';\n          break;\n        case gl.OUT_OF_MEMORY:\n          label = 'OUT_OF_MEMORY';\n          break;\n        case gl.CONTEXT_LOST_WEBGL:\n          label = 'CONTEXT_LOST_WEBGL';\n          break;\n        default:\n          label = `Unknown WebGL Error: ${error.toString(16)}`;\n      }\n      throw new Error(label);\n    }\n  }\n  deleteTexture(texture: WebGLTexture): void {\n    this.gl.deleteTexture(texture);\n  }\n  deleteProgram(program: WebGLProgram): void {\n    this.gl.deleteProgram(program);\n  }\n  getEncoder(dataType: Encoder.DataType, channels: number, usage: EncoderUsage = EncoderUsage.Default): DataEncoder {\n    if (this.version === 2) {\n      return new DataEncoders.RedFloat32DataEncoder(this.gl as WebGL2RenderingContext, channels);\n    }\n\n    switch (dataType) {\n      case 'float':\n        if (usage === EncoderUsage.UploadOnly || this.isRenderFloat32Supported) {\n          return new DataEncoders.RGBAFloatDataEncoder(this.gl, channels);\n        } else {\n          return new DataEncoders.RGBAFloatDataEncoder(\n            this.gl,\n            channels,\n            this.textureHalfFloatExtension!.HALF_FLOAT_OES,\n          );\n        }\n      case 'int':\n        throw new Error('not implemented');\n      case 'byte':\n        return new DataEncoders.Uint8DataEncoder(this.gl, channels);\n      default:\n        throw new Error(`Invalid dataType: ${dataType}`);\n    }\n  }\n  clearActiveTextures(): void {\n    const gl = this.gl;\n    for (let unit = 0; unit < this.maxTextureImageUnits; ++unit) {\n      gl.activeTexture(gl.TEXTURE0 + unit);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n  }\n  dispose(): void {\n    if (this.disposed) {\n      return;\n    }\n    const gl = this.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteFramebuffer(this.framebuffer);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.deleteBuffer(this.vertexbuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    gl.finish();\n    this.disposed = true;\n  }\n\n  private createDefaultGeometry(): Float32Array {\n    // Sets of x,y,z(=0),s,t coordinates.\n    return new Float32Array([\n      -1.0,\n      1.0,\n      0.0,\n      0.0,\n      1.0, // upper left\n      -1.0,\n      -1.0,\n      0.0,\n      0.0,\n      0.0, // lower left\n      1.0,\n      1.0,\n      0.0,\n      1.0,\n      1.0, // upper right\n      1.0,\n      -1.0,\n      0.0,\n      1.0,\n      0.0, // lower right\n    ]);\n  }\n  private createVertexbuffer(): WebGLBuffer {\n    const gl = this.gl;\n    const buffer = gl.createBuffer();\n    if (!buffer) {\n      throw new Error('createBuffer() returned null');\n    }\n    const geometry = this.createDefaultGeometry();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, geometry, gl.STATIC_DRAW);\n    this.checkError();\n    return buffer;\n  }\n  private createFramebuffer(): WebGLFramebuffer {\n    const fb = this.gl.createFramebuffer();\n    if (!fb) {\n      throw new Error('createFramebuffer returned null');\n    }\n    return fb;\n  }\n\n  private queryVitalParameters(): void {\n    const gl = this.gl;\n\n    this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer();\n    this.isRenderFloat32Supported = this.checkRenderFloat32();\n    this.isFloat32DownloadSupported = this.checkFloat32Download();\n\n    if (this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) {\n      throw new Error('both float32 and float16 TextureType are not supported');\n    }\n\n    this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend();\n\n    // this.maxCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    this.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    // this.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n    // this.shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);\n    // this.webglVendor = gl.getParameter(gl.VENDOR);\n    // this.webglVersion = gl.getParameter(gl.VERSION);\n\n    if (this.version === 2) {\n      // this.max3DTextureSize = gl.getParameter(WebGL2RenderingContext.MAX_3D_TEXTURE_SIZE);\n      // this.maxArrayTextureLayers = gl.getParameter(WebGL2RenderingContext.MAX_ARRAY_TEXTURE_LAYERS);\n      // this.maxColorAttachments = gl.getParameter(WebGL2RenderingContext.MAX_COLOR_ATTACHMENTS);\n      // this.maxDrawBuffers = gl.getParameter(WebGL2RenderingContext.MAX_DRAW_BUFFERS);\n    }\n  }\n  private getExtensions(): void {\n    if (this.version === 2) {\n      this.colorBufferFloatExtension = this.gl.getExtension('EXT_color_buffer_float');\n      this.disjointTimerQueryWebgl2Extension = this.gl.getExtension('EXT_disjoint_timer_query_webgl2');\n    } else {\n      this.textureFloatExtension = this.gl.getExtension('OES_texture_float');\n      this.textureHalfFloatExtension = this.gl.getExtension('OES_texture_half_float');\n    }\n  }\n\n  private checkFloatTextureAttachableToFrameBuffer(): boolean {\n    // test whether Float32 texture is supported:\n    // STEP.1 create a float texture\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const internalFormat = this.version === 2 ? (gl as unknown as { RGBA32F: number }).RGBA32F : gl.RGBA;\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n    // STEP.2 bind a frame buffer\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    // STEP.3 attach texture to framebuffer\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    // STEP.4 test whether framebuffer is complete\n    const isComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isComplete;\n  }\n\n  private checkRenderFloat32(): boolean {\n    if (this.version === 2) {\n      if (!this.colorBufferFloatExtension) {\n        return false;\n      }\n    } else {\n      if (!this.textureFloatExtension) {\n        return false;\n      }\n    }\n    return this.isFloatTextureAttachableToFrameBuffer;\n  }\n\n  private checkFloat32Download(): boolean {\n    if (this.version === 2) {\n      if (!this.colorBufferFloatExtension) {\n        return false;\n      }\n    } else {\n      if (!this.textureFloatExtension) {\n        return false;\n      }\n      if (!this.gl.getExtension('WEBGL_color_buffer_float')) {\n        return false;\n      }\n    }\n    return this.isFloatTextureAttachableToFrameBuffer;\n  }\n\n  /**\n   * Check whether GL_BLEND is supported\n   */\n  private checkFloat32Blend(): boolean {\n    // it looks like currently (2019-05-08) there is no easy way to detect whether BLEND is supported\n    // https://github.com/microsoft/onnxjs/issues/145\n\n    const gl = this.gl;\n\n    let texture: WebGLTexture | null | undefined;\n    let frameBuffer: WebGLFramebuffer | null | undefined;\n    let vertexShader: WebGLShader | null | undefined;\n    let fragmentShader: WebGLShader | null | undefined;\n    let program: WebGLProgram | null | undefined;\n\n    try {\n      texture = gl.createTexture();\n      frameBuffer = gl.createFramebuffer();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      const internalFormat = this.version === 2 ? (gl as unknown as { RGBA32F: number }).RGBA32F : gl.RGBA;\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n      gl.enable(gl.BLEND);\n\n      vertexShader = gl.createShader(gl.VERTEX_SHADER);\n      if (!vertexShader) {\n        return false;\n      }\n      gl.shaderSource(vertexShader, 'void main(){}');\n      gl.compileShader(vertexShader);\n\n      fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n      if (!fragmentShader) {\n        return false;\n      }\n      gl.shaderSource(fragmentShader, 'precision highp float;void main(){gl_FragColor=vec4(0.5);}');\n      gl.compileShader(fragmentShader);\n\n      program = gl.createProgram();\n      if (!program) {\n        return false;\n      }\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      gl.useProgram(program);\n\n      gl.drawArrays(gl.POINTS, 0, 1);\n      return gl.getError() === gl.NO_ERROR;\n    } finally {\n      gl.disable(gl.BLEND);\n\n      if (program) {\n        gl.deleteProgram(program);\n      }\n      if (vertexShader) {\n        gl.deleteShader(vertexShader);\n      }\n      if (fragmentShader) {\n        gl.deleteShader(fragmentShader);\n      }\n      if (frameBuffer) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.deleteFramebuffer(frameBuffer);\n      }\n      if (texture) {\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.deleteTexture(texture);\n      }\n    }\n  }\n\n  beginTimer(): WebGLQuery {\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n\n      const query = gl2.createQuery() as WebGLQuery;\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported.');\n    }\n  }\n\n  endTimer() {\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n  }\n\n  isTimerResultAvailable(query: WebGLQuery): boolean {\n    let available = false,\n      disjoint = false;\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n\n      available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      disjoint = gl2.getParameter(ext.GPU_DISJOINT_EXT);\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n\n    return available && !disjoint;\n  }\n\n  getTimerResult(query: WebGLQuery): number {\n    let timeElapsed = 0;\n    if (this.version === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      timeElapsed = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      gl2.deleteQuery(query);\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n    // return miliseconds\n    return timeElapsed / 1000000;\n  }\n\n  async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await repeatedTry(() => this.isTimerResultAvailable(query));\n    return this.getTimerResult(query);\n  }\n\n  public async createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let isFencePassed: () => boolean;\n    const gl2 = gl as WebGL2RenderingContext;\n    const query = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    if (query === null) {\n      isFencePassed = () => true;\n    } else {\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(query, 0, 0);\n        return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;\n      };\n    }\n    return { query, isFencePassed };\n  }\n\n  async pollFence(fenceContext: FenceContext) {\n    return new Promise<void>((resolve) => {\n      void this.addItemToPoll(\n        () => fenceContext.isFencePassed(),\n        () => resolve(),\n      );\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const { resolveFn } = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private async addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({ isDoneFn, resolveFn });\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    await repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Logger } from '../../instrument';\n\nimport { WebGLContext } from './webgl-context';\n\nconst cache: { [contextId: string]: WebGLContext } = {};\n\n/**\n * This factory function creates proper WebGLRenderingContext based on\n * the current browsers capabilities\n * The order is from higher/most recent versions to most basic\n */\nexport function createWebGLContext(contextId?: 'webgl' | 'webgl2'): WebGLContext {\n  let context: WebGLContext | undefined;\n  if ((!contextId || contextId === 'webgl2') && 'webgl2' in cache) {\n    context = cache.webgl2;\n  } else if ((!contextId || contextId === 'webgl') && 'webgl' in cache) {\n    context = cache.webgl;\n  }\n\n  if (!context) {\n    try {\n      // try to create webgl context from an offscreen canvas\n      const offscreenCanvas = createOffscreenCanvas();\n      context = createNewWebGLContext(offscreenCanvas, contextId);\n    } catch (e) {\n      // if failed, fallback to try to use a normal canvas element\n      const canvas = createCanvas();\n      context = createNewWebGLContext(canvas, contextId);\n    }\n  }\n\n  contextId = contextId || context.version === 1 ? 'webgl' : 'webgl2';\n  const gl = context.gl;\n\n  cache[contextId] = context;\n\n  if (gl.isContextLost()) {\n    delete cache[contextId];\n    return createWebGLContext(contextId);\n  }\n\n  gl.disable(gl.DEPTH_TEST);\n  gl.disable(gl.STENCIL_TEST);\n  gl.disable(gl.BLEND);\n  gl.disable(gl.DITHER);\n  gl.disable(gl.POLYGON_OFFSET_FILL);\n  gl.disable(gl.SAMPLE_COVERAGE);\n  gl.enable(gl.SCISSOR_TEST);\n  gl.enable(gl.CULL_FACE);\n  gl.cullFace(gl.BACK);\n\n  return context;\n}\n\nexport function createNewWebGLContext(canvas: HTMLCanvasElement, contextId?: 'webgl' | 'webgl2'): WebGLContext {\n  const contextAttributes: WebGLContextAttributes = {\n    alpha: false,\n    depth: false,\n    antialias: false,\n    stencil: false,\n    preserveDrawingBuffer: false,\n    premultipliedAlpha: false,\n    failIfMajorPerformanceCaveat: false,\n  };\n  let gl: WebGLRenderingContext | null;\n  const ca = contextAttributes;\n  if (!contextId || contextId === 'webgl2') {\n    gl = canvas.getContext('webgl2', ca);\n    if (gl) {\n      try {\n        return new WebGLContext(gl, 2);\n      } catch (err) {\n        Logger.warning('GlContextFactory', `failed to create WebGLContext using contextId 'webgl2'. Error: ${err}`);\n      }\n    }\n  }\n  if (!contextId || contextId === 'webgl') {\n    gl = canvas.getContext('webgl', ca) || (canvas.getContext('experimental-webgl', ca) as WebGLRenderingContext);\n    if (gl) {\n      try {\n        return new WebGLContext(gl, 1);\n      } catch (err) {\n        Logger.warning(\n          'GlContextFactory',\n          `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${err}`,\n        );\n      }\n    }\n  }\n\n  throw new Error('WebGL is not supported');\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\ndeclare let OffscreenCanvas: { new (width: number, height: number): HTMLCanvasElement };\n\nfunction createCanvas(): HTMLCanvasElement {\n  if (typeof document === 'undefined') {\n    throw new TypeError('failed to create canvas: document is not supported');\n  }\n  const canvas: HTMLCanvasElement = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = 1;\n  return canvas;\n}\n\nfunction createOffscreenCanvas(): HTMLCanvasElement {\n  if (typeof OffscreenCanvas === 'undefined') {\n    throw new TypeError('failed to create offscreen canvas: OffscreenCanvas is not supported');\n  }\n  return new OffscreenCanvas(1, 1);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env } from 'onnxruntime-common';\n\nimport { Backend, SessionHandler } from '../backend';\nimport { Logger } from '../instrument';\nimport { Session } from '../session';\n\nimport { WebGLSessionHandler } from './webgl/session-handler';\nimport { WebGLContext } from './webgl/webgl-context';\nimport { createWebGLContext } from './webgl/webgl-context-factory';\n\n/**\n * WebGLBackend is the entry point for all WebGL opeartions\n * When it starts it created the WebGLRenderingContext\n * and other main framework components such as Program and Texture Managers\n */\nexport class WebGLBackend implements Backend {\n  glContext: WebGLContext;\n\n  get contextId(): 'webgl' | 'webgl2' | undefined {\n    return env.webgl.contextId;\n  }\n  set contextId(value: 'webgl' | 'webgl2' | undefined) {\n    env.webgl.contextId = value;\n  }\n\n  get matmulMaxBatchSize(): number | undefined {\n    return env.webgl.matmulMaxBatchSize;\n  }\n  set matmulMaxBatchSize(value: number | undefined) {\n    env.webgl.matmulMaxBatchSize = value;\n  }\n\n  get textureCacheMode(): 'initializerOnly' | 'full' | undefined {\n    return env.webgl.textureCacheMode;\n  }\n  set textureCacheMode(value: 'initializerOnly' | 'full' | undefined) {\n    env.webgl.textureCacheMode = value;\n  }\n\n  get pack(): boolean | undefined {\n    return env.webgl.pack;\n  }\n  set pack(value: boolean | undefined) {\n    env.webgl.pack = value;\n  }\n\n  get async(): boolean | undefined {\n    return env.webgl.async;\n  }\n  set async(value: boolean | undefined) {\n    env.webgl.async = value;\n  }\n\n  initialize(): boolean {\n    try {\n      this.glContext = createWebGLContext(this.contextId);\n      if (typeof this.matmulMaxBatchSize !== 'number') {\n        this.matmulMaxBatchSize = 16;\n      }\n      if (typeof this.textureCacheMode !== 'string') {\n        this.textureCacheMode = 'full';\n      }\n      if (typeof this.pack !== 'boolean') {\n        this.pack = false;\n      }\n      if (typeof this.async !== 'boolean') {\n        this.async = false;\n      }\n\n      Logger.setWithEnv(env);\n\n      if (!env.webgl.context) {\n        Object.defineProperty(env.webgl, 'context', { value: this.glContext.gl });\n      }\n\n      Logger.verbose(\n        'WebGLBackend',\n        `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${\n          this.matmulMaxBatchSize\n        }; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`,\n      );\n      return true;\n    } catch (e) {\n      Logger.warning('WebGLBackend', `Unable to initialize WebGLBackend. ${e}`);\n      return false;\n    }\n  }\n  createSessionHandler(context: Session.Context): SessionHandler {\n    return new WebGLSessionHandler(this, context);\n  }\n  dispose(): void {\n    this.glContext.dispose();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { WebGLBackend } from './backends/backend-webgl';\nimport { Graph } from './graph';\nimport { Operator } from './operators';\nimport { OpSet } from './opset';\nimport { Session } from './session';\n\nexport interface InferenceHandler {\n  /**\n   * dispose the inference handler. it will be called as the last step in Session.run()\n   */\n  dispose(): void;\n}\n\nexport interface SessionHandler {\n  /**\n   * transform the graph at initialization time\n   * @param graphTransformer the graph transformer to manipulate the model graph\n   */\n  transformGraph?(graphTransformer: Graph.Transformer): void;\n\n  /**\n   * create an instance of InferenceHandler to use in a Session.run() call\n   */\n  createInferenceHandler(): InferenceHandler;\n\n  /**\n   * dispose the session handler. it will be called when a session is being disposed explicitly\n   */\n  dispose(): void;\n\n  /**\n   * Resolves the operator from the name and opset version; backend specific\n   * @param node the node to resolve\n   * @param opsets a list of opsets that exported from the model\n   * @param graph the completely initialized graph\n   */\n  resolve(node: Graph.Node, opsets: readonly OpSet[], graph: Graph): Operator;\n\n  /**\n   * This method let's the sessionHandler know that the graph initialization is complete\n   * @param graph the completely initialized graph\n   */\n  onGraphInitialized?(graph: Graph): void;\n\n  /**\n   * a reference to the corresponding backend\n   */\n  readonly backend: Backend;\n\n  /**\n   * a reference to the session context\n   */\n  readonly context: Session.Context;\n}\n\nexport interface Backend {\n  /**\n   * initialize the backend. will be called only once, when the first time the\n   * backend it to be used\n   */\n  initialize(): boolean | Promise<boolean>;\n\n  /**\n   * create an instance of SessionHandler to use in a Session object's lifecycle\n   */\n  createSessionHandler(context: Session.Context): SessionHandler;\n\n  /**\n   * dispose the backend. currently this will not be called\n   */\n  dispose(): void;\n}\n\n// caches all initialized backend instances\nconst backendsCache: Map<string, Backend> = new Map();\n\nexport const backend: { [name: string]: Backend } = {\n  webgl: new WebGLBackend(),\n};\n\n/**\n * Resolve a reference to the backend. If a hint is specified, the corresponding\n * backend will be used.\n */\nexport async function resolveBackend(hint?: string | readonly string[]): Promise<Backend> {\n  if (!hint) {\n    return resolveBackend(['webgl']);\n  } else {\n    const hints = typeof hint === 'string' ? [hint] : hint;\n\n    for (const backendHint of hints) {\n      const cache = backendsCache.get(backendHint);\n      if (cache) {\n        return cache;\n      }\n\n      const backend = await tryLoadBackend(backendHint);\n      if (backend) {\n        return backend;\n      }\n    }\n  }\n\n  throw new Error('no available backend to use');\n}\n\nasync function tryLoadBackend(backendHint: string): Promise<Backend | undefined> {\n  const backendObj = backend;\n\n  if (typeof backendObj[backendHint] !== 'undefined' && isBackend(backendObj[backendHint])) {\n    const backend = backendObj[backendHint];\n    let init = backend.initialize();\n    if (typeof init === 'object' && 'then' in init) {\n      init = await init;\n    }\n    if (init) {\n      backendsCache.set(backendHint, backend);\n      return backend;\n    }\n  }\n\n  return undefined;\n}\n\nfunction isBackend(obj: unknown) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const o = obj as any;\n\n  // check if an object is a Backend instance\n  if (\n    'initialize' in o &&\n    typeof o.initialize === 'function' && // initialize()\n    'createSessionHandler' in o &&\n    typeof o.createSessionHandler === 'function' && // createSessionHandler()\n    'dispose' in o &&\n    typeof o.dispose === 'function' // dispose()\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nexport type BackendType = Backend;\nexport type SessionHandlerType = ReturnType<BackendType['createSessionHandler']>;\nexport type InferenceHandlerType = ReturnType<SessionHandlerType['createInferenceHandler']>;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { SessionHandler } from './backend';\nimport { Graph } from './graph';\nimport { Logger, Profiler } from './instrument';\nimport { Operator } from './operators';\nimport { Tensor } from './tensor';\n\nclass KernelOp {\n  constructor(\n    public op: Operator,\n    public node: Graph.Node,\n  ) {}\n}\n\nexport class ExecutionPlan {\n  constructor(\n    private graph: Graph,\n    ops: Operator[],\n    private profiler: Readonly<Profiler>,\n  ) {\n    this.initialize(ops);\n  }\n\n  initialize(ops: Operator[]) {\n    this.profiler.event('session', 'ExecutionPlan.initialize', () => {\n      const graphNodes = this.graph.getNodes();\n      if (graphNodes.length !== ops.length) {\n        throw new Error('The size of nodes and OPs do not match.');\n      }\n\n      this._ops = ops.map((op, i) => new KernelOp(op, graphNodes[i]));\n      this.reset();\n\n      // look for starter node(s)\n      this._starter = [];\n      this._ops.forEach((op, i) => {\n        let resolved = true;\n        for (const input of op.node.inputs) {\n          if (\n            !this._values[input] && // not an initialized input\n            this.graph.getInputIndices().indexOf(input) === -1 // not model input\n          ) {\n            resolved = false;\n            break;\n          }\n        }\n        if (resolved) {\n          this._starter.push(i);\n        }\n      });\n    });\n  }\n\n  reset() {\n    this._values = this.graph.getValues().map((i) => i.tensor);\n  }\n\n  async execute(sessionHandler: SessionHandler, modelInputs: Tensor[]): Promise<Tensor[]> {\n    return this.profiler.event('session', 'ExecutionPlan.execute', async () => {\n      // reset mediem result\n      this.reset();\n\n      // create inference handler\n      const inferenceHandler = sessionHandler.createInferenceHandler();\n\n      // populate inputs value\n      const graphInputs = this.graph.getInputIndices();\n      if (modelInputs.length !== graphInputs.length) {\n        throw new Error(\n          `number of input tensors don't match the number of inputs to the model: actual: ${\n            modelInputs.length\n          } expected: ${graphInputs.length}`,\n        );\n      }\n\n      modelInputs.forEach((input, i) => {\n        const index = graphInputs[i];\n        this._values[index] = input;\n      });\n\n      // prepare running sequence\n      const sequence: number[] = this._starter.slice(0);\n\n      // execution iterations\n      const graphValues = this.graph.getValues();\n      const graphNodes = this.graph.getNodes();\n\n      let rear = 0;\n      while (rear < sequence.length) {\n        const thisOpIndex = sequence[rear++];\n        const thisOp = this._ops[thisOpIndex];\n\n        // check input\n        const inputList = thisOp.node.inputs.map((i) => this._values[i]);\n        if (inputList.indexOf(undefined) !== -1) {\n          throw new Error(`unresolved input detected: op: ${thisOp.node}`);\n        }\n\n        // run\n        const inputTensors = inputList as Tensor[];\n        Logger.verbose(\n          'ExecPlan',\n          `Running op:${thisOp.node.name} (${inputTensors\n            .map((t, i) => `'${thisOp.node.inputs[i]}': ${t.type}[${t.dims.join(',')}]`)\n            .join(', ')})`,\n        );\n\n        const outputList = await this.profiler.event('node', thisOp.node.name, async () =>\n          thisOp.op.impl(inferenceHandler, inputTensors, thisOp.op.context),\n        );\n\n        // check output\n        if (outputList.length !== thisOp.node.outputs.length) {\n          throw new Error('the size of output does not match model definition.');\n        }\n\n        // fill value\n        outputList.forEach((output, i) => {\n          const j = thisOp.node.outputs[i];\n          if (this._values[j]) {\n            throw new Error(`output [${j}] already has value: op:${thisOp.node.name}`);\n          }\n          this._values[j] = output;\n        });\n\n        // resolve downstream nodes\n        const downstreamNodes = new Set<number>();\n        outputList.forEach((_output, i) => {\n          const j = thisOp.node.outputs[i];\n          for (const currentDownstreamNodeIndex of graphValues[j].to) {\n            const currentDownstreamNode = graphNodes[currentDownstreamNodeIndex];\n            let resolved = true;\n            for (const k of currentDownstreamNode.inputs) {\n              if (!this._values[k]) {\n                resolved = false;\n                break;\n              }\n            }\n            if (resolved) {\n              downstreamNodes.add(currentDownstreamNodeIndex);\n            }\n          }\n        });\n        sequence.push(...downstreamNodes);\n      }\n\n      const output: Tensor[] = [];\n      for (let i = 0; i < this.graph.getOutputIndices().length; i++) {\n        const outputIndex = this.graph.getOutputIndices()[i];\n        const outputTensor = this._values[outputIndex];\n        if (outputTensor === undefined) {\n          throw new Error(`required output [${outputIndex}] does not have value`);\n        }\n        if (outputIndex === 0) {\n          await outputTensor.getData();\n        } else {\n          // eslint-disable-next-line no-unused-expressions\n          outputTensor.data;\n        }\n        output.push(outputTensor);\n      }\n      Logger.verbose('ExecPlan', 'disposing of inferenceHandler');\n      inferenceHandler.dispose();\n      return output;\n    });\n  }\n\n  _values: Array<Tensor | undefined>;\n  _ops: KernelOp[];\n  _starter: number[];\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport Long from 'long';\n\nimport { onnxruntime } from './ort-schema/flatbuffers/ort-generated';\nimport { onnx } from './ort-schema/protobuf/onnx';\nimport { Tensor } from './tensor';\nimport { decodeUtf8String, LongUtil } from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Attribute {\n  export interface DataTypeMap {\n    float: number;\n    int: number;\n    string: string;\n    tensor: Tensor;\n    floats: number[];\n    ints: number[];\n    strings: string[];\n    tensors: Tensor[];\n  }\n\n  export type DataType = keyof DataTypeMap;\n}\n\ntype ValueTypes = Attribute.DataTypeMap[Attribute.DataType];\n\ntype Value = [ValueTypes, Attribute.DataType];\n\nexport class Attribute {\n  constructor(attributes: onnx.IAttributeProto[] | ortFbs.Attribute[] | null | undefined) {\n    this._attributes = new Map();\n    if (attributes !== null && attributes !== undefined) {\n      for (const attr of attributes) {\n        if (attr instanceof onnx.AttributeProto) {\n          this._attributes.set(attr.name, [Attribute.getValue(attr), Attribute.getType(attr)]);\n        } else if (attr instanceof ortFbs.Attribute) {\n          this._attributes.set(attr.name()!, [Attribute.getValue(attr), Attribute.getType(attr)]);\n        }\n      }\n      if (this._attributes.size < attributes.length) {\n        throw new Error('duplicated attribute names');\n      }\n    }\n  }\n\n  set(key: string, type: Attribute.DataType, value: ValueTypes): void {\n    this._attributes.set(key, [value, type]);\n  }\n  delete(key: string): void {\n    this._attributes.delete(key);\n  }\n  getFloat(key: string, defaultValue?: Attribute.DataTypeMap['float']) {\n    return this.get(key, 'float', defaultValue);\n  }\n\n  getInt(key: string, defaultValue?: Attribute.DataTypeMap['int']) {\n    return this.get(key, 'int', defaultValue);\n  }\n\n  getString(key: string, defaultValue?: Attribute.DataTypeMap['string']) {\n    return this.get(key, 'string', defaultValue);\n  }\n\n  getTensor(key: string, defaultValue?: Attribute.DataTypeMap['tensor']) {\n    return this.get(key, 'tensor', defaultValue);\n  }\n\n  getFloats(key: string, defaultValue?: Attribute.DataTypeMap['floats']) {\n    return this.get(key, 'floats', defaultValue);\n  }\n\n  getInts(key: string, defaultValue?: Attribute.DataTypeMap['ints']) {\n    return this.get(key, 'ints', defaultValue);\n  }\n\n  getStrings(key: string, defaultValue?: Attribute.DataTypeMap['strings']) {\n    return this.get(key, 'strings', defaultValue);\n  }\n\n  getTensors(key: string, defaultValue?: Attribute.DataTypeMap['tensors']) {\n    return this.get(key, 'tensors', defaultValue);\n  }\n\n  private get<V extends Attribute.DataTypeMap[Attribute.DataType]>(\n    key: string,\n    type: Attribute.DataType,\n    defaultValue?: V,\n  ): V {\n    const valueAndType = this._attributes.get(key);\n    if (valueAndType === undefined) {\n      if (defaultValue !== undefined) {\n        return defaultValue;\n      }\n      throw new Error(`required attribute not found: ${key}`);\n    }\n    if (valueAndType[1] !== type) {\n      throw new Error(`type mismatch: expected ${type} but got ${valueAndType[1]}`);\n    }\n    return valueAndType[0] as V;\n  }\n\n  private static getType(attr: onnx.IAttributeProto | ortFbs.Attribute): Attribute.DataType {\n    const type = attr instanceof onnx.AttributeProto ? attr.type : (attr as ortFbs.Attribute).type();\n    switch (type) {\n      case onnx.AttributeProto.AttributeType.FLOAT:\n        return 'float';\n      case onnx.AttributeProto.AttributeType.INT:\n        return 'int';\n      case onnx.AttributeProto.AttributeType.STRING:\n        return 'string';\n      case onnx.AttributeProto.AttributeType.TENSOR:\n        return 'tensor';\n      case onnx.AttributeProto.AttributeType.FLOATS:\n        return 'floats';\n      case onnx.AttributeProto.AttributeType.INTS:\n        return 'ints';\n      case onnx.AttributeProto.AttributeType.STRINGS:\n        return 'strings';\n      case onnx.AttributeProto.AttributeType.TENSORS:\n        return 'tensors';\n      default:\n        throw new Error(`attribute type is not supported yet: ${onnx.AttributeProto.AttributeType[type]}`);\n    }\n  }\n\n  private static getValue(attr: onnx.IAttributeProto | ortFbs.Attribute) {\n    const attrType = attr instanceof onnx.AttributeProto ? attr.type : (attr as ortFbs.Attribute).type();\n    if (attrType === onnx.AttributeProto.AttributeType.GRAPH || attrType === onnx.AttributeProto.AttributeType.GRAPHS) {\n      throw new Error('graph attribute is not supported yet');\n    }\n\n    const value = this.getValueNoCheck(attr);\n\n    // cast LONG to number\n    if (attrType === onnx.AttributeProto.AttributeType.INT && LongUtil.isLong(value)) {\n      return LongUtil.longToNumber(value as Long | flatbuffers.Long);\n    }\n\n    // cast LONG[] to number[]\n    if (attrType === onnx.AttributeProto.AttributeType.INTS) {\n      const arr = value as Array<number | Long | flatbuffers.Long>;\n      const numberValue: number[] = new Array<number>(arr.length);\n\n      for (let i = 0; i < arr.length; i++) {\n        const maybeLong = arr[i];\n        numberValue[i] = LongUtil.longToNumber(maybeLong);\n      }\n\n      return numberValue;\n    }\n\n    // cast onnx.TensorProto to onnxjs.Tensor\n    if (attrType === onnx.AttributeProto.AttributeType.TENSOR) {\n      return attr instanceof onnx.AttributeProto\n        ? Tensor.fromProto(value as onnx.ITensorProto)\n        : Tensor.fromOrtTensor(value as ortFbs.Tensor);\n    }\n\n    // cast onnx.TensorProto[] to onnxjs.Tensor[]\n    if (attrType === onnx.AttributeProto.AttributeType.TENSORS) {\n      if (attr instanceof onnx.AttributeProto) {\n        const tensorProtos = value as onnx.ITensorProto[];\n        return tensorProtos.map((value) => Tensor.fromProto(value));\n      } else if (attr instanceof ortFbs.Attribute) {\n        const tensorProtos = value as ortFbs.Tensor[];\n        return tensorProtos.map((value) => Tensor.fromOrtTensor(value));\n      }\n    }\n\n    // cast Uint8Array to string\n    if (attrType === onnx.AttributeProto.AttributeType.STRING) {\n      // string in onnx attribute is of uint8array type, so we need to convert it to string below. While in ort format,\n      // string attributes are returned as string, so no conversion is needed.\n      if (attr instanceof onnx.AttributeProto) {\n        const utf8String = value as Uint8Array;\n        return decodeUtf8String(utf8String);\n      }\n    }\n\n    // cast Uint8Array[] to string[]\n    if (attrType === onnx.AttributeProto.AttributeType.STRINGS) {\n      // strings in onnx attribute is returned as uint8array[], so we need to convert it to string[] below. While in ort\n      // format strings attributes are returned as string[], so no conversion is needed.\n      if (attr instanceof onnx.AttributeProto) {\n        const utf8Strings = value as Uint8Array[];\n        return utf8Strings.map(decodeUtf8String);\n      }\n    }\n\n    return value as ValueTypes;\n  }\n\n  private static getValueNoCheck(attr: onnx.IAttributeProto | ortFbs.Attribute) {\n    return attr instanceof onnx.AttributeProto\n      ? this.getValueNoCheckFromOnnxFormat(attr)\n      : this.getValueNoCheckFromOrtFormat(attr as ortFbs.Attribute);\n  }\n\n  private static getValueNoCheckFromOnnxFormat(attr: onnx.IAttributeProto) {\n    switch (attr.type!) {\n      case onnx.AttributeProto.AttributeType.FLOAT:\n        return attr.f;\n      case onnx.AttributeProto.AttributeType.INT:\n        return attr.i;\n      case onnx.AttributeProto.AttributeType.STRING:\n        return attr.s;\n      case onnx.AttributeProto.AttributeType.TENSOR:\n        return attr.t;\n      case onnx.AttributeProto.AttributeType.GRAPH:\n        return attr.g;\n      case onnx.AttributeProto.AttributeType.FLOATS:\n        return attr.floats;\n      case onnx.AttributeProto.AttributeType.INTS:\n        return attr.ints;\n      case onnx.AttributeProto.AttributeType.STRINGS:\n        return attr.strings;\n      case onnx.AttributeProto.AttributeType.TENSORS:\n        return attr.tensors;\n      case onnx.AttributeProto.AttributeType.GRAPHS:\n        return attr.graphs;\n      default:\n        throw new Error(`unsupported attribute type: ${onnx.AttributeProto.AttributeType[attr.type!]}`);\n    }\n  }\n\n  private static getValueNoCheckFromOrtFormat(attr: ortFbs.Attribute) {\n    switch (attr.type()) {\n      case ortFbs.AttributeType.FLOAT:\n        return attr.f();\n      case ortFbs.AttributeType.INT:\n        return attr.i();\n      case ortFbs.AttributeType.STRING:\n        return attr.s();\n      case ortFbs.AttributeType.TENSOR:\n        return attr.t();\n      case ortFbs.AttributeType.GRAPH:\n        return attr.g();\n      case ortFbs.AttributeType.FLOATS:\n        return attr.floatsArray();\n      case ortFbs.AttributeType.INTS: {\n        const ints = [];\n        for (let i = 0; i < attr.intsLength(); i++) {\n          ints.push(attr.ints(i)!);\n        }\n        return ints;\n      }\n      case ortFbs.AttributeType.STRINGS: {\n        const strings = [];\n        for (let i = 0; i < attr.stringsLength(); i++) {\n          strings.push(attr.strings(i));\n        }\n        return strings;\n      }\n      case ortFbs.AttributeType.TENSORS: {\n        const tensors = [];\n        for (let i = 0; i < attr.tensorsLength(); i++) {\n          tensors.push(attr.tensors(i)!);\n        }\n        return tensors;\n      }\n      // case ortFbs.AttributeType.GRAPHS:\n      // TODO: Subgraph not supported yet.\n      // const graphs = [];\n      // for (let i = 0; i < attr.graphsLength(); i++) {\n      //   graphs.push(attr.graphs(i)!);\n      // }\n      // return graphs;\n      default:\n        throw new Error(`unsupported attribute type: ${ortFbs.AttributeType[attr.type()]}`);\n    }\n  }\n\n  protected _attributes: Map<string, Value>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Attribute } from './attribute';\nimport { onnxruntime } from './ort-schema/flatbuffers/ort-generated';\nimport { onnx } from './ort-schema/protobuf/onnx';\nimport { Tensor } from './tensor';\nimport { LongUtil, MAX_CLIP, MIN_CLIP, ProtoUtil } from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Graph {\n  export interface Shape {\n    readonly dims: readonly number[];\n  }\n  export interface ValueType {\n    readonly tensorType: Tensor.DataType;\n    readonly shape: Shape;\n  }\n  export interface Value {\n    // the tensor data. empty for non-initialized inputs\n    readonly tensor?: Tensor;\n\n    // index to the Node where the value comes from. -1 for initializer.\n    readonly from: number;\n\n    // indices to the Nodes where the values go to.\n    readonly to: readonly number[];\n\n    // value type specification. empty for non-input values.\n    readonly type?: ValueType;\n  }\n  export interface Node {\n    // name of the node\n    readonly name: string;\n\n    // the operator type\n    readonly opType: string;\n\n    // indices to the Values where the inputs come from.\n    readonly inputs: readonly number[];\n\n    // indices to the Values where the outpus go to.\n    readonly outputs: readonly number[];\n\n    // the attributes that used by the operator\n    readonly attributes: Attribute;\n  }\n\n  /**\n   * a Transformer is an instance that allows all possible transformation operations that applied to a graph\n   */\n  export interface Transformer {\n    removeAllIdentityNodes(): void;\n    removeAllDropoutNodes(): void;\n    fuseConvActivationNodes(): void;\n    // TODO: add generic functions to manipulate the graph\n  }\n\n  // an initializer can use transformer to transform the graph\n  export interface Initializer {\n    transformGraph(transformer: Transformer): void;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport interface Graph {\n  getInputIndices(): readonly number[];\n  getInputNames(): readonly string[];\n  getOutputIndices(): readonly number[];\n  getOutputNames(): readonly string[];\n  getValues(): readonly Graph.Value[];\n  getNodes(): readonly Graph.Node[];\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-redeclare\nexport const Graph = {\n  /**\n   * construct a graph from a graph protobuf type\n   */\n  from: (graphProto: onnx.IGraphProto | ortFbs.Graph, initializer?: Graph.Initializer) =>\n    new GraphImpl(graphProto, initializer),\n};\n\nclass Value implements Graph.Value {\n  constructor(valueInfo?: onnx.IValueInfoProto) {\n    this._from = undefined;\n    this._to = [];\n    this.tensor = undefined;\n    this.type = undefined;\n\n    if (valueInfo) {\n      this.type = ProtoUtil.tensorValueTypeFromProto(valueInfo.type!.tensorType!);\n    }\n  }\n\n  _from?: number; // -1 represent from initializer\n  get from() {\n    return this._from!;\n  }\n  _to: number[];\n  get to() {\n    return this._to;\n  }\n  type?: Graph.ValueType;\n  tensor?: Tensor;\n}\n\nclass Node implements Graph.Node {\n  constructor(_nodeProto: onnx.INodeProto | ortFbs.Node, name?: string) {\n    if (_nodeProto instanceof onnx.NodeProto) {\n      this.name = _nodeProto.name;\n      this.opType = _nodeProto.opType;\n      this.attributes = new Attribute(_nodeProto.attribute);\n    } else if (_nodeProto instanceof ortFbs.Node) {\n      this.name = name ?? _nodeProto.name()!;\n      this.opType = _nodeProto.opType()!;\n      this.attributes = new Attribute(ProtoUtil.tensorAttributesFromORTFormat(_nodeProto));\n    }\n\n    this.inputs = [];\n    this.outputs = [];\n    this.executeNode = true;\n  }\n\n  name: string;\n  opType: string;\n  inputs: number[];\n  outputs: number[];\n  attributes: Attribute;\n  executeNode: boolean;\n}\n\nclass GraphImpl implements Graph, Graph.Transformer {\n  private _allData: Value[];\n\n  private _allInputIndices: number[];\n  private _allInputNames: string[];\n\n  private _allOutputIndices: number[];\n  private _allOutputNames: string[];\n\n  private _nodes: Node[];\n\n  constructor(graph: onnx.IGraphProto | ortFbs.Graph, graphInitializer?: Graph.Initializer) {\n    if (!graph) {\n      throw new TypeError('graph is empty');\n    }\n\n    // build the graph - will throw exceptions if something fatal is detected\n    this.buildGraph(graph);\n\n    // execute any transformation logic for the graph (if applicable)\n    this.transformGraph(graphInitializer);\n\n    // check for cycles and other inconsistencies - will throw exceptions if something fatal is detected\n    this.checkIsAcyclic();\n  }\n\n  getInputIndices(): readonly number[] {\n    return this._allInputIndices;\n  }\n\n  getInputNames(): readonly string[] {\n    return this._allInputNames;\n  }\n\n  getOutputIndices(): readonly number[] {\n    return this._allOutputIndices;\n  }\n\n  getOutputNames(): readonly string[] {\n    return this._allOutputNames;\n  }\n\n  getValues(): readonly Graph.Value[] {\n    return this._allData;\n  }\n\n  getNodes(): readonly Graph.Node[] {\n    return this._nodes;\n  }\n\n  private buildGraph(graph: onnx.IGraphProto | ortFbs.Graph) {\n    // build the graph - will throw exceptions if something fatal is detected\n    if (graph instanceof onnx.GraphProto) {\n      this.buildGraphFromOnnxFormat(graph);\n    } else if (graph instanceof ortFbs.Graph) {\n      this.buildGraphFromOrtFormat(graph);\n    } else {\n      throw new TypeError('Graph type is not supported.');\n    }\n  }\n  private buildGraphFromOnnxFormat(graph: onnx.IGraphProto) {\n    const dataIndices = new Map<string, number>();\n    this._allData = [];\n\n    this._allInputIndices = [];\n    this._allInputNames = [];\n\n    this._allOutputIndices = [];\n    this._allOutputNames = [];\n\n    this._nodes = [];\n\n    const nodesIndices = new Map<string, number>();\n\n    // scan all inputs\n    if (!graph.input) {\n      throw new Error('missing information in graph: input');\n    }\n    const inputValueNames = [];\n    for (const i of graph.input) {\n      if (dataIndices.has(i.name!)) {\n        throw new Error(`duplicated input name: ${i.name}`);\n      }\n      const currentIndex = this._allData.push(new Value(i)) - 1;\n      dataIndices.set(i.name!, currentIndex);\n      inputValueNames.push(i.name!);\n    }\n\n    // scan all initializers\n    if (!graph.initializer) {\n      throw new Error('missing information in graph: initializer');\n    }\n    for (const i of graph.initializer) {\n      let index = dataIndices.get(i.name!);\n      if (index === undefined) {\n        const value = new Value();\n        value.type = {\n          shape: { dims: ProtoUtil.tensorDimsFromProto(i.dims!) },\n          tensorType: ProtoUtil.tensorDataTypeFromProto(i.dataType!),\n        };\n        index = this._allData.push(value) - 1;\n        dataIndices.set(i.name!, index);\n      }\n      this._allData[index]._from = -1;\n      this._allData[index].tensor = Tensor.fromProto(i);\n    }\n\n    // filter out input indices\n    for (let i = 0; i < this._allData.length; i++) {\n      if (!this._allData[i].tensor) {\n        this._allInputIndices.push(i);\n        this._allInputNames.push(inputValueNames[i]);\n      }\n    }\n\n    // scan all outputs\n    if (!graph.output) {\n      throw new Error('missing information in graph: output');\n    }\n    for (const i of graph.output) {\n      if (dataIndices.has(i.name!)) {\n        throw new Error(`duplicated output name: ${i.name}`);\n      }\n      const currentIndex = this._allData.push(new Value(i)) - 1;\n      dataIndices.set(i.name!, currentIndex);\n      this._allOutputIndices.push(currentIndex);\n      this._allOutputNames.push(i.name!);\n    }\n\n    // scan all nodes\n    if (!graph.node) {\n      throw new Error('missing information in graph: node');\n    }\n    for (const nodeProto of graph.node) {\n      if (!nodeProto.name) {\n        // assign a name to the node if it doesn't have one\n        for (let pick = 0; ; pick++) {\n          const name = `unnamed_${nodeProto.opType}_${pick}`;\n          if (!nodesIndices.has(name)) {\n            nodeProto.name = name;\n            break;\n          }\n        }\n      }\n\n      if (nodesIndices.has(nodeProto.name)) {\n        throw new Error(`duplicated node name: ${nodeProto.name}`);\n      }\n      const currentIndex = this._nodes.push(new Node(nodeProto)) - 1;\n      nodesIndices.set(nodeProto.name, currentIndex);\n    }\n\n    // scan node's outputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.node[i];\n      if (!nodeProto.output) {\n        throw new Error(`missing output for node: ${nodeProto.name}`);\n      }\n      for (const output of nodeProto.output) {\n        let dataIndex = dataIndices.get(output);\n        if (typeof dataIndex === 'undefined') {\n          dataIndex = this._allData.push(new Value()) - 1;\n          dataIndices.set(output, dataIndex);\n        }\n        node.outputs.push(dataIndex);\n\n        if (this._allData[dataIndex]._from !== undefined) {\n          throw new Error(`multiple nodes output to one data value: ${dataIndex}`);\n        }\n        this._allData[dataIndex]._from = i;\n\n        // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the\n        // operator and ignore the node from the graph\n        if (nodeProto.opType === 'Constant') {\n          if (!nodeProto.attribute || nodeProto.attribute.length !== 1 || !nodeProto.attribute[0].t) {\n            throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');\n          }\n          if (!nodeProto.output || nodeProto.output.length !== 1) {\n            throw new Error('missing output or incorrect number of outputs for this Constant operator');\n          }\n          node.outputs.pop();\n          node.executeNode = false;\n\n          this._allData[dataIndex]._from = -1;\n          this._allData[dataIndex].tensor = Tensor.fromProto(nodeProto.attribute[0].t);\n        }\n      }\n    }\n\n    // scan node's inputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.node[i];\n\n      if (!nodeProto.input) {\n        throw new Error(`missing input for node: ${nodeProto.name}`);\n      }\n      for (const input of nodeProto.input) {\n        const dataIndex = dataIndices.get(input);\n        if (typeof dataIndex === 'undefined') {\n          // handle exception when opset > 9 and roi / scales not given\n          if (\n            input === '' &&\n            (nodeProto.input.length === 3 || nodeProto.input.length === 4) &&\n            nodeProto.opType === 'Resize'\n          ) {\n            continue;\n          }\n          throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name}`);\n        }\n        node.inputs.push(dataIndex);\n\n        this._allData[dataIndex]._to.push(i);\n      }\n    }\n\n    return true;\n  }\n\n  private buildGraphFromOrtFormat(graph: ortFbs.Graph) {\n    const dataIndices = new Map<string, number>();\n    this._allData = [];\n\n    this._allInputIndices = [];\n    this._allInputNames = [];\n\n    this._allOutputIndices = [];\n    this._allOutputNames = [];\n\n    this._nodes = [];\n\n    const nodesIndices = new Map<string, number>();\n\n    // scan all inputs\n    const inputValueNames = [];\n    for (let i = 0; i < graph.inputsLength(); i++) {\n      const inputName = graph.inputs(i);\n      if (dataIndices.has(inputName)) {\n        throw new Error(`duplicated input name: ${inputName}`);\n      }\n      // Find the input typeInfo from nodeargs\n      for (let j = 0; j < graph.nodeArgsLength(); j++) {\n        if (graph.nodeArgs(j)?.name() === inputName) {\n          const value = new Value();\n          const valueType = graph.nodeArgs(j)?.type()?.valueType();\n          if (valueType !== ortFbs.TypeInfoValue.tensor_type) {\n            throw new Error('Unexpected value type for the nodeArg.');\n          }\n          const valueInfo = graph.nodeArgs(j)!.type()!.value(new ortFbs.TensorTypeAndShape())!;\n          const type = ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType());\n          const shape = valueInfo.shape()!;\n          const dims = [];\n          for (let k = 0; k < shape.dimLength()!; k++) {\n            dims.push(LongUtil.longToNumber(shape.dim(k)!.value()!.dimValue()!));\n          }\n          value.type = { shape: { dims }, tensorType: type };\n          const currentIndex = this._allData.push(value) - 1;\n          dataIndices.set(inputName, currentIndex);\n          inputValueNames.push(inputName);\n        }\n      }\n    }\n    // check initializers\n    for (let i = 0; i < graph.initializersLength(); i++) {\n      const initializer = graph.initializers(i)!;\n      let index = dataIndices.get(initializer.name()!);\n      if (index === undefined) {\n        const value = new Value();\n        const dims = ProtoUtil.tensorDimsFromORTFormat(initializer);\n        const type = ProtoUtil.tensorDataTypeFromProto(initializer.dataType());\n        value.type = { shape: { dims }, tensorType: type };\n        index = this._allData.push(value) - 1;\n        dataIndices.set(initializer.name()!, index);\n      }\n      this._allData[index]._from = -1;\n      this._allData[index].tensor = Tensor.fromOrtTensor(initializer);\n    }\n\n    // filter out input indices\n    for (let i = 0; i < this._allData.length; i++) {\n      if (!this._allData[i].tensor) {\n        this._allInputIndices.push(i);\n        this._allInputNames.push(inputValueNames[i]);\n      }\n    }\n\n    // scan all outputs\n    for (let i = 0; i < graph.outputsLength(); i++) {\n      const outputName = graph.outputs(i);\n      if (dataIndices.has(outputName)) {\n        throw new Error(`duplicated output name: ${outputName}`);\n      }\n      const currentIndex = this._allData.push(new Value()) - 1;\n      dataIndices.set(outputName, currentIndex);\n      this._allOutputIndices.push(currentIndex);\n      this._allOutputNames.push(outputName);\n    }\n\n    // scan all nodes\n    if (!graph.nodes) {\n      throw new Error('missing information in graph: node');\n    }\n    for (let i = 0; i < graph.nodesLength(); i++) {\n      const nodeProto = graph.nodes(i);\n      let name = nodeProto!.name();\n      if (!name) {\n        // assign a name to the node if it doesn't have one\n        for (let pick = 0; ; pick++) {\n          name = `unnamed_${nodeProto!.opType()}_${pick}`;\n          if (!nodesIndices.has(name)) {\n            // an unique name is found. break.\n            break;\n          }\n        }\n      }\n\n      if (nodesIndices.has(name)) {\n        throw new Error(`duplicated node name: ${name}`);\n      }\n      const currentIndex = this._nodes.push(new Node(nodeProto!, name)) - 1;\n      nodesIndices.set(name, currentIndex);\n    }\n\n    // scan node's outputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.nodes(i);\n      if (nodeProto == null) {\n        throw new Error(`No node exists at index ${i}`);\n      }\n      if (nodeProto?.outputsLength() === 0) {\n        throw new Error(`missing output for node: ${nodeProto.name}`);\n      }\n      for (let j = 0; j < nodeProto?.outputsLength(); j++) {\n        const output = nodeProto?.outputs(j);\n        let dataIndex = dataIndices.get(output);\n        if (typeof dataIndex === 'undefined') {\n          dataIndex = this._allData.push(new Value()) - 1;\n          dataIndices.set(output, dataIndex);\n        }\n        node.outputs.push(dataIndex);\n\n        if (this._allData[dataIndex]._from !== undefined) {\n          throw new Error(`multiple nodes output to one data value: ${dataIndex}`);\n        }\n        this._allData[dataIndex]._from = i;\n\n        // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the\n        // operator and ignore the node from the graph\n        if (nodeProto.opType() === 'Constant') {\n          if (nodeProto.attributesLength() !== 1 || !nodeProto.attributes(0)!.t()) {\n            throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');\n          }\n          if (nodeProto.outputsLength() !== 1) {\n            throw new Error('missing output or incorrect number of outputs for this Constant operator');\n          }\n          node.outputs.pop();\n          node.executeNode = false;\n\n          this._allData[dataIndex]._from = -1;\n          this._allData[dataIndex].tensor = Tensor.fromOrtTensor(nodeProto.attributes(0)!.t()!);\n        }\n      }\n    }\n\n    // scan node's inputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.nodes(i)!;\n\n      if (nodeProto.inputsLength() === 0) {\n        throw new Error(`missing input for node: ${nodeProto.name}`);\n      }\n      for (let j = 0; j < nodeProto.inputsLength()!; j++) {\n        const input = nodeProto.inputs(j)!;\n        const dataIndex = dataIndices.get(input);\n        if (typeof dataIndex === 'undefined') {\n          throw new Error(`unrecognized input '${input}' for node: ${nodeProto!.name()}`);\n        }\n        node.inputs.push(dataIndex);\n\n        this._allData[dataIndex]._to.push(i);\n      }\n    }\n  }\n\n  private checkIsAcyclic() {\n    // go through the graph and check for cycles or other fatal inconsistencies\n    const starters: Set<number> = new Set<number>();\n    this._allInputIndices.forEach((i) => {\n      const data = this._allData[i];\n      data._to.forEach((j) => {\n        starters.add(j);\n      });\n    });\n\n    // Iterative DFS to check for cycles\n    const nodesStack = Array.from(starters);\n    const nodesState = new Array<string>(this._nodes.length).fill('white');\n\n    while (nodesStack.length > 0) {\n      const nodeIndex = nodesStack.pop()!;\n      // this node has now been processed completely. Mark this node 'black' to denote this.\n      if (nodesState[nodeIndex] === 'gray') {\n        nodesState[nodeIndex] = 'black';\n      } else {\n        // this node is under processing stage. mark this node 'gray' to denote this.\n        nodesStack.push(nodeIndex);\n        nodesState[nodeIndex] = 'gray';\n\n        this._nodes[nodeIndex].outputs.forEach((outgoingEdgeIndex) => {\n          const data = this._allData[outgoingEdgeIndex];\n          if (typeof data.tensor !== 'undefined') {\n            throw new Error('node outputs should not be initialized');\n          }\n          if (data._from !== nodeIndex) {\n            throw new Error(\"from property of the Value object doesn't match index of Node being processed\");\n          }\n          data._to.forEach((downstreamNodeIndex) => {\n            // back edge found - cyclic\n            if (nodesState[downstreamNodeIndex] === 'gray') {\n              throw new Error('model graph is cyclic');\n            }\n            // tree edge found - continue processing by adding it to stack\n            else if (nodesState[downstreamNodeIndex] === 'white') {\n              nodesStack.push(downstreamNodeIndex);\n            }\n          });\n        });\n      }\n    }\n  }\n\n  private transformGraph(graphInitializer?: Graph.Initializer): void {\n    // apply common transform\n    this.removeAllIdentityNodes();\n    this.removeAllDropoutNodes();\n    this.fuseConvActivationNodes();\n    // apply initializer specific transform\n    if (graphInitializer) {\n      graphInitializer.transformGraph(this);\n    }\n\n    // finalize graph\n    this.finalizeGraph();\n  }\n\n  /**\n   * finalize the graph.\n   *\n   * this function should be called after all the transformation completed.\n   * this function removes all unnecessary nodes and values from the graph\n   */\n  finalizeGraph() {\n    let offset = 0;\n    // delete all nodes that are not being executed\n    // The graph is represented using these two arrays\n    // this._nodes - Array holding the kernels to execute - each entry is a kernel pointing to this._allData\n    // this._allData - hold 2 fields - to [] & from - these feileds hold the graph map for inputs and outputs per node\n    // newIndices - remapping the graph after reading the flag 'executeNode'\n    const newIndices = new Array<number>(this._nodes.length, 0);\n    let nodePossition = 0;\n\n    for (let i = 0; i < this._nodes.length; i++) {\n      // giving new indexes to the nodes based on execution flag\n      newIndices[i] = nodePossition;\n      if (this._nodes[i].executeNode) {\n        if (nodePossition !== i) {\n          this._nodes[nodePossition] = this._nodes[i];\n        }\n        nodePossition++;\n      } else {\n        // delete all output values\n        this._nodes[i].outputs.forEach((ind) => {\n          this._allData[ind]._from = -2;\n        });\n      }\n    }\n\n    // removing the unused nodes\n    this._nodes.splice(nodePossition, this._nodes.length - nodePossition);\n\n    // Updating this._allData according to the new this._nodes\n    for (let i = 0; i < this._allData.length; i++) {\n      const currentData = this._allData[i];\n      if (currentData._from !== undefined && currentData._from !== -1 && currentData._from !== -2) {\n        currentData._from = newIndices[currentData._from];\n      }\n\n      for (let j = 0; j < currentData._to.length; j++) {\n        if (currentData._to[j] >= 0) {\n          currentData._to[j] = newIndices[currentData._to[j]];\n        } else {\n          throw new Error('Trying to update a removed node');\n        }\n      }\n    }\n\n    offset = 0;\n    // delete all values that are not being referenced\n    for (let i = 0; i < this._allData.length; i++) {\n      // if current value is neither linked to next node, nor an output value, remove it.\n      if (this._allData[i].from === -2 && this._allOutputIndices.indexOf(i + offset) === -1) {\n        offset++;\n        this._allData.splice(i, 1);\n        i--;\n        continue;\n      }\n      if (offset > 0) {\n        let ind = -1;\n        // if current value is neither an input value nor an initializer, find the node it's\n        // coming from and update the corresponding node output\n        if (this._allData[i].from !== undefined && this._allData[i].from !== -1) {\n          ind = this._nodes[this._allData[i].from].outputs.indexOf(i + offset);\n          if (ind !== -1) {\n            this._nodes[this._allData[i].from].outputs[ind] = i;\n          }\n        } else {\n          // if current value is an input value, update its reference in inputIndices\n          ind = this._allInputIndices.indexOf(i + offset);\n          if (ind !== -1) {\n            this._allInputIndices[ind] = i;\n          }\n        }\n\n        // find the node that the current value is linking to and update its input reference\n        this._allData[i].to.forEach((node) => {\n          ind = this._nodes[node].inputs.indexOf(i + offset);\n          if (ind !== -1) {\n            this._nodes[node].inputs[ind] = i;\n          }\n        });\n        if (this._allData[i].to.length === 0) {\n          // if current value is a graph output, update its reference in outputIndices\n          ind = this._allOutputIndices.indexOf(i + offset);\n          if (ind !== -1) {\n            this._allOutputIndices[ind] = i;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Delete the specified node. Assume the node has one incoming input and the first output connected to other nodes.\n   * An input validation must be done before calling this function.\n   * @param nodeIndex The index of node to be deleted\n   */\n  private deleteNode(nodeIndex: number) {\n    const node = this._nodes[nodeIndex];\n    if (node.outputs.length > 1) {\n      for (let i = 1; i < node.outputs.length; i++) {\n        if (this._allData[node.outputs[i]].to.length > 0) {\n          throw new Error('Node deletion with more than one output connected to other nodes is not supported. ');\n        }\n      }\n    }\n\n    // this node wil not be executed\n    node.executeNode = false;\n    const inputValueIndex = node.inputs[0];\n    const outputValueIndex = node.outputs[0];\n    const nodesConsumingOutput = this._allData[outputValueIndex].to;\n\n    // remove this node from the to property of the input Value\n    for (let i = 0; i < node.inputs.length; i++) {\n      const delIndex = this._allData[node.inputs[i]].to.indexOf(nodeIndex);\n      // should not happen\n      if (delIndex === -1) {\n        throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");\n      }\n      this._allData[node.inputs[i]].to.splice(delIndex, 1);\n    }\n\n    // clear node indices consuming this output Value\n    this._allData[outputValueIndex]._to = [];\n\n    // if the output of this node is a graph output, adjust the index appropriately\n    const index = this._allOutputIndices.indexOf(outputValueIndex);\n    if (index !== -1) {\n      this._allOutputIndices[index] = inputValueIndex;\n    }\n\n    // override the inputs for nodes consuming this node's output with the input to this node\n    if (nodesConsumingOutput && nodesConsumingOutput.length > 0) {\n      for (const nodeIndex of nodesConsumingOutput) {\n        const replaceIndex = this._nodes[nodeIndex].inputs.indexOf(outputValueIndex);\n        // should not happen\n        if (replaceIndex === -1) {\n          throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");\n        }\n        this._nodes[nodeIndex].inputs[replaceIndex] = inputValueIndex;\n        this._allData[inputValueIndex].to.push(nodeIndex);\n      }\n    }\n  }\n\n  removeAllDropoutNodes() {\n    let nodeIndex = 0;\n    for (const node of this._nodes) {\n      // weed out 'Dropout' nodes so that no time is wasted in execution\n      if (node.opType === 'Dropout') {\n        // the node should have exactly 1 input and 1 or 2 outputs\n        if (node.inputs.length !== 1) {\n          throw new Error('Dropout nodes should only contain one input. ');\n        }\n        if (node.outputs.length !== 1 && node.outputs.length !== 2) {\n          throw new Error('Dropout nodes should contain either 1 or 2 output(s)');\n        }\n        // the second output should not be referenced by any other node\n        if (node.outputs.length === 2 && this._allData[node.outputs[1]]._to.length !== 0) {\n          throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");\n        }\n        this.deleteNode(nodeIndex);\n      }\n      nodeIndex++;\n    }\n  }\n\n  removeAllIdentityNodes() {\n    let nodeIndex = 0;\n    for (const node of this._nodes) {\n      // weed out 'Identity' nodes so that no time is wasted in execution\n      if (node.opType === 'Identity') {\n        this.deleteNode(nodeIndex);\n      }\n      nodeIndex++;\n    }\n  }\n\n  isActivation(n: Node): boolean {\n    switch (n.opType) {\n      // TODO: add other activation methods\n      case 'Relu':\n      case 'Sigmoid':\n      case 'Clip':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  fuseConvActivationNodes() {\n    for (const node of this._nodes) {\n      if (node.opType === 'Conv') {\n        const next = this._allData[node.outputs[0]]._to;\n        if (next.length === 1 && this.isActivation(this._nodes[next[0]])) {\n          const child = this._nodes[next[0]];\n          if (child.opType === 'Clip') {\n            if (child.inputs.length === 1) {\n              try {\n                node.attributes.set('activation_params', 'floats', [\n                  child.attributes.getFloat('min'),\n                  child.attributes.getFloat('max'),\n                ]);\n              } catch (e) {\n                node.attributes.set('activation_params', 'floats', [MIN_CLIP, MAX_CLIP]);\n              }\n            } else if (\n              child.inputs.length >= 3 &&\n              this._allData[child.inputs[1]].tensor !== undefined &&\n              this._allData[child.inputs[2]].tensor !== undefined\n            ) {\n              node.attributes.set('activation_params', 'floats', [\n                this._allData[child.inputs[1]].tensor!.floatData[0],\n                this._allData[child.inputs[2]].tensor!.floatData[0],\n              ]);\n            } else {\n              // Skip fusion with clip node since clip min and clip max are not coming from initializer\n              continue;\n            }\n          }\n          node.attributes.set('activation', 'string', child.opType);\n          this.deleteNode(next[0]);\n        }\n      }\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { flatbuffers } from 'flatbuffers';\n\nimport { Graph } from './graph';\nimport { OpSet } from './opset';\nimport { onnxruntime } from './ort-schema/flatbuffers/ort-generated';\nimport { onnx } from './ort-schema/protobuf/onnx';\nimport { LongUtil } from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport class Model {\n  // empty model\n  constructor() {}\n\n  load(buf: Uint8Array, graphInitializer?: Graph.Initializer, isOrtFormat?: boolean): void {\n    let onnxError: Error | undefined;\n    if (!isOrtFormat) {\n      // isOrtFormat === false || isOrtFormat === undefined\n      try {\n        this.loadFromOnnxFormat(buf, graphInitializer);\n        return;\n      } catch (e) {\n        if (isOrtFormat !== undefined) {\n          throw e;\n        }\n        onnxError = e;\n      }\n    }\n\n    try {\n      this.loadFromOrtFormat(buf, graphInitializer);\n    } catch (e) {\n      if (isOrtFormat !== undefined) {\n        throw e;\n      }\n      // Tried both formats and failed (when isOrtFormat === undefined)\n      throw new Error(`Failed to load model as ONNX format: ${onnxError}\\nas ORT format: ${e}`);\n    }\n  }\n\n  private loadFromOnnxFormat(buf: Uint8Array, graphInitializer?: Graph.Initializer): void {\n    const modelProto = onnx.ModelProto.decode(buf);\n    const irVersion = LongUtil.longToNumber(modelProto.irVersion);\n    if (irVersion < 3) {\n      throw new Error('only support ONNX model with IR_VERSION>=3');\n    }\n\n    this._opsets = modelProto.opsetImport.map((i) => ({\n      domain: i.domain as string,\n      version: LongUtil.longToNumber(i.version!),\n    }));\n\n    this._graph = Graph.from(modelProto.graph!, graphInitializer);\n  }\n\n  private loadFromOrtFormat(buf: Uint8Array, graphInitializer?: Graph.Initializer): void {\n    const fb = new flatbuffers.ByteBuffer(buf);\n    const ortModel = ortFbs.InferenceSession.getRootAsInferenceSession(fb).model()!;\n    const irVersion = LongUtil.longToNumber(ortModel.irVersion());\n    if (irVersion < 3) {\n      throw new Error('only support ONNX model with IR_VERSION>=3');\n    }\n    this._opsets = [];\n    for (let i = 0; i < ortModel.opsetImportLength(); i++) {\n      const opsetId = ortModel.opsetImport(i)!;\n      this._opsets.push({ domain: opsetId?.domain() as string, version: LongUtil.longToNumber(opsetId.version()!) });\n    }\n\n    this._graph = Graph.from(ortModel.graph()!, graphInitializer);\n  }\n\n  private _graph: Graph;\n  get graph(): Graph {\n    return this._graph;\n  }\n\n  private _opsets: OpSet[];\n  get opsets(): readonly OpSet[] {\n    return this._opsets;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { resolveBackend, SessionHandlerType } from './backend';\nimport { ExecutionPlan } from './execution-plan';\nimport { Graph } from './graph';\nimport { Profiler } from './instrument';\nimport { Model } from './model';\nimport { Operator } from './operators';\nimport { Tensor } from './tensor';\n\nexport declare namespace Session {\n  export interface Config {\n    backendHint?: string;\n    profiler?: Profiler.Config;\n  }\n\n  export interface Context {\n    profiler: Readonly<Profiler>;\n    graphInputTypes?: Tensor.DataType[];\n    graphInputDims?: Array<readonly number[]>;\n  }\n}\n\nexport class Session {\n  constructor(config: Session.Config = {}) {\n    this._initialized = false;\n    this.backendHint = config.backendHint;\n    this.profiler = Profiler.create(config.profiler);\n    this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };\n  }\n\n  get inputNames(): readonly string[] {\n    return this._model.graph.getInputNames();\n  }\n  get outputNames(): readonly string[] {\n    return this._model.graph.getOutputNames();\n  }\n\n  startProfiling() {\n    this.profiler.start();\n  }\n\n  endProfiling() {\n    this.profiler.stop();\n  }\n\n  async loadModel(uri: string): Promise<void>;\n  async loadModel(buffer: ArrayBuffer, byteOffset?: number, length?: number): Promise<void>;\n  async loadModel(buffer: Uint8Array): Promise<void>;\n  async loadModel(arg: string | ArrayBuffer | Uint8Array, byteOffset?: number, length?: number): Promise<void> {\n    await this.profiler.event('session', 'Session.loadModel', async () => {\n      // resolve backend and session handler\n      const backend = await resolveBackend(this.backendHint);\n      this.sessionHandler = backend.createSessionHandler(this.context);\n\n      this._model = new Model();\n      if (typeof arg === 'string') {\n        const isOrtFormat = arg.endsWith('.ort');\n        if (typeof process !== 'undefined' && process.versions && process.versions.node) {\n          // node\n          const { readFile } = require('node:fs/promises');\n          const buf = await readFile(arg);\n          this.initialize(buf, isOrtFormat);\n        } else {\n          // browser\n          const response = await fetch(arg);\n          const buf = await response.arrayBuffer();\n          this.initialize(new Uint8Array(buf), isOrtFormat);\n        }\n      } else if (!ArrayBuffer.isView(arg)) {\n        // load model from ArrayBuffer\n        const arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);\n        this.initialize(arr);\n      } else {\n        // load model from Uint8array\n        this.initialize(arg);\n      }\n    });\n  }\n\n  private initialize(modelProtoBlob: Uint8Array, isOrtFormat?: boolean): void {\n    if (this._initialized) {\n      throw new Error('already initialized');\n    }\n\n    this.profiler.event('session', 'Session.initialize', () => {\n      // load graph\n      const graphInitializer = this.sessionHandler.transformGraph\n        ? (this.sessionHandler as Graph.Initializer)\n        : undefined;\n      this._model.load(modelProtoBlob, graphInitializer, isOrtFormat);\n\n      // graph is completely initialzied at this stage , let the interested handlers know\n      if (this.sessionHandler.onGraphInitialized) {\n        this.sessionHandler.onGraphInitialized(this._model.graph);\n      }\n      // initialize each operator in the graph\n      this.initializeOps(this._model.graph);\n\n      // instantiate an ExecutionPlan object to be used by the Session object\n      this._executionPlan = new ExecutionPlan(this._model.graph, this._ops, this.profiler);\n    });\n\n    this._initialized = true;\n  }\n\n  async run(inputs: Map<string, Tensor> | Tensor[]): Promise<Map<string, Tensor>> {\n    if (!this._initialized) {\n      throw new Error('session not initialized yet');\n    }\n\n    return this.profiler.event('session', 'Session.run', async () => {\n      const inputTensors = this.normalizeAndValidateInputs(inputs);\n\n      const outputTensors = await this._executionPlan.execute(this.sessionHandler, inputTensors);\n\n      return this.createOutput(outputTensors);\n    });\n  }\n\n  private normalizeAndValidateInputs(inputs: Map<string, Tensor> | Tensor[]): Tensor[] {\n    const modelInputNames = this._model.graph.getInputNames();\n\n    // normalize inputs\n    // inputs: Tensor[]\n    if (Array.isArray(inputs)) {\n      if (inputs.length !== modelInputNames.length) {\n        throw new Error(`incorrect input array length: expected ${modelInputNames.length} but got ${inputs.length}`);\n      }\n    }\n    // convert map to array\n    // inputs: Map<string, Tensor>\n    else {\n      if (inputs.size !== modelInputNames.length) {\n        throw new Error(`incorrect input map size: expected ${modelInputNames.length} but got ${inputs.size}`);\n      }\n\n      const sortedInputs = new Array<Tensor>(inputs.size);\n      let sortedInputsIndex = 0;\n      for (let i = 0; i < modelInputNames.length; ++i) {\n        const tensor = inputs.get(modelInputNames[i]);\n        if (!tensor) {\n          throw new Error(`missing input tensor for: '${name}'`);\n        }\n        sortedInputs[sortedInputsIndex++] = tensor;\n      }\n\n      inputs = sortedInputs;\n    }\n\n    // validate dims requirements\n    // First session run - graph input data is not cached for the session\n    if (\n      !this.context.graphInputTypes ||\n      this.context.graphInputTypes.length === 0 ||\n      !this.context.graphInputDims ||\n      this.context.graphInputDims.length === 0\n    ) {\n      const modelInputIndices = this._model.graph.getInputIndices();\n      const modelValues = this._model.graph.getValues();\n\n      const graphInputDims = new Array<readonly number[]>(modelInputIndices.length);\n\n      for (let i = 0; i < modelInputIndices.length; ++i) {\n        const graphInput = modelValues[modelInputIndices[i]];\n        graphInputDims[i] = graphInput.type!.shape.dims;\n\n        // cached for second and subsequent runs.\n        // Some parts of the framework works on the assumption that the graph and types and shapes are static\n        this.context.graphInputTypes!.push(graphInput.type!.tensorType);\n        this.context.graphInputDims!.push(inputs[i].dims);\n      }\n\n      this.validateInputTensorDims(graphInputDims, inputs, true);\n    }\n\n    // Second and subsequent session runs - graph input data is cached for the session\n    else {\n      this.validateInputTensorDims(this.context.graphInputDims, inputs, false);\n    }\n\n    // validate types requirement\n    this.validateInputTensorTypes(this.context.graphInputTypes!, inputs);\n\n    return inputs;\n  }\n\n  private validateInputTensorTypes(graphInputTypes: Tensor.DataType[], givenInputs: Tensor[]) {\n    for (let i = 0; i < givenInputs.length; i++) {\n      const expectedType = graphInputTypes[i];\n      const actualType = givenInputs[i].type;\n      if (expectedType !== actualType) {\n        throw new Error(`input tensor[${i}] check failed: expected type '${expectedType}' but got ${actualType}`);\n      }\n    }\n  }\n\n  private validateInputTensorDims(\n    graphInputDims: Array<readonly number[]>,\n    givenInputs: Tensor[],\n    noneDimSupported: boolean,\n  ) {\n    for (let i = 0; i < givenInputs.length; i++) {\n      const expectedDims = graphInputDims[i];\n      const actualDims = givenInputs[i].dims;\n      if (!this.compareTensorDims(expectedDims, actualDims, noneDimSupported)) {\n        throw new Error(\n          `input tensor[${i}] check failed: expected shape '[${expectedDims.join(',')}]' but got [${actualDims.join(\n            ',',\n          )}]`,\n        );\n      }\n    }\n  }\n\n  private compareTensorDims(\n    expectedDims: readonly number[],\n    actualDims: readonly number[],\n    noneDimSupported: boolean,\n  ): boolean {\n    if (expectedDims.length !== actualDims.length) {\n      return false;\n    }\n\n    for (let i = 0; i < expectedDims.length; ++i) {\n      if (expectedDims[i] !== actualDims[i] && (!noneDimSupported || expectedDims[i] !== 0)) {\n        // data shape mis-match AND not a 'None' dimension.\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private createOutput(outputTensors: Tensor[]): Map<string, Tensor> {\n    const modelOutputNames = this._model.graph.getOutputNames();\n    if (outputTensors.length !== modelOutputNames.length) {\n      throw new Error('expected number of outputs do not match number of generated outputs');\n    }\n\n    const output = new Map<string, Tensor>();\n    for (let i = 0; i < modelOutputNames.length; ++i) {\n      output.set(modelOutputNames[i], outputTensors[i]);\n    }\n\n    return output;\n  }\n\n  private initializeOps(graph: Graph): void {\n    const nodes = graph.getNodes();\n    this._ops = new Array(nodes.length);\n\n    for (let i = 0; i < nodes.length; i++) {\n      this._ops[i] = this.sessionHandler.resolve(nodes[i], this._model.opsets, graph);\n    }\n  }\n\n  private _model: Model;\n  private _initialized: boolean;\n\n  private _ops: Operator[];\n  private _executionPlan: ExecutionPlan;\n\n  private backendHint?: string;\n\n  private sessionHandler: SessionHandlerType;\n  private context: Session.Context;\n  private profiler: Readonly<Profiler>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession, InferenceSessionHandler, SessionHandler, Tensor } from 'onnxruntime-common';\n\nimport { Session } from './session';\nimport { Tensor as OnnxjsTensor } from './tensor';\n\nexport class OnnxjsSessionHandler implements InferenceSessionHandler {\n  constructor(private session: Session) {\n    this.inputNames = this.session.inputNames;\n    this.outputNames = this.session.outputNames;\n  }\n\n  async dispose(): Promise<void> {}\n  inputNames: readonly string[];\n  outputNames: readonly string[];\n  async run(\n    feeds: SessionHandler.FeedsType,\n    _fetches: SessionHandler.FetchesType,\n    _options: InferenceSession.RunOptions,\n  ): Promise<SessionHandler.ReturnType> {\n    const inputMap = new Map<string, OnnxjsTensor>();\n    for (const name in feeds) {\n      if (Object.hasOwnProperty.call(feeds, name)) {\n        const feed = feeds[name];\n        inputMap.set(\n          name,\n          new OnnxjsTensor(\n            feed.dims,\n            feed.type as OnnxjsTensor.DataType,\n            undefined,\n            undefined,\n            feed.data as OnnxjsTensor.NumberType,\n          ),\n        );\n      }\n    }\n    const outputMap = await this.session.run(inputMap);\n    const output: SessionHandler.ReturnType = {};\n    outputMap.forEach((tensor, name) => {\n      output[name] = new Tensor(tensor.type, tensor.data, tensor.dims);\n    });\n    return output;\n  }\n  startProfiling(): void {\n    this.session.startProfiling();\n  }\n  endProfiling(): void {\n    this.session.endProfiling();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/* eslint-disable import/no-internal-modules */\nimport { Backend, InferenceSession, InferenceSessionHandler } from 'onnxruntime-common';\n\nimport { Session } from './onnxjs/session';\nimport { OnnxjsSessionHandler } from './onnxjs/session-handler-inference';\n\nclass OnnxjsBackend implements Backend {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  async init(): Promise<void> {}\n\n  async createInferenceSessionHandler(\n    pathOrBuffer: string | Uint8Array,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSessionHandler> {\n    // NOTE: Session.Config(from onnx.js) is not compatible with InferenceSession.SessionOptions(from\n    // onnxruntime-common).\n    //       In future we should remove Session.Config and use InferenceSession.SessionOptions.\n    //       Currently we allow this to happen to make test runner work.\n    const session = new Session(options as unknown as Session.Config);\n\n    // typescript cannot merge method override correctly (so far in 4.2.3). need if-else to call the method.\n    if (typeof pathOrBuffer === 'string') {\n      await session.loadModel(pathOrBuffer);\n    } else {\n      await session.loadModel(pathOrBuffer);\n    }\n\n    return new OnnxjsSessionHandler(session);\n  }\n}\n\nexport const onnxjsBackend = new OnnxjsBackend();\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nexport const isNode = !!(typeof process !== 'undefined' && process.versions && process.versions.node);\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/// <reference lib=\"webworker\" />\n\n//\n// * type hack for \"HTMLImageElement\"\n//\n// in typescript, the type of \"HTMLImageElement\" is defined in lib.dom.d.ts, which is conflict with lib.webworker.d.ts.\n// when we use webworker, the lib.webworker.d.ts will be used, which does not have HTMLImageElement defined.\n//\n// we will get the following errors complaining that HTMLImageElement is not defined:\n//\n// ====================================================================================================================\n//\n// ../common/dist/cjs/tensor-factory.d.ts:187:29 - error TS2552: Cannot find name 'HTMLImageElement'. Did you mean\n// 'HTMLLIElement'?\n//\n// 187     fromImage(imageElement: HTMLImageElement, options?: TensorFromImageElementOptions):\n// Promise<TypedTensor<'float32'> | TypedTensor<'uint8'>>;\n//                                 ~~~~~~~~~~~~~~~~\n//\n// node_modules/@webgpu/types/dist/index.d.ts:83:7 - error TS2552: Cannot find name 'HTMLImageElement'. Did you mean\n// 'HTMLLIElement'?\n//\n// 83     | HTMLImageElement\n//          ~~~~~~~~~~~~~~~~\n//\n// ====================================================================================================================\n//\n// `HTMLImageElement` is only used in type declaration and not in real code. So we define it as `unknown` here to\n// bypass the type check.\n\n//\n// * type hack for \"document\"\n//\n// in typescript, the type of \"document\" is defined in lib.dom.d.ts, so it's not available in webworker.\n//\n// we will get the following errors complaining that document is not defined:\n//\n// ====================================================================================================================\n//\n// lib/wasm/wasm-utils-import.ts:7:33 - error TS2584: Cannot find name 'document'. Do you need to change your target\n// library? Try changing the 'lib' compiler option to include 'dom'.\n//\n// 7 export const scriptSrc = typeof document !== 'undefined' ? (document?.currentScript as HTMLScriptElement)?.src :\n//                                   ~~~~~~~~\n//\n// lib/wasm/wasm-utils-import.ts:7:61 - error TS2584: Cannot find name 'document'. Do you need to change your target\n// library? Try changing the 'lib' compiler option to include 'dom'.\n//\n// 7 export const scriptSrc = typeof document !== 'undefined' ? (document?.currentScript as HTMLScriptElement)?.src :\n//                                                               ~~~~~~~~\n//\n// lib/wasm/wasm-utils-import.ts:7:88 - error TS2552: Cannot find name 'HTMLScriptElement'. Did you mean\n// 'HTMLLIElement'?\n//\n// 7 export const scriptSrc = typeof document !== 'undefined' ? (document?.currentScript as HTMLScriptElement)?.src :\n//                                                                                          ~~~~~~~~~~~~~~~~~\n// ====================================================================================================================\n//\n// `document` is used to get the current script URL, which is not available in webworker. This file is served as a\n// \"dual\" file for entries of both webworker and the esm module.\n//\ndeclare global {\n  type HTMLImageElement = unknown;\n  type HTMLScriptElement = { src?: string };\n  const document: undefined | { currentScript?: HTMLScriptElement };\n}\n\n/**\n * @summary\n *\n * This file is served as a \"dual\" file for both entries of the following:\n * - The proxy worker itself.\n *   - When used as a worker, it listens to the messages from the main thread and performs the corresponding operations.\n *   - Should be imported directly using `new Worker()` in the main thread.\n *\n * - The ESM module that creates the proxy worker (as a worker launcher).\n *   - When used as a worker launcher, it creates the proxy worker and returns it.\n *   - Should be imported using `import()` in the main thread, with the query parameter `import=1`.\n *\n * This file will be always compiling into ESM format.\n */\n\nimport type { OrtWasmMessage, SerializableTensorMetadata } from '../proxy-messages.js';\nimport {\n  createSession,\n  copyFromExternalBuffer,\n  endProfiling,\n  extractTransferableBuffers,\n  initEp,\n  initRuntime,\n  releaseSession,\n  run,\n} from '../wasm-core-impl.js';\nimport { initializeWebAssembly } from '../wasm-factory.js';\nimport { scriptSrc } from '../wasm-utils-import.js';\n\nconst WORKER_NAME = 'ort-wasm-proxy-worker';\nconst isProxyWorker = globalThis.self?.name === WORKER_NAME;\n\nif (isProxyWorker) {\n  // Worker thread\n  self.onmessage = (ev: MessageEvent<OrtWasmMessage>): void => {\n    const { type, in: message } = ev.data;\n    try {\n      switch (type) {\n        case 'init-wasm':\n          initializeWebAssembly(message!.wasm).then(\n            () => {\n              initRuntime(message!).then(\n                () => {\n                  postMessage({ type });\n                },\n                (err) => {\n                  postMessage({ type, err });\n                },\n              );\n            },\n            (err) => {\n              postMessage({ type, err });\n            },\n          );\n          break;\n        case 'init-ep': {\n          const { epName, env } = message!;\n          initEp(env, epName).then(\n            () => {\n              postMessage({ type });\n            },\n            (err) => {\n              postMessage({ type, err });\n            },\n          );\n          break;\n        }\n        case 'copy-from': {\n          const { buffer } = message!;\n          const bufferData = copyFromExternalBuffer(buffer);\n          postMessage({ type, out: bufferData } as OrtWasmMessage);\n          break;\n        }\n        case 'create': {\n          const { model, options } = message!;\n          createSession(model, options).then(\n            (sessionMetadata) => {\n              postMessage({ type, out: sessionMetadata } as OrtWasmMessage);\n            },\n            (err) => {\n              postMessage({ type, err });\n            },\n          );\n          break;\n        }\n        case 'release':\n          releaseSession(message!);\n          postMessage({ type });\n          break;\n        case 'run': {\n          const { sessionId, inputIndices, inputs, outputIndices, options } = message!;\n          run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(\n            (outputs) => {\n              if (outputs.some((o) => o[3] !== 'cpu')) {\n                postMessage({ type, err: 'Proxy does not support non-cpu tensor location.' });\n              } else {\n                postMessage(\n                  { type, out: outputs } as OrtWasmMessage,\n                  extractTransferableBuffers([...inputs, ...outputs] as SerializableTensorMetadata[]),\n                );\n              }\n            },\n            (err) => {\n              postMessage({ type, err });\n            },\n          );\n          break;\n        }\n        case 'end-profiling':\n          endProfiling(message!);\n          postMessage({ type });\n          break;\n        default:\n      }\n    } catch (err) {\n      postMessage({ type, err } as OrtWasmMessage);\n    }\n  };\n}\n\nexport default isProxyWorker\n  ? null\n  : (urlOverride?: string) =>\n      new Worker(urlOverride ?? scriptSrc!, { type: BUILD_DEFS.IS_ESM ? 'module' : 'classic', name: WORKER_NAME });\n","var e,t=(e=import.meta.url,async function(t={}){function r(){return C.buffer!=R.buffer&&H(),R}function n(){return C.buffer!=R.buffer&&H(),U}function a(){return C.buffer!=R.buffer&&H(),Y}function o(){return C.buffer!=R.buffer&&H(),W}function i(){return C.buffer!=R.buffer&&H(),x}var s,u,f=Object.assign({},t),l=new Promise(((e,t)=>{s=e,u=t})),c=\"object\"==typeof window,d=\"function\"==typeof importScripts,g=d&&\"em-pthread\"==self.name;f.mountExternalData=(e,t)=>{e.startsWith(\"./\")&&(e=e.substring(2)),(f.Ua||(f.Ua=new Map)).set(e,t)},f.unmountExternalData=()=>{delete f.Ua};var h,m,p=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor,b=Object.assign({},f),v=\"./this.program\",w=(e,t)=>{throw t},O=\"\";(c||d)&&(d?O=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(O=document.currentScript.src),e&&(O=e),O=O.startsWith(\"blob:\")?\"\":O.substr(0,O.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1),e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.send(null),t.responseText},d&&(m=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.responseType=\"arraybuffer\",t.send(null),new Uint8Array(t.response)}),h=(e,t,r)=>{var n=new XMLHttpRequest;n.open(\"GET\",e,!0),n.responseType=\"arraybuffer\",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,_=console.log.bind(console),T=console.error.bind(console),M=_,A=T;if(Object.assign(f,b),b=null,g){var S,E=!1;function rr(e){try{var t=e.data,r=t.cmd;if(\"load\"===r){let e=[];self.onmessage=t=>e.push(t),self.startWorker=()=>{postMessage({cmd:\"loaded\"});for(let t of e)rr(t);self.onmessage=rr};for(const e of t.handlers)f[e]&&!f[e].proxy||(f[e]=(...t)=>{postMessage({Za:\"callHandler\",kb:e,args:t})},\"print\"==e&&(M=f[e]),\"printErr\"==e&&(A=f[e]));C=t.wasmMemory,H(),S(t.wasmModule)}else if(\"run\"===r){Lt(t.pthread_ptr,0,0,1,0,0),Ve(t.pthread_ptr),we(),he(),E||=!0;try{ye(t.start_routine,t.arg)}catch(e){if(\"unwind\"!=e)throw e}}else\"cancel\"===r?Gt()&&Xt(-1):\"setimmediate\"!==t.target&&(\"checkMailbox\"===r?E&&Xe():r&&(A(`worker: received unknown command ${r}`),A(t)))}catch(e){throw zt(),e}}A=function(...e){e=e.join(\" \"),console.error(e)},self.alert=function(...e){postMessage({Za:\"alert\",text:e.join(\" \"),nb:Gt()})},f.instantiateWasm=(e,t)=>new Promise((e=>{S=r=>{r=new WebAssembly.Instance(r,J()),t(r),e()}})),self.onunhandledrejection=e=>{throw e.reason||e},self.onmessage=rr}f.wasmBinary&&(y=f.wasmBinary);var C,D,F,R,U,Y,W,k,x,B=!1;function H(){var e=C.buffer;f.HEAP8=R=new Int8Array(e),f.HEAP16=new Int16Array(e),f.HEAPU8=U=new Uint8Array(e),f.HEAPU16=new Uint16Array(e),f.HEAP32=Y=new Int32Array(e),f.HEAPU32=W=new Uint32Array(e),f.HEAPF32=new Float32Array(e),f.HEAPF64=x=new Float64Array(e),f.HEAP64=k=new BigInt64Array(e),f.HEAPU64=new BigUint64Array(e)}if(!g){if(!((C=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof p))throw A(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),Error(\"bad memory\");H()}var P=[],I=[],N=[],$=0,G=null,j=null;function L(){if(0==--$&&(null!==G&&(clearInterval(G),G=null),j)){var e=j;j=null,e()}}function z(e){throw A(e=\"Aborted(\"+e+\")\"),B=!0,F=1,e=new WebAssembly.RuntimeError(e+\". Build with -sASSERTIONS for more info.\"),u(e),e}var Q,V=e=>e.startsWith(\"data:application/octet-stream;base64,\"),X=e=>e.startsWith(\"file://\");function q(e){if(e==Q&&y)return new Uint8Array(y);if(m)return m(e);throw\"both async and sync fetching of the wasm failed\"}function Z(e,t,r){return function(e){if(!y&&(c||d)){if(\"function\"==typeof fetch&&!X(e))return fetch(e,{credentials:\"same-origin\"}).then((t=>{if(!t.ok)throw`failed to load wasm binary file at '${e}'`;return t.arrayBuffer()})).catch((()=>q(e)));if(h)return new Promise(((t,r)=>{h(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>q(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then(r,(e=>{A(`failed to asynchronously prepare wasm: ${e}`),z(e)}))}function J(){return{a:{j:ee,b:Te,E:Ae,g:De,V:Fe,A:We,C:ke,W:xe,T:Be,L:He,S:Pe,o:Ie,B:Ne,y:$e,U:Ge,z:je,_:Le,Z:ze,P:Qe,w:qe,F:Je,k:Ke,O:Ve,Y:et,I:tt,J:ot,K:it,G:st,H:ut,v:ft,q:ct,l:dt,p:gt,e:ht,X:pt,x:bt,d:mt,f:vt,i:wt,u:Ot,t:Mt,s:At,Q:Dt,R:Ft,D:ue,h:Rt,n:Ut,M:Yt,m:kt,a:C,r:ie,N:Pt,c:It}}}var K={837620:(e,t,r,a,o)=>{if(void 0===f||!f.Ua)return 1;if((e=Ce(e>>>0)).startsWith(\"./\")&&(e=e.substring(2)),!(e=f.Ua.get(e)))return 2;if(a>>>=0,(t>>>=0)+(r>>>=0)>e.byteLength)return 3;try{const i=e.subarray(t,t+r);switch(o){case 0:n().set(i,a>>>0);break;case 1:f.mb(a,i);break;default:return 4}return 0}catch{return 4}},838303:()=>\"undefined\"!=typeof wasmOffsetConverter};function ee(){return\"undefined\"!=typeof wasmOffsetConverter}function te(e){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${e})`,this.status=e}var re=e=>{e.terminate(),e.onmessage=()=>{}},ne=e=>{0==fe.length&&(pe(),me(fe[0]));var t=fe.pop();if(!t)return 6;le.push(t),de[e.Ra]=t,t.Ra=e.Ra;var r={cmd:\"run\",start_routine:e.cb,arg:e.ab,pthread_ptr:e.Ra};return t.postMessage(r,e.ib),0},ae=0,oe=(e,t,...r)=>{for(var n=2*r.length,a=er(),o=Kt(8*n),s=o>>>3,u=0;u<r.length;u++){var f=r[u];\"bigint\"==typeof f?(k[s+2*u]=1n,k[s+2*u+1]=f):(k[s+2*u]=0n,i()[s+2*u+1>>>0]=f)}return e=Qt(e,0,n,o,t),Jt(a),e};function ie(e){if(g)return oe(0,1,e);if(F=e,!(0<ae)){for(var t of le)re(t);for(t of fe)re(t);fe=[],le=[],de=[],B=!0}w(e,new te(e))}function se(e){if(g)return oe(1,0,e);ue(e)}var ue=e=>{if(F=e,g)throw se(e),\"unwind\";ie(e)},fe=[],le=[],ce=[],de={},ge=e=>{var t=e.Ra;delete de[t],fe.push(e),le.splice(le.indexOf(e),1),e.Ra=0,Vt(t)};function he(){ce.forEach((e=>e()))}var me=e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=Gt()){var a=de[r.targetThread];a?a.postMessage(r,r.transferList):A(`Internal error! Worker sent a message \"${n}\" to target pthread ${r.targetThread}, but that thread no longer exists!`)}else\"checkMailbox\"===n?Xe():\"spawnThread\"===n?ne(r):\"cleanupThread\"===n?ge(de[r.thread]):\"killThread\"===n?(r=r.thread,n=de[r],delete de[r],re(n),Vt(r),le.splice(le.indexOf(n),1),n.Ra=0):\"cancelThread\"===n?de[r.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===n?(e.loaded=!0,t(e)):\"alert\"===n?alert(`Thread ${r.threadId}: ${r.text}`):\"setimmediate\"===r.target?e.postMessage(r):\"callHandler\"===n?f[r.handler](...r.args):n&&A(`worker sent an unknown command ${n}`)},e.onerror=e=>{throw A(`worker sent an error! ${e.filename}:${e.lineno}: ${e.message}`),e};var r,n=[];for(r of[])f.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:\"load\",handlers:n,wasmMemory:C,wasmModule:D})}));function pe(){var e=new Worker(new URL(import.meta.url),{type:\"module\",workerData:\"em-pthread\",name:\"em-pthread\"});fe.push(e)}var be,ve=e=>{for(;0<e.length;)e.shift()(f)},we=()=>{var e=Gt(),t=o()[e+52>>>2>>>0];e=o()[e+56>>>2>>>0],Zt(t,t-e),Jt(t)},Oe=[],ye=(e,t)=>{ae=0;var r=Oe[e];r||(e>=Oe.length&&(Oe.length=e+1),Oe[e]=r=be.get(e)),e=r(t),0<ae?F=e:Xt(e)};class _e{constructor(e){this.Xa=e-24}}function Te(e,t,r){var n=new _e(e>>>=0);throw t>>>=0,r>>>=0,o()[n.Xa+16>>>2>>>0]=0,o()[n.Xa+4>>>2>>>0]=t,o()[n.Xa+8>>>2>>>0]=r,e}function Me(e,t,r,n){return g?oe(2,1,e,t,r,n):Ae(e,t,r,n)}function Ae(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,void 0===p)return A(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var a=[];return g&&0===a.length?Me(e,t,r,n):(e={cb:r,Ra:e,ab:n,ib:a},g?(e.Za=\"spawnThread\",postMessage(e,a),0):ne(e))}var Se=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0,Ee=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&Se)return Se.decode(e.buffer instanceof p?e.slice(t,r):e.subarray(t,r));for(n=\"\";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},Ce=(e,t)=>(e>>>=0)?Ee(n(),e,t):\"\";function De(e,t,r){return g?oe(3,1,e,t,r):0}function Fe(e,t){if(g)return oe(4,1,e,t)}var Re=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ue=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Ye=(e,t,r)=>Ue(e,n(),t,r);function We(e,t){if(g)return oe(5,1,e,t)}function ke(e,t,r){if(g)return oe(6,1,e,t,r)}function xe(e,t,r){return g?oe(7,1,e,t,r):0}function Be(e,t){if(g)return oe(8,1,e,t)}function He(e,t,r){if(g)return oe(9,1,e,t,r)}function Pe(e,t,r,n){if(g)return oe(10,1,e,t,r,n)}function Ie(e,t,r,n){if(g)return oe(11,1,e,t,r,n)}function Ne(e,t,r,n){if(g)return oe(12,1,e,t,r,n)}function $e(e){if(g)return oe(13,1,e)}function Ge(e,t){if(g)return oe(14,1,e,t)}function je(e,t,r){if(g)return oe(15,1,e,t,r)}var Le=()=>{z(\"\")},ze=()=>1;function Qe(e){Lt(e>>>0,!d,1,!c,131072,!1),he()}function Ve(e){e>>>=0,\"function\"==typeof Atomics.jb&&(Atomics.jb(a(),e>>>2,e).value.then(Xe),e+=128,Atomics.store(a(),e>>>2,1))}var Xe=()=>{var e=Gt();if(e&&(Ve(e),e=qt,!B))try{if(e(),!(0<ae))try{g?Xt(F):ue(F)}catch(e){e instanceof te||\"unwind\"==e||w(1,e)}}catch(e){e instanceof te||\"unwind\"==e||w(1,e)}};function qe(e,t){(e>>>=0)==t>>>0?setTimeout(Xe):g?postMessage({targetThread:e,cmd:\"checkMailbox\"}):(e=de[e])&&e.postMessage({cmd:\"checkMailbox\"})}var Ze=[];function Je(e,t,r,n,a){for(t>>>=0,n/=2,Ze.length=n,r=a>>>0>>>3,a=0;a<n;a++)Ze[a]=k[r+2*a]?k[r+2*a+1]:i()[r+2*a+1>>>0];return(t?K[t]:Nt[e])(...Ze)}function Ke(e){e>>>=0,g?postMessage({cmd:\"cleanupThread\",thread:e}):ge(de[e])}function et(e){}function tt(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),a()[t>>>2>>>0]=e.getUTCSeconds(),a()[t+4>>>2>>>0]=e.getUTCMinutes(),a()[t+8>>>2>>>0]=e.getUTCHours(),a()[t+12>>>2>>>0]=e.getUTCDate(),a()[t+16>>>2>>>0]=e.getUTCMonth(),a()[t+20>>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>>2>>>0]=e}var rt=e=>0==e%4&&(0!=e%100||0==e%400),nt=[0,31,60,91,121,152,182,213,244,274,305,335],at=[0,31,59,90,120,151,181,212,243,273,304,334];function ot(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),a()[t>>>2>>>0]=e.getSeconds(),a()[t+4>>>2>>>0]=e.getMinutes(),a()[t+8>>>2>>>0]=e.getHours(),a()[t+12>>>2>>>0]=e.getDate(),a()[t+16>>>2>>>0]=e.getMonth(),a()[t+20>>>2>>>0]=e.getFullYear()-1900,a()[t+24>>>2>>>0]=e.getDay();var r=(rt(e.getFullYear())?nt:at)[e.getMonth()]+e.getDate()-1|0;a()[t+28>>>2>>>0]=r,a()[t+36>>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>>2>>>0]=e}function it(e){e>>>=0;var t=new Date(a()[e+20>>>2>>>0]+1900,a()[e+16>>>2>>>0],a()[e+12>>>2>>>0],a()[e+8>>>2>>>0],a()[e+4>>>2>>>0],a()[e>>>2>>>0],0),r=a()[e+32>>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(i,o);return 0>r?a()[e+32>>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),a()[e+24>>>2>>>0]=t.getDay(),r=(rt(t.getFullYear())?nt:at)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>>2>>>0]=r,a()[e>>>2>>>0]=t.getSeconds(),a()[e+4>>>2>>>0]=t.getMinutes(),a()[e+8>>>2>>>0]=t.getHours(),a()[e+12>>>2>>>0]=t.getDate(),a()[e+16>>>2>>>0]=t.getMonth(),a()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),BigInt(isNaN(e)?-1:e/1e3)}function st(e,t,r,n,a,o,i){return g?oe(16,1,e,t,r,n,a,o,i):-52}function ut(e,t,r,n,a,o){if(g)return oe(17,1,e,t,r,n,a,o)}function ft(e,t,r,n){e>>>=0,t>>>=0,r>>>=0,n>>>=0;var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var f=u.getTimezoneOffset(),l=Math.max(i,f);o()[e>>>2>>>0]=60*l,a()[t>>>2>>>0]=Number(i!=f),s=(e=e=>e.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:\"short\"}).split(\" \")[1])(s),u=e(u),f<i?(Ye(s,r,17),Ye(u,n,17)):(Ye(s,n,17),Ye(u,r,17))}var lt=[];function ct(e,t,r){e>>>=0,t>>>=0,r>>>=0,lt.length=0;for(var s;s=n()[t++>>>0];){var u=105!=s;r+=(u&=112!=s)&&r%8?4:0,lt.push(112==s?o()[r>>>2>>>0]:106==s?k[r>>>3]:105==s?a()[r>>>2>>>0]:i()[r>>>3>>>0]),r+=u?8:4}return K[e](...lt)}var dt=()=>{},gt=()=>Date.now();function ht(e,t){return A(Ce(e>>>0,t>>>0))}var mt,pt=()=>{throw ae+=1,\"unwind\"};function bt(){return 4294901760}mt=()=>performance.timeOrigin+performance.now();var vt=()=>navigator.hardwareConcurrency;function wt(){return z(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"),0}function Ot(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=(o.min.call(o,4294901760,a+(65536-a%65536)%65536)-C.buffer.byteLength+65535)/65536;try{C.grow(o),H();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1}var yt=()=>(z(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"),0),_t={},Tt=e=>{e.forEach((e=>{var t=yt();t&&(_t[t]=e)}))};function Mt(){var e=Error().stack.toString().split(\"\\n\");return\"Error\"==e[0]&&e.shift(),Tt(e),_t.$a=yt(),_t.bb=e,_t.$a}function At(e,t,r){if(e>>>=0,t>>>=0,_t.$a==e)var n=_t.bb;else\"Error\"==(n=Error().stack.toString().split(\"\\n\"))[0]&&n.shift(),Tt(n);for(var o=3;n[o]&&yt()!=e;)++o;for(e=0;e<r&&n[e+o];++e)a()[t+4*e>>>2>>>0]=yt();return e}var St,Et={},Ct=()=>{if(!St){var e,t={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:v||\"./this.program\"};for(e in Et)void 0===Et[e]?delete t[e]:t[e]=Et[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);St=r}return St};function Dt(e,t){if(g)return oe(18,1,e,t);e>>>=0,t>>>=0;var n=0;return Ct().forEach(((a,i)=>{var s=t+n;for(i=o()[e+4*i>>>2>>>0]=s,s=0;s<a.length;++s)r()[i++>>>0]=a.charCodeAt(s);r()[i>>>0]=0,n+=a.length+1})),0}function Ft(e,t){if(g)return oe(19,1,e,t);e>>>=0,t>>>=0;var r=Ct();o()[e>>>2>>>0]=r.length;var n=0;return r.forEach((e=>n+=e.length+1)),o()[t>>>2>>>0]=n,0}function Rt(e){return g?oe(20,1,e):52}function Ut(e,t,r,n){return g?oe(21,1,e,t,r,n):52}function Yt(e,t,r,n){return g?oe(22,1,e,t,r,n):70}var Wt=[null,[],[]];function kt(e,t,r,a){if(g)return oe(23,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var i=0,s=0;s<r;s++){var u=o()[t>>>2>>>0],f=o()[t+4>>>2>>>0];t+=8;for(var l=0;l<f;l++){var c=n()[u+l>>>0],d=Wt[e];0===c||10===c?((1===e?M:A)(Ee(d,0)),d.length=0):d.push(c)}i+=f}return o()[a>>>2>>>0]=i,0}var xt=[31,29,31,30,31,30,31,31,30,31,30,31],Bt=[31,28,31,30,31,30,31,31,30,31,30,31],Ht=(e,t)=>{r().set(e,t>>>0)};function Pt(e,t,r,n){function i(e,t,r){for(e=\"number\"==typeof e?e.toString():e||\"\";e.length<t;)e=r[0]+e;return e}function s(e,t){return i(e,t,\"0\")}function u(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function f(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Sa;for(e=new Date(new Date(e.Ta+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(rt(e.getFullYear())?xt:Bt)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=f(new Date(e.getFullYear(),0,4)),r=f(r),0>=u(t,e)?0>=u(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var c=o()[n+40>>>2>>>0];for(var d in n={gb:a()[n>>>2>>>0],fb:a()[n+4>>>2>>>0],Va:a()[n+8>>>2>>>0],Ya:a()[n+12>>>2>>>0],Wa:a()[n+16>>>2>>>0],Ta:a()[n+20>>>2>>>0],Qa:a()[n+24>>>2>>>0],Sa:a()[n+28>>>2>>>0],ob:a()[n+32>>>2>>>0],eb:a()[n+36>>>2>>>0],hb:c?Ce(c):\"\"},r=Ce(r),c={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(d,\"g\"),c[d]);var g=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),h=\"January February March April May June July August September October November December\".split(\" \");for(d in c={\"%a\":e=>g[e.Qa].substring(0,3),\"%A\":e=>g[e.Qa],\"%b\":e=>h[e.Wa].substring(0,3),\"%B\":e=>h[e.Wa],\"%C\":e=>s((e.Ta+1900)/100|0,2),\"%d\":e=>s(e.Ya,2),\"%e\":e=>i(e.Ya,2,\" \"),\"%g\":e=>l(e).toString().substring(2),\"%G\":l,\"%H\":e=>s(e.Va,2),\"%I\":e=>(0==(e=e.Va)?e=12:12<e&&(e-=12),s(e,2)),\"%j\":e=>{for(var t=0,r=0;r<=e.Wa-1;t+=(rt(e.Ta+1900)?xt:Bt)[r++]);return s(e.Ya+t,3)},\"%m\":e=>s(e.Wa+1,2),\"%M\":e=>s(e.fb,2),\"%n\":()=>\"\\n\",\"%p\":e=>0<=e.Va&&12>e.Va?\"AM\":\"PM\",\"%S\":e=>s(e.gb,2),\"%t\":()=>\"\\t\",\"%u\":e=>e.Qa||7,\"%U\":e=>s(Math.floor((e.Sa+7-e.Qa)/7),2),\"%V\":e=>{var t=Math.floor((e.Sa+7-(e.Qa+6)%7)/7);if(2>=(e.Qa+371-e.Sa-2)%7&&t++,t)53==t&&(4==(r=(e.Qa+371-e.Sa)%7)||3==r&&rt(e.Ta)||(t=1));else{t=52;var r=(e.Qa+7-e.Sa-1)%7;(4==r||5==r&&rt(e.Ta%400-1))&&t++}return s(t,2)},\"%w\":e=>e.Qa,\"%W\":e=>s(Math.floor((e.Sa+7-(e.Qa+6)%7)/7),2),\"%y\":e=>(e.Ta+1900).toString().substring(2),\"%Y\":e=>e.Ta+1900,\"%z\":e=>{var t=0<=(e=e.eb);return e=Math.abs(e)/60,(t?\"+\":\"-\")+String(\"0000\"+(e/60*100+e%60)).slice(-4)},\"%Z\":e=>e.hb,\"%%\":()=>\"%\"},r=r.replace(/%%/g,\"\\0\\0\"),c)r.includes(d)&&(r=r.replace(new RegExp(d,\"g\"),c[d](n)));return d=function(e){var t=Array(Re(e)+1);return Ue(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,\"%\")),d.length>t?0:(Ht(d,e),d.length-1)}function It(e,t,r,n){return Pt(e>>>0,t>>>0,r>>>0,n>>>0)}g||function(){for(var e=f.numThreads-1;e--;)pe();P.unshift((()=>{$++,function(e){g?e():Promise.all(fe.map(me)).then(e)}((()=>L()))}))}();var Nt=[ie,se,Me,De,Fe,We,ke,xe,Be,He,Pe,Ie,Ne,$e,Ge,je,st,ut,Dt,Ft,Rt,Ut,Yt,kt],$t=function(){function e(e,t){return $t=e.exports,$t=function(){var e=$t,t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).Ba=t(e.Ba),e.Ca=r(e.Ca),e.emscripten_main_runtime_thread_id=t(e.emscripten_main_runtime_thread_id),e.Oa=r(e.Oa),e.Pa=t(e.Pa),e}(),ce.push($t.Ea),be=$t.Fa,I.unshift($t.$),D=t,L(),$t}var t=J();if($++,f.instantiateWasm)try{return f.instantiateWasm(t,e)}catch(e){A(`Module.instantiateWasm callback failed with error: ${e}`),u(e)}return Q||=f.locateFile?V(\"ort-wasm-simd-threaded.wasm\")?\"ort-wasm-simd-threaded.wasm\":f.locateFile?f.locateFile(\"ort-wasm-simd-threaded.wasm\",O):O+\"ort-wasm-simd-threaded.wasm\":new URL(\"ort-wasm-simd-threaded.wasm\",import.meta.url).href,function(e,t){var r=Q;return y||\"function\"!=typeof WebAssembly.instantiateStreaming||V(r)||X(r)||\"function\"!=typeof fetch?Z(r,e,t):fetch(r,{credentials:\"same-origin\"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return A(`wasm streaming compile failed: ${n}`),A(\"falling back to ArrayBuffer instantiation\"),Z(r,e,t)}))))}(t,(function(t){e(t.instance,t.module)})).catch(u),{}}();f._OrtInit=(e,t)=>(f._OrtInit=$t.aa)(e,t),f._OrtGetLastError=(e,t)=>(f._OrtGetLastError=$t.ba)(e,t),f._OrtCreateSessionOptions=(e,t,r,n,a,o,i,s,u,l)=>(f._OrtCreateSessionOptions=$t.ca)(e,t,r,n,a,o,i,s,u,l),f._OrtAppendExecutionProvider=(e,t)=>(f._OrtAppendExecutionProvider=$t.da)(e,t),f._OrtAddFreeDimensionOverride=(e,t,r)=>(f._OrtAddFreeDimensionOverride=$t.ea)(e,t,r),f._OrtAddSessionConfigEntry=(e,t,r)=>(f._OrtAddSessionConfigEntry=$t.fa)(e,t,r),f._OrtReleaseSessionOptions=e=>(f._OrtReleaseSessionOptions=$t.ga)(e),f._OrtCreateSession=(e,t,r)=>(f._OrtCreateSession=$t.ha)(e,t,r),f._OrtReleaseSession=e=>(f._OrtReleaseSession=$t.ia)(e),f._OrtGetInputOutputCount=(e,t,r)=>(f._OrtGetInputOutputCount=$t.ja)(e,t,r),f._OrtGetInputName=(e,t)=>(f._OrtGetInputName=$t.ka)(e,t),f._OrtGetOutputName=(e,t)=>(f._OrtGetOutputName=$t.la)(e,t),f._OrtFree=e=>(f._OrtFree=$t.ma)(e),f._OrtCreateTensor=(e,t,r,n,a,o)=>(f._OrtCreateTensor=$t.na)(e,t,r,n,a,o),f._OrtGetTensorData=(e,t,r,n,a)=>(f._OrtGetTensorData=$t.oa)(e,t,r,n,a),f._OrtReleaseTensor=e=>(f._OrtReleaseTensor=$t.pa)(e),f._OrtCreateRunOptions=(e,t,r,n)=>(f._OrtCreateRunOptions=$t.qa)(e,t,r,n),f._OrtAddRunConfigEntry=(e,t,r)=>(f._OrtAddRunConfigEntry=$t.ra)(e,t,r),f._OrtReleaseRunOptions=e=>(f._OrtReleaseRunOptions=$t.sa)(e),f._OrtCreateBinding=e=>(f._OrtCreateBinding=$t.ta)(e),f._OrtBindInput=(e,t,r)=>(f._OrtBindInput=$t.ua)(e,t,r),f._OrtBindOutput=(e,t,r,n)=>(f._OrtBindOutput=$t.va)(e,t,r,n),f._OrtClearBoundOutputs=e=>(f._OrtClearBoundOutputs=$t.wa)(e),f._OrtReleaseBinding=e=>(f._OrtReleaseBinding=$t.xa)(e),f._OrtRunWithBinding=(e,t,r,n,a)=>(f._OrtRunWithBinding=$t.ya)(e,t,r,n,a),f._OrtRun=(e,t,r,n,a,o,i,s)=>(f._OrtRun=$t.za)(e,t,r,n,a,o,i,s),f._OrtEndProfiling=e=>(f._OrtEndProfiling=$t.Aa)(e);var Gt=()=>(Gt=$t.Ba)();f._malloc=e=>(f._malloc=$t.Ca)(e),f._free=e=>(f._free=$t.Da)(e);var jt,Lt=(e,t,r,n,a,o)=>(Lt=$t.Ga)(e,t,r,n,a,o),zt=()=>(zt=$t.Ha)(),Qt=(e,t,r,n,a)=>(Qt=$t.Ia)(e,t,r,n,a),Vt=e=>(Vt=$t.Ja)(e),Xt=e=>(Xt=$t.Ka)(e),qt=()=>(qt=$t.La)(),Zt=(e,t)=>(Zt=$t.Ma)(e,t),Jt=e=>(Jt=$t.Na)(e),Kt=e=>(Kt=$t.Oa)(e),er=()=>(er=$t.Pa)();function tr(){0<$||(g?(s(f),g||ve(I),startWorker(f)):(ve(P),0<$||jt||(jt=!0,f.calledRun=!0,B||(g||ve(I),s(f),g||ve(N)))))}return f.___start_em_js=838360,f.___stop_em_js=838421,f.stackSave=()=>er(),f.stackRestore=e=>Jt(e),f.stackAlloc=e=>Kt(e),f.UTF8ToString=Ce,f.stringToUTF8=Ye,f.lengthBytesUTF8=Re,j=function e(){jt||tr(),jt||(j=e)},tr(),l});export default t;\"em-pthread\"===globalThis.self?.name&&t();","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport type { OrtWasmModule } from './wasm-types';\nimport { isNode } from './wasm-utils-env';\n\n/**\n * The classic script source URL. This is not always available in non ESModule environments.\n *\n * In Node.js, this is undefined.\n */\nexport const scriptSrc =\n  // if Nodejs, return undefined\n  isNode\n    ? undefined\n    : // if It's ESM, use import.meta.url\n      (BUILD_DEFS.ESM_IMPORT_META_URL ??\n      // use `document.currentScript.src` if available\n      (typeof document !== 'undefined'\n        ? (document.currentScript as HTMLScriptElement)?.src\n        : // use `self.location.href` if available\n          typeof self !== 'undefined'\n          ? self.location?.href\n          : undefined));\n\n/**\n * The origin of the current location.\n *\n * In Node.js, this is undefined.\n */\nconst origin = isNode || typeof location === 'undefined' ? undefined : location.origin;\n\n/**\n * Check if the given filename with prefix is from the same origin.\n */\nconst isSameOrigin = (filename: string, prefixOverride?: string) => {\n  try {\n    const baseUrl = prefixOverride ?? scriptSrc;\n    const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);\n    return url.origin === origin;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Normalize the inputs to an absolute URL with the given prefix override. If failed, return undefined.\n */\nconst normalizeUrl = (filename: string, prefixOverride?: string) => {\n  const baseUrl = prefixOverride ?? scriptSrc;\n  try {\n    const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);\n    return url.href;\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n * Create a fallback URL if an absolute URL cannot be created by the normalizeUrl function.\n */\nconst fallbackUrl = (filename: string, prefixOverride?: string) => `${prefixOverride ?? './'}${filename}`;\n\n/**\n * This helper function is used to preload a module from a URL.\n *\n * If the origin of the worker URL is different from the current origin, the worker cannot be loaded directly.\n * See discussions in https://github.com/webpack-contrib/worker-loader/issues/154\n *\n * In this case, we will fetch the worker URL and create a new Blob URL with the same origin as a workaround.\n *\n * @param absoluteUrl - The absolute URL to preload.\n *\n * @returns - A promise that resolves to a new Blob URL\n */\nconst preload = async (absoluteUrl: string): Promise<string> => {\n  const response = await fetch(absoluteUrl, { credentials: 'same-origin' });\n  const blob = await response.blob();\n  return URL.createObjectURL(blob);\n};\n\n/**\n * This helper function is used to dynamically import a module from a URL.\n *\n * The build script has special handling for this function to ensure that the URL is not bundled into the final output.\n *\n * @param url - The URL to import.\n *\n * @returns - A promise that resolves to the default export of the module.\n */\nconst dynamicImportDefault = async <T>(url: string): Promise<T> =>\n  (await import(/* webpackIgnore: true */ url)).default;\n\n/**\n * The proxy worker factory imported from the proxy worker module.\n *\n * This is only available when the WebAssembly proxy is not disabled.\n */\nconst createProxyWorker: ((urlOverride?: string) => Worker) | undefined =\n  // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\n  BUILD_DEFS.DISABLE_WASM_PROXY ? undefined : require('./proxy-worker/main').default;\n\n/**\n * Import the proxy worker.\n *\n * This function will perform the following steps:\n * 1. If a preload is needed, it will preload the module and return the object URL.\n * 2. Use the proxy worker factory to create the proxy worker.\n *\n * @returns - A promise that resolves to a tuple of 2 elements:\n *            - The object URL of the preloaded module, or undefined if no preload is needed.\n *            - The proxy worker.\n */\nexport const importProxyWorker = async (): Promise<[undefined | string, Worker]> => {\n  if (!scriptSrc) {\n    throw new Error('Failed to load proxy worker: cannot determine the script source URL.');\n  }\n\n  // If the script source is from the same origin, we can use the embedded proxy module directly.\n  if (isSameOrigin(scriptSrc)) {\n    return [undefined, createProxyWorker!()];\n  }\n\n  // Otherwise, need to preload\n  const url = await preload(scriptSrc);\n  return [url, createProxyWorker!(url)];\n};\n\n/**\n * The embedded WebAssembly module.\n *\n * This is only available in ESM and when embedding is not disabled.\n */\nconst embeddedWasmModule: EmscriptenModuleFactory<OrtWasmModule> | undefined =\n  BUILD_DEFS.IS_ESM && BUILD_DEFS.DISABLE_DYNAMIC_IMPORT\n    ? // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\n      require(\n        !BUILD_DEFS.DISABLE_JSEP\n          ? '../../dist/ort-wasm-simd-threaded.jsep.mjs'\n          : '../../dist/ort-wasm-simd-threaded.mjs',\n      ).default\n    : undefined;\n\n/**\n * Import the WebAssembly module.\n *\n * This function will perform the following steps:\n * 1. If BUILD_DEFS.DISABLE_DYNAMIC_IMPORT is true, use the embedded module.\n * 2. If a preload is needed, it will preload the module and return the object URL.\n * 3. Otherwise, it will perform a dynamic import of the module.\n *\n * @returns - A promise that resolves to a tuple of 2 elements:\n *            - The object URL of the preloaded module, or undefined if no preload is needed.\n *            - The default export of the module, which is a factory function to create the WebAssembly module.\n */\nexport const importWasmModule = async (\n  urlOverride: string | undefined,\n  prefixOverride: string | undefined,\n  isMultiThreaded: boolean,\n): Promise<[undefined | string, EmscriptenModuleFactory<OrtWasmModule>]> => {\n  if (BUILD_DEFS.DISABLE_DYNAMIC_IMPORT) {\n    return [undefined, embeddedWasmModule!];\n  } else {\n    const wasmModuleFilename = !BUILD_DEFS.DISABLE_JSEP\n      ? 'ort-wasm-simd-threaded.jsep.mjs'\n      : 'ort-wasm-simd-threaded.mjs';\n    const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);\n    // need to preload if all of the following conditions are met:\n    // 1. not in Node.js.\n    //    - Node.js does not have the same origin policy for creating workers.\n    // 2. multi-threaded is enabled.\n    //    - If multi-threaded is disabled, no worker will be created. So we don't need to preload the module.\n    // 3. the absolute URL is available.\n    //    - If the absolute URL is failed to be created, the origin cannot be determined. In this case, we will not\n    //    preload the module.\n    // 4. the worker URL is not from the same origin.\n    //    - If the worker URL is from the same origin, we can create the worker directly.\n    const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);\n    const url = needPreload\n      ? await preload(wasmModuleUrl)\n      : (wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride));\n    return [needPreload ? url : undefined, await dynamicImportDefault<EmscriptenModuleFactory<OrtWasmModule>>(url)];\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Env } from 'onnxruntime-common';\n\nimport type { OrtWasmModule } from './wasm-types';\nimport { importWasmModule } from './wasm-utils-import';\n\nlet wasm: OrtWasmModule | undefined;\nlet initialized = false;\nlet initializing = false;\nlet aborted = false;\n\nconst isMultiThreadSupported = (): boolean => {\n  // If 'SharedArrayBuffer' is not available, WebAssembly threads will not work.\n  if (typeof SharedArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  try {\n    // Test for transferability of SABs (for browsers. needed for Firefox)\n    // https://groups.google.com/forum/#!msg/mozilla.dev.platform/IHkBZlHETpA/dwsMNchWEQAJ\n    if (typeof MessageChannel !== 'undefined') {\n      new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));\n    }\n\n    // Test for WebAssembly threads capability (for both browsers and Node.js)\n    // This typed array is a WebAssembly program containing threaded instructions.\n    return WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16,\n        2, 0, 26, 11,\n      ]),\n    );\n  } catch (e) {\n    return false;\n  }\n};\n\nconst isSimdSupported = (): boolean => {\n  try {\n    // Test for WebAssembly SIMD capability (for both browsers and Node.js)\n    // This typed array is a WebAssembly program containing SIMD instructions.\n\n    // The binary data is generated from the following code by wat2wasm:\n    //\n    // (module\n    //   (type $t0 (func))\n    //   (func $f0 (type $t0)\n    //     (drop\n    //       (i32x4.dot_i16x8_s\n    //         (i8x16.splat\n    //           (i32.const 0))\n    //         (v128.const i32x4 0x00000000 0x00000000 0x00000000 0x00000000)))))\n\n    return WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11,\n      ]),\n    );\n  } catch (e) {\n    return false;\n  }\n};\n\nexport const initializeWebAssembly = async (flags: Env.WebAssemblyFlags): Promise<void> => {\n  if (initialized) {\n    return Promise.resolve();\n  }\n  if (initializing) {\n    throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n  }\n  if (aborted) {\n    throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n  }\n\n  initializing = true;\n\n  // wasm flags are already initialized\n  const timeout = flags.initTimeout!;\n  let numThreads = flags.numThreads!;\n\n  // ensure SIMD is supported\n  if (!isSimdSupported()) {\n    throw new Error('WebAssembly SIMD is not supported in the current environment.');\n  }\n\n  // check if multi-threading is supported\n  const multiThreadSupported = isMultiThreadSupported();\n  if (numThreads > 1 && !multiThreadSupported) {\n    if (typeof self !== 'undefined' && !self.crossOriginIsolated) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'env.wasm.numThreads is set to ' +\n          numThreads +\n          ', but this will not work unless you enable crossOriginIsolated mode. ' +\n          'See https://web.dev/cross-origin-isolation-guide/ for more info.',\n      );\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn(\n      'WebAssembly multi-threading is not supported in the current environment. ' + 'Falling back to single-threading.',\n    );\n\n    // set flags.numThreads to 1 so that OrtInit() will not create a global thread pool.\n    flags.numThreads = numThreads = 1;\n  }\n\n  const wasmPaths = flags.wasmPaths;\n  const wasmPrefixOverride = typeof wasmPaths === 'string' ? wasmPaths : undefined;\n  const mjsPathOverrideFlag = (wasmPaths as Env.WasmFilePaths)?.mjs;\n  const mjsPathOverride = (mjsPathOverrideFlag as URL)?.href ?? mjsPathOverrideFlag;\n  const wasmPathOverrideFlag = (wasmPaths as Env.WasmFilePaths)?.wasm;\n  const wasmPathOverride = (wasmPathOverrideFlag as URL)?.href ?? wasmPathOverrideFlag;\n  const wasmBinaryOverride = flags.wasmBinary;\n\n  const [objectUrl, ortWasmFactory] = await importWasmModule(mjsPathOverride, wasmPrefixOverride, numThreads > 1);\n\n  let isTimeout = false;\n\n  const tasks: Array<Promise<void>> = [];\n\n  // promise for timeout\n  if (timeout > 0) {\n    tasks.push(\n      new Promise((resolve) => {\n        setTimeout(() => {\n          isTimeout = true;\n          resolve();\n        }, timeout);\n      }),\n    );\n  }\n\n  // promise for module initialization\n  tasks.push(\n    new Promise((resolve, reject) => {\n      const config: Partial<OrtWasmModule> = {\n        /**\n         * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be\n         * created.\n         */\n        numThreads,\n      };\n\n      if (wasmBinaryOverride) {\n        /**\n         * Set a custom buffer which contains the WebAssembly binary. This will skip the wasm file fetching.\n         */\n        config.wasmBinary = wasmBinaryOverride;\n      } else if (wasmPathOverride || wasmPrefixOverride) {\n        /**\n         * A callback function to locate the WebAssembly file. The function should return the full path of the file.\n         *\n         * Since Emscripten 3.1.58, this function is only called for the .wasm file.\n         */\n        config.locateFile = (fileName, scriptDirectory) =>\n          wasmPathOverride ?? (wasmPrefixOverride ?? scriptDirectory) + fileName;\n      }\n\n      ortWasmFactory(config).then(\n        // wasm module initialized successfully\n        (module) => {\n          initializing = false;\n          initialized = true;\n          wasm = module;\n          resolve();\n          if (objectUrl) {\n            URL.revokeObjectURL(objectUrl);\n          }\n        },\n        // wasm module failed to initialize\n        (what) => {\n          initializing = false;\n          aborted = true;\n          reject(what);\n        },\n      );\n    }),\n  );\n\n  await Promise.race(tasks);\n\n  if (isTimeout) {\n    throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);\n  }\n};\n\nexport const getInstance = (): OrtWasmModule => {\n  if (initialized && wasm) {\n    return wasm;\n  }\n\n  throw new Error('WebAssembly is not initialized yet.');\n};\n\nexport const dispose = (): void => {\n  if (initialized && !initializing && !aborted) {\n    // TODO: currently \"PThread.terminateAllThreads()\" is not exposed in the wasm module.\n    //       And this function is not yet called by any code.\n    //       If it is needed in the future, we should expose it in the wasm module and uncomment the following line.\n\n    // wasm?.PThread?.terminateAllThreads();\n    wasm = undefined;\n\n    initializing = false;\n    initialized = false;\n    aborted = true;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getInstance } from './wasm-factory';\n\nexport const allocWasmString = (data: string, allocs: number[]): number => {\n  const wasm = getInstance();\n\n  const dataLength = wasm.lengthBytesUTF8(data) + 1;\n  const dataOffset = wasm._malloc(dataLength);\n  wasm.stringToUTF8(data, dataOffset, dataLength);\n  allocs.push(dataOffset);\n\n  return dataOffset;\n};\n\ninterface ExtraOptionsHandler {\n  (name: string, value: string): void;\n}\n\nexport const iterateExtraOptions = (\n  options: Record<string, unknown>,\n  prefix: string,\n  seen: WeakSet<Record<string, unknown>>,\n  handler: ExtraOptionsHandler,\n): void => {\n  if (typeof options == 'object' && options !== null) {\n    if (seen.has(options)) {\n      throw new Error('Circular reference in options');\n    } else {\n      seen.add(options);\n    }\n  }\n\n  Object.entries(options).forEach(([key, value]) => {\n    const name = prefix ? prefix + key : key;\n    if (typeof value === 'object') {\n      iterateExtraOptions(value as Record<string, unknown>, name + '.', seen, handler);\n    } else if (typeof value === 'string' || typeof value === 'number') {\n      handler(name, value.toString());\n    } else if (typeof value === 'boolean') {\n      handler(name, value ? '1' : '0');\n    } else {\n      throw new Error(`Can't handle extra config type: ${typeof value}`);\n    }\n  });\n};\n\n/**\n * check web assembly API's last error and throw error if any error occurred.\n * @param message a message used when an error occurred.\n */\nexport const checkLastError = (message: string): void => {\n  const wasm = getInstance();\n\n  const stack = wasm.stackSave();\n  try {\n    const paramsOffset = wasm.stackAlloc(8);\n    wasm._OrtGetLastError(paramsOffset, paramsOffset + 4);\n    const errorCode = wasm.HEAP32[paramsOffset / 4];\n    const errorMessagePointer = wasm.HEAPU32[paramsOffset / 4 + 1];\n    const errorMessage = errorMessagePointer ? wasm.UTF8ToString(errorMessagePointer) : '';\n    throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);\n  } finally {\n    wasm.stackRestore(stack);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession } from 'onnxruntime-common';\n\nimport { getInstance } from './wasm-factory';\nimport { allocWasmString, checkLastError, iterateExtraOptions } from './wasm-utils';\n\nexport const setRunOptions = (options: InferenceSession.RunOptions): [number, number[]] => {\n  const wasm = getInstance();\n  let runOptionsHandle = 0;\n  const allocs: number[] = [];\n\n  const runOptions: InferenceSession.RunOptions = options || {};\n\n  try {\n    if (options?.logSeverityLevel === undefined) {\n      runOptions.logSeverityLevel = 2; // Default to warning\n    } else if (\n      typeof options.logSeverityLevel !== 'number' ||\n      !Number.isInteger(options.logSeverityLevel) ||\n      options.logSeverityLevel < 0 ||\n      options.logSeverityLevel > 4\n    ) {\n      throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);\n    }\n\n    if (options?.logVerbosityLevel === undefined) {\n      runOptions.logVerbosityLevel = 0; // Default to 0\n    } else if (typeof options.logVerbosityLevel !== 'number' || !Number.isInteger(options.logVerbosityLevel)) {\n      throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);\n    }\n\n    if (options?.terminate === undefined) {\n      runOptions.terminate = false;\n    }\n\n    let tagDataOffset = 0;\n    if (options?.tag !== undefined) {\n      tagDataOffset = allocWasmString(options.tag, allocs);\n    }\n\n    runOptionsHandle = wasm._OrtCreateRunOptions(\n      runOptions.logSeverityLevel!,\n      runOptions.logVerbosityLevel!,\n      !!runOptions.terminate!,\n      tagDataOffset,\n    );\n    if (runOptionsHandle === 0) {\n      checkLastError(\"Can't create run options.\");\n    }\n\n    if (options?.extra !== undefined) {\n      iterateExtraOptions(options.extra, '', new WeakSet<Record<string, unknown>>(), (key, value) => {\n        const keyDataOffset = allocWasmString(key, allocs);\n        const valueDataOffset = allocWasmString(value, allocs);\n\n        if (wasm._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n          checkLastError(`Can't set a run config entry: ${key} - ${value}.`);\n        }\n      });\n    }\n\n    return [runOptionsHandle, allocs];\n  } catch (e) {\n    if (runOptionsHandle !== 0) {\n      wasm._OrtReleaseRunOptions(runOptionsHandle);\n    }\n    allocs.forEach((alloc) => wasm._free(alloc));\n    throw e;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { InferenceSession } from 'onnxruntime-common';\n\nimport { getInstance } from './wasm-factory';\nimport { allocWasmString, checkLastError, iterateExtraOptions } from './wasm-utils';\n\nconst getGraphOptimzationLevel = (graphOptimizationLevel: string | unknown): number => {\n  switch (graphOptimizationLevel) {\n    case 'disabled':\n      return 0;\n    case 'basic':\n      return 1;\n    case 'extended':\n      return 2;\n    case 'all':\n      return 99;\n    default:\n      throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);\n  }\n};\n\nconst getExecutionMode = (executionMode: 'sequential' | 'parallel'): number => {\n  switch (executionMode) {\n    case 'sequential':\n      return 0;\n    case 'parallel':\n      return 1;\n    default:\n      throw new Error(`unsupported execution mode: ${executionMode}`);\n  }\n};\n\nconst appendDefaultOptions = (options: InferenceSession.SessionOptions): void => {\n  if (!options.extra) {\n    options.extra = {};\n  }\n  if (!options.extra.session) {\n    options.extra.session = {};\n  }\n  const session = options.extra.session as Record<string, string>;\n  if (!session.use_ort_model_bytes_directly) {\n    // eslint-disable-next-line camelcase\n    session.use_ort_model_bytes_directly = '1';\n  }\n\n  // if using JSEP with WebGPU, always disable memory pattern\n  if (\n    options.executionProviders &&\n    options.executionProviders.some((ep) => (typeof ep === 'string' ? ep : ep.name) === 'webgpu')\n  ) {\n    options.enableMemPattern = false;\n  }\n};\n\nconst setExecutionProviders = (\n  sessionOptionsHandle: number,\n  executionProviders: readonly InferenceSession.ExecutionProviderConfig[],\n  allocs: number[],\n): void => {\n  for (const ep of executionProviders) {\n    let epName = typeof ep === 'string' ? ep : ep.name;\n\n    // check EP name\n    switch (epName) {\n      case 'webnn':\n        epName = 'WEBNN';\n        if (typeof ep !== 'string') {\n          const webnnOptions = ep as InferenceSession.WebNNExecutionProviderOption;\n          // const context = (webnnOptions as InferenceSession.WebNNOptionsWithMLContext)?.context;\n          const deviceType = (webnnOptions as InferenceSession.WebNNContextOptions)?.deviceType;\n          if (deviceType) {\n            const keyDataOffset = allocWasmString('deviceType', allocs);\n            const valueDataOffset = allocWasmString(deviceType, allocs);\n            if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n              checkLastError(`Can't set a session config entry: 'deviceType' - ${deviceType}.`);\n            }\n          }\n        }\n        break;\n      case 'webgpu':\n        epName = 'JS';\n        if (typeof ep !== 'string') {\n          const webgpuOptions = ep as InferenceSession.WebGpuExecutionProviderOption;\n          if (webgpuOptions?.preferredLayout) {\n            if (webgpuOptions.preferredLayout !== 'NCHW' && webgpuOptions.preferredLayout !== 'NHWC') {\n              throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);\n            }\n            const keyDataOffset = allocWasmString('preferredLayout', allocs);\n            const valueDataOffset = allocWasmString(webgpuOptions.preferredLayout, allocs);\n            if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n              checkLastError(`Can't set a session config entry: 'preferredLayout' - ${webgpuOptions.preferredLayout}.`);\n            }\n          }\n        }\n        break;\n      case 'wasm':\n      case 'cpu':\n        continue;\n      default:\n        throw new Error(`not supported execution provider: ${epName}`);\n    }\n\n    const epNameDataOffset = allocWasmString(epName, allocs);\n    if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {\n      checkLastError(`Can't append execution provider: ${epName}.`);\n    }\n  }\n};\n\nexport const setSessionOptions = (options?: InferenceSession.SessionOptions): [number, number[]] => {\n  const wasm = getInstance();\n  let sessionOptionsHandle = 0;\n  const allocs: number[] = [];\n\n  const sessionOptions: InferenceSession.SessionOptions = options || {};\n  appendDefaultOptions(sessionOptions);\n\n  try {\n    const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? 'all');\n    const executionMode = getExecutionMode(sessionOptions.executionMode ?? 'sequential');\n    const logIdDataOffset =\n      typeof sessionOptions.logId === 'string' ? allocWasmString(sessionOptions.logId, allocs) : 0;\n\n    const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2; // Default to 2 - warning\n    if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {\n      throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);\n    }\n\n    const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0; // Default to 0 - verbose\n    if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {\n      throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);\n    }\n\n    const optimizedModelFilePathOffset =\n      typeof sessionOptions.optimizedModelFilePath === 'string'\n        ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs)\n        : 0;\n\n    sessionOptionsHandle = wasm._OrtCreateSessionOptions(\n      graphOptimizationLevel,\n      !!sessionOptions.enableCpuMemArena,\n      !!sessionOptions.enableMemPattern,\n      executionMode,\n      !!sessionOptions.enableProfiling,\n      0,\n      logIdDataOffset,\n      logSeverityLevel,\n      logVerbosityLevel,\n      optimizedModelFilePathOffset,\n    );\n    if (sessionOptionsHandle === 0) {\n      checkLastError(\"Can't create session options.\");\n    }\n\n    if (sessionOptions.executionProviders) {\n      setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);\n    }\n\n    if (sessionOptions.enableGraphCapture !== undefined) {\n      if (typeof sessionOptions.enableGraphCapture !== 'boolean') {\n        throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);\n      }\n      const keyDataOffset = allocWasmString('enableGraphCapture', allocs);\n      const valueDataOffset = allocWasmString(sessionOptions.enableGraphCapture.toString(), allocs);\n      if (wasm._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n        checkLastError(\n          `Can't set a session config entry: 'enableGraphCapture' - ${sessionOptions.enableGraphCapture}.`,\n        );\n      }\n    }\n\n    if (sessionOptions.freeDimensionOverrides) {\n      for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {\n        if (typeof name !== 'string') {\n          throw new Error(`free dimension override name must be a string: ${name}`);\n        }\n        if (typeof value !== 'number' || !Number.isInteger(value) || value < 0) {\n          throw new Error(`free dimension override value must be a non-negative integer: ${value}`);\n        }\n        const nameOffset = allocWasmString(name, allocs);\n        if (wasm._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {\n          checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);\n        }\n      }\n    }\n\n    if (sessionOptions.extra !== undefined) {\n      iterateExtraOptions(sessionOptions.extra, '', new WeakSet<Record<string, unknown>>(), (key, value) => {\n        const keyDataOffset = allocWasmString(key, allocs);\n        const valueDataOffset = allocWasmString(value, allocs);\n\n        if (wasm._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n          checkLastError(`Can't set a session config entry: ${key} - ${value}.`);\n        }\n      });\n    }\n\n    return [sessionOptionsHandle, allocs];\n  } catch (e) {\n    if (sessionOptionsHandle !== 0) {\n      wasm._OrtReleaseSessionOptions(sessionOptionsHandle);\n    }\n    allocs.forEach((alloc) => wasm._free(alloc));\n    throw e;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tensor } from 'onnxruntime-common';\n\n// a dummy type declaration for Float16Array in case any polyfill is available.\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-explicit-any\n  const Float16Array: any;\n}\n\n// This file includes common definitions. They do NOT have dependency on the WebAssembly instance.\n\n/**\n * Copied from ONNX definition. Use this to drop dependency 'onnx_proto' to decrease compiled .js file size.\n */\nexport const enum DataType {\n  undefined = 0,\n  float = 1,\n  uint8 = 2,\n  int8 = 3,\n  uint16 = 4,\n  int16 = 5,\n  int32 = 6,\n  int64 = 7,\n  string = 8,\n  bool = 9,\n  float16 = 10,\n  double = 11,\n  uint32 = 12,\n  uint64 = 13,\n  complex64 = 14,\n  complex128 = 15,\n  bfloat16 = 16,\n\n  // 4-bit data-types\n  uint4 = 21,\n  int4 = 22,\n}\n\n/**\n * Map string tensor data to enum value\n */\nexport const tensorDataTypeStringToEnum = (type: string): DataType => {\n  switch (type) {\n    case 'int8':\n      return DataType.int8;\n    case 'uint8':\n      return DataType.uint8;\n    case 'bool':\n      return DataType.bool;\n    case 'int16':\n      return DataType.int16;\n    case 'uint16':\n      return DataType.uint16;\n    case 'int32':\n      return DataType.int32;\n    case 'uint32':\n      return DataType.uint32;\n    case 'float16':\n      return DataType.float16;\n    case 'float32':\n      return DataType.float;\n    case 'float64':\n      return DataType.double;\n    case 'string':\n      return DataType.string;\n    case 'int64':\n      return DataType.int64;\n    case 'uint64':\n      return DataType.uint64;\n    case 'int4':\n      return DataType.int4;\n    case 'uint4':\n      return DataType.uint4;\n\n    default:\n      throw new Error(`unsupported data type: ${type}`);\n  }\n};\n\n/**\n * Map enum value to string tensor data\n */\nexport const tensorDataTypeEnumToString = (typeProto: DataType): Tensor.Type => {\n  switch (typeProto) {\n    case DataType.int8:\n      return 'int8';\n    case DataType.uint8:\n      return 'uint8';\n    case DataType.bool:\n      return 'bool';\n    case DataType.int16:\n      return 'int16';\n    case DataType.uint16:\n      return 'uint16';\n    case DataType.int32:\n      return 'int32';\n    case DataType.uint32:\n      return 'uint32';\n    case DataType.float16:\n      return 'float16';\n    case DataType.float:\n      return 'float32';\n    case DataType.double:\n      return 'float64';\n    case DataType.string:\n      return 'string';\n    case DataType.int64:\n      return 'int64';\n    case DataType.uint64:\n      return 'uint64';\n    case DataType.int4:\n      return 'int4';\n    case DataType.uint4:\n      return 'uint4';\n\n    default:\n      throw new Error(`unsupported data type: ${typeProto}`);\n  }\n};\n\n/**\n * get tensor size in bytes by the given data type and dimensions\n * @returns size in integer or undefined if the data type is not supported\n */\nexport const calculateTensorSizeInBytes = (\n  dateType: number,\n  dimsOrSize: readonly number[] | number,\n): number | undefined => {\n  const elementSize = [\n    -1, // undefined = 0\n    4, // float = 1\n    1, // uint8 = 2\n    1, // int8 = 3\n    2, // uint16 = 4\n    2, // int16 = 5\n    4, // int32 = 6\n    8, // int64 = 7\n    -1, // string = 8\n    1, // bool = 9\n    2, // float16 = 10\n    8, // double = 11\n    4, // uint32 = 12\n    8, // uint64 = 13\n    -1, // complex64 = 14\n    -1, // complex128 = 15\n    -1, // bfloat16 = 16\n    -1, // FLOAT8E4M3FN = 17\n    -1, // FLOAT8E4M3FNUZ = 18\n    -1, // FLOAT8E5M2 = 19\n    -1, // FLOAT8E5M2FNUZ = 20\n    0.5, // uint4 = 21\n    0.5, // int4 = 22\n  ][dateType];\n\n  const size = typeof dimsOrSize === 'number' ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);\n  return elementSize > 0 ? Math.ceil(size * elementSize) : undefined;\n};\n\n/**\n * get typed array constructor by the given tensor type\n */\nexport const tensorTypeToTypedArrayConstructor = (\n  type: Tensor.Type,\n):\n  | Float32ArrayConstructor\n  | Uint8ArrayConstructor\n  | Int8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | BigInt64ArrayConstructor\n  | Uint8ArrayConstructor\n  | Float64ArrayConstructor\n  | Uint32ArrayConstructor\n  | BigUint64ArrayConstructor => {\n  switch (type) {\n    case 'float16':\n      // allow Float16Array polyfill.\n      return typeof Float16Array !== 'undefined' && Float16Array.from ? Float16Array : Uint16Array;\n    case 'float32':\n      return Float32Array;\n    case 'uint8':\n      return Uint8Array;\n    case 'int8':\n      return Int8Array;\n    case 'uint16':\n      return Uint16Array;\n    case 'int16':\n      return Int16Array;\n    case 'int32':\n      return Int32Array;\n    case 'bool':\n      return Uint8Array;\n    case 'float64':\n      return Float64Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'int64':\n      return BigInt64Array;\n    case 'uint64':\n      return BigUint64Array;\n    default:\n      throw new Error(`unsupported type: ${type}`);\n  }\n};\n\n/**\n * Map string log level to integer value\n */\nexport const logLevelStringToEnum = (logLevel?: 'verbose' | 'info' | 'warning' | 'error' | 'fatal'): number => {\n  switch (logLevel) {\n    case 'verbose':\n      return 0;\n    case 'info':\n      return 1;\n    case 'warning':\n      return 2;\n    case 'error':\n      return 3;\n    case 'fatal':\n      return 4;\n    default:\n      throw new Error(`unsupported logging level: ${logLevel}`);\n  }\n};\n\n/**\n * Check whether the given tensor type is supported by GPU buffer\n */\nexport const isGpuBufferSupportedType = (type: Tensor.Type): type is Tensor.GpuBufferDataTypes =>\n  type === 'float32' ||\n  type === 'float16' ||\n  type === 'int32' ||\n  type === 'int64' ||\n  type === 'uint32' ||\n  type === 'uint8' ||\n  type === 'bool' ||\n  type === 'uint4' ||\n  type === 'int4';\n\n/**\n * Check whether the given tensor type is supported by WebNN MLTensor\n */\nexport const isMLTensorSupportedType = (type: Tensor.Type): type is Tensor.MLTensorDataTypes =>\n  type === 'float32' ||\n  type === 'float16' ||\n  type === 'int32' ||\n  type === 'int64' ||\n  type === 'uint32' ||\n  type === 'uint64' ||\n  type === 'int8' ||\n  type === 'uint8' ||\n  type === 'bool';\n\n/**\n * Map string data location to integer value\n */\nexport const dataLocationStringToEnum = (location: Tensor.DataLocation): number => {\n  switch (location) {\n    case 'none':\n      return 0;\n    case 'cpu':\n      return 1;\n    case 'cpu-pinned':\n      return 2;\n    case 'texture':\n      return 3;\n    case 'gpu-buffer':\n      return 4;\n    case 'ml-tensor':\n      return 5;\n    default:\n      throw new Error(`unsupported data location: ${location}`);\n  }\n};\n\n/**\n * Map integer data location to string value\n */\nexport const dataLocationEnumToString = (location: number): Tensor.DataLocation | undefined =>\n  (['none', 'cpu', 'cpu-pinned', 'texture', 'gpu-buffer', 'ml-tensor'] as const)[location];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { isNode } from './wasm-utils-env';\n\n/**\n * Load a file into a Uint8Array.\n *\n * @param file - the file to load. Can be a URL/path, a Blob, an ArrayBuffer, or a Uint8Array.\n * @returns a Uint8Array containing the file data.\n */\nexport const loadFile = async (file: string | Blob | ArrayBufferLike | Uint8Array): Promise<Uint8Array> => {\n  if (typeof file === 'string') {\n    if (isNode) {\n      // load file into ArrayBuffer in Node.js\n      try {\n        const { readFile } = require('node:fs/promises');\n        return new Uint8Array(await readFile(file));\n      } catch (e) {\n        if (e.code === 'ERR_FS_FILE_TOO_LARGE') {\n          // file is too large, use fs.createReadStream instead\n          const { createReadStream } = require('node:fs');\n          const stream = createReadStream(file);\n          const chunks: Uint8Array[] = [];\n          for await (const chunk of stream) {\n            chunks.push(chunk);\n          }\n          return new Uint8Array(Buffer.concat(chunks));\n        }\n        throw e;\n      }\n    } else {\n      // load file into ArrayBuffer in browsers\n      const response = await fetch(file);\n      if (!response.ok) {\n        throw new Error(`failed to load external data file: ${file}`);\n      }\n      const contentLengthHeader = response.headers.get('Content-Length');\n      const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;\n      if (fileSize < 1073741824 /* 1GB */) {\n        // when Content-Length header is not set, we cannot determine the file size. We assume it is small enough to\n        // load into memory.\n        return new Uint8Array(await response.arrayBuffer());\n      } else {\n        // file is too large, use stream instead\n        if (!response.body) {\n          throw new Error(`failed to load external data file: ${file}, no response body.`);\n        }\n        const reader = response.body.getReader();\n\n        let buffer;\n        try {\n          // try to create ArrayBuffer directly\n          buffer = new ArrayBuffer(fileSize);\n        } catch (e) {\n          if (e instanceof RangeError) {\n            // use WebAssembly Memory to allocate larger ArrayBuffer\n            const pages = Math.ceil(fileSize / 65536);\n            buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;\n          } else {\n            throw e;\n          }\n        }\n\n        let offset = 0;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            break;\n          }\n          const chunkSize = value.byteLength;\n          const chunk = new Uint8Array(buffer, offset, chunkSize);\n          chunk.set(value);\n          offset += chunkSize;\n        }\n        return new Uint8Array(buffer, 0, fileSize);\n      }\n    }\n  } else if (file instanceof Blob) {\n    return new Uint8Array(await file.arrayBuffer());\n  } else if (file instanceof Uint8Array) {\n    return file;\n  } else {\n    return new Uint8Array(file);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// WebNN API currently does not have a TypeScript definition file. This file is a workaround with types generated from\n// WebNN API specification.\n// https://github.com/webmachinelearning/webnn/issues/677\n/// <reference path=\"jsep/webnn/webnn.d.ts\" />\n\nimport { Env, InferenceSession, Tensor } from 'onnxruntime-common';\n\nimport {\n  SerializableInternalBuffer,\n  SerializableSessionMetadata,\n  SerializableTensorMetadata,\n  TensorMetadata,\n} from './proxy-messages';\nimport { setRunOptions } from './run-options';\nimport { setSessionOptions } from './session-options';\nimport {\n  calculateTensorSizeInBytes,\n  dataLocationStringToEnum,\n  isGpuBufferSupportedType,\n  isMLTensorSupportedType,\n  logLevelStringToEnum,\n  tensorDataTypeEnumToString,\n  tensorDataTypeStringToEnum,\n  tensorTypeToTypedArrayConstructor,\n} from './wasm-common';\nimport { getInstance } from './wasm-factory';\nimport { allocWasmString, checkLastError } from './wasm-utils';\nimport { loadFile } from './wasm-utils-load-file';\n\n// #region Initializations\n\n/**\n * There are 4 different \"initialization\" steps for ORT. They happen in different places and different time.\n *\n * 1. JavaScript initialization for onnxruntime-common and onnxruntime-web.\n *    This is the first initialization step. In this step, onnxruntime-web calls onnxruntime-common's registerBackend()\n * function multiple times to register all the available backends. The backend registration is very fast. It only\n * registers the backend name with the uninitialized backend object. No heavy initialization is done in this step.\n *    Refer to web/lib/index.ts for the backend registration.\n *\n * 2. WebAssembly artifact initialization.\n *    This happens when any registered wasm backend is used for the first time (ie. `ort.InferenceSession.create()` is\n * called). In this step, onnxruntime-web does the followings:\n *     - create a proxy worker and make sure the proxy worker is ready to receive messages, if proxy is enabled.\n *     - perform feature detection, locate correct WebAssembly artifact path and call the Emscripten generated\n * JavaScript code to initialize the WebAssembly runtime.\n *         - if proxy is enabled, this step happens in the proxy worker using message 'init-wasm'.\n *         - downloading the 'ort-wasm{...}.wasm' file is done in this step.\n *         - if multi-thread is enabled, one or more webworker will be created to initialize the PThread threadpool.\n *\n * 3. ORT environment initialization.\n *    This happens after step 2. In this step, onnxruntime-web performs ONNX Runtime environment initialization.\n * Function `_OrtInit()` is called in this step.\n *     - if proxy is enabled, this step happens in the proxy worker using message 'init-ort'.\n *     - logging level (ort.env.logLevel) and thread number (ort.env.wasm.numThreads) are set in this step.\n *\n * 4. Session initialization.\n *    This happens when `ort.InferenceSession.create()` is called. Unlike the first 3 steps (they only called once),\n * this step will be done for each session. In this step, onnxruntime-web does the followings:\n *    If the parameter is a URL:\n *    - download the model data from the URL.\n *    - copy the model data to the WASM heap. (proxy: 'copy-from')\n *    - dereference the model buffer. This step allows the original ArrayBuffer to be garbage collected.\n *    - call `_OrtCreateSession()` to create the session. (proxy: 'create')\n *\n *    If the parameter is a Uint8Array object:\n *    - copy the model data to the WASM heap. (proxy: 'copy-from')\n *    - call `_OrtCreateSession()` to create the session. (proxy: 'create')\n *\n *\n */\n\n/**\n * initialize ORT environment.\n *\n * @param numThreads SetGlobalIntraOpNumThreads(numThreads)\n * @param loggingLevel CreateEnv(static_cast<OrtLoggingLevel>(logging_level))\n */\nconst initOrt = (numThreads: number, loggingLevel: number): void => {\n  const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);\n  if (errorCode !== 0) {\n    checkLastError(\"Can't initialize onnxruntime.\");\n  }\n};\n\n/**\n * initialize runtime environment.\n * @param env passed in the environment config object.\n */\nexport const initRuntime = async (env: Env): Promise<void> => {\n  // init ORT\n  initOrt(env.wasm.numThreads!, logLevelStringToEnum(env.logLevel));\n};\n\n/**\n * perform EP specific initialization.\n *\n * @param env\n * @param epName\n */\nexport const initEp = async (env: Env, epName: string): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_JSEP) {\n    // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\n    const initJsep = require('./jsep/init').init;\n\n    if (epName === 'webgpu') {\n      // perform WebGPU availability check\n      if (typeof navigator === 'undefined' || !navigator.gpu) {\n        throw new Error('WebGPU is not supported in current environment');\n      }\n\n      let adapter = env.webgpu.adapter as GPUAdapter | null;\n      if (!adapter) {\n        // if adapter is not set, request a new adapter.\n        const powerPreference = env.webgpu.powerPreference;\n        if (\n          powerPreference !== undefined &&\n          powerPreference !== 'low-power' &&\n          powerPreference !== 'high-performance'\n        ) {\n          throw new Error(`Invalid powerPreference setting: \"${powerPreference}\"`);\n        }\n        const forceFallbackAdapter = env.webgpu.forceFallbackAdapter;\n        if (forceFallbackAdapter !== undefined && typeof forceFallbackAdapter !== 'boolean') {\n          throw new Error(`Invalid forceFallbackAdapter setting: \"${forceFallbackAdapter}\"`);\n        }\n        adapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });\n        if (!adapter) {\n          throw new Error(\n            'Failed to get GPU adapter. ' +\n              'You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.',\n          );\n        }\n      } else {\n        // if adapter is set, validate it.\n        if (\n          typeof adapter.limits !== 'object' ||\n          typeof adapter.features !== 'object' ||\n          typeof adapter.requestDevice !== 'function'\n        ) {\n          throw new Error('Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.');\n        }\n      }\n\n      await initJsep('webgpu', getInstance(), env, adapter);\n    }\n    if (epName === 'webnn') {\n      // perform WebNN availability check\n      if (typeof navigator === 'undefined' || !(navigator as unknown as { ml: unknown }).ml) {\n        throw new Error('WebNN is not supported in current environment');\n      }\n\n      await initJsep('webnn', getInstance(), env);\n    }\n  }\n};\n\n// #endregion Initializations\n\n/**\n * valid data locations for input/output tensors.\n */\ntype SupportedTensorDataLocationForInputOutput = 'cpu' | 'cpu-pinned' | 'gpu-buffer' | 'ml-tensor';\n\ntype IOBindingState = {\n  /**\n   * the handle of IO binding.\n   */\n  readonly handle: number;\n\n  /**\n   * the preferred location for each output tensor.\n   *\n   * value is one of 'cpu', 'cpu-pinned', 'gpu-buffer', 'ml-tensor'.\n   */\n  readonly outputPreferredLocations: readonly SupportedTensorDataLocationForInputOutput[];\n\n  /**\n   * enum value of the preferred location for each output tensor.\n   */\n  readonly outputPreferredLocationsEncoded: readonly number[];\n};\n\n/**\n *  tuple elements are: InferenceSession ID; inputNamesUTF8Encoded; outputNamesUTF8Encoded; bindingState\n */\ntype SessionMetadata = [\n  inferenceSessionId: number,\n  inputNamesUTF8Encoded: number[],\n  outputNamesUTF8Encoded: number[],\n  bindingState: IOBindingState | null,\n  enableGraphCapture: boolean,\n  inputOutputBound: boolean,\n];\n\nconst activeSessions = new Map<number, SessionMetadata>();\n\n/**\n * get the input/output count of the session.\n * @param sessionHandle the handle representing the session. should be non-zero.\n * @returns a tuple including 2 numbers, representing the input count and output count.\n */\nconst getSessionInputOutputCount = (sessionHandle: number): [number, number] => {\n  const wasm = getInstance();\n  const stack = wasm.stackSave();\n  try {\n    const dataOffset = wasm.stackAlloc(8);\n    const errorCode = wasm._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);\n    if (errorCode !== 0) {\n      checkLastError(\"Can't get session input/output count.\");\n    }\n    return [wasm.HEAP32[dataOffset / 4], wasm.HEAP32[dataOffset / 4 + 1]];\n  } finally {\n    wasm.stackRestore(stack);\n  }\n};\n\n/**\n * allocate the memory and memcpy the external buffer.\n *\n * @param model - the external buffer containing the model data. Must not be the same buffer as the WASM heap.\n * @returns a 2-elements tuple - the pointer and size of the allocated buffer\n */\nexport const copyFromExternalBuffer = (model: Uint8Array): [number, number] => {\n  const wasm = getInstance();\n  const modelDataOffset = wasm._malloc(model.byteLength);\n  if (modelDataOffset === 0) {\n    throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);\n  }\n  wasm.HEAPU8.set(model, modelDataOffset);\n  return [modelDataOffset, model.byteLength];\n};\n\n/**\n * create an inference session from a model data buffer.\n *\n * @param modelData - either a Uint8Array object representing the model data, or a 2-elements tuple containing the\n *     pointer and size of the model data buffer.\n * @param options an optional session options object.\n * @returns a 3-elements tuple containing [session handle, input names, output names]\n */\nexport const createSession = async (\n  modelData: Uint8Array | SerializableInternalBuffer,\n  options?: InferenceSession.SessionOptions,\n): Promise<SerializableSessionMetadata> => {\n  let modelDataOffset: number, modelDataLength: number;\n  const wasm = getInstance();\n\n  if (Array.isArray(modelData)) {\n    // if model data is an array, it must be a 2-elements tuple containing the pointer and size of the model data\n    [modelDataOffset, modelDataLength] = modelData;\n  } else if (modelData.buffer === wasm.HEAPU8.buffer) {\n    // if model data uses the same buffer as the WASM heap, we don't need to copy it.\n    [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];\n  } else {\n    // otherwise, copy the model data to the WASM heap.\n    [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);\n  }\n\n  let sessionHandle = 0;\n  let sessionOptionsHandle = 0;\n  let ioBindingHandle = 0;\n  let allocs: number[] = [];\n  const inputNamesUTF8Encoded = [];\n  const outputNamesUTF8Encoded = [];\n\n  try {\n    [sessionOptionsHandle, allocs] = setSessionOptions(options);\n\n    if (options?.externalData && wasm.mountExternalData) {\n      const loadingPromises = [];\n      for (const file of options.externalData) {\n        const path = typeof file === 'string' ? file : file.path;\n        loadingPromises.push(\n          loadFile(typeof file === 'string' ? file : file.data).then((data) => {\n            wasm.mountExternalData!(path, data);\n          }),\n        );\n      }\n\n      // wait for all external data files to be loaded\n      await Promise.all(loadingPromises);\n    }\n\n    for (const provider of options?.executionProviders ?? []) {\n      const providerName = typeof provider === 'string' ? provider : provider.name;\n      if (providerName === 'webnn') {\n        wasm.shouldTransferToMLTensor = false;\n        if (wasm.currentContext) {\n          throw new Error('WebNN execution provider is already set.');\n        }\n        if (typeof provider !== 'string') {\n          const webnnOptions = provider as InferenceSession.WebNNExecutionProviderOption;\n          const context = (webnnOptions as InferenceSession.WebNNOptionsWithMLContext)?.context;\n          const gpuDevice = (webnnOptions as InferenceSession.WebNNOptionsWebGpu)?.gpuDevice;\n          const deviceType = (webnnOptions as InferenceSession.WebNNContextOptions)?.deviceType;\n          const numThreads = (webnnOptions as InferenceSession.WebNNContextOptions)?.numThreads;\n          const powerPreference = (webnnOptions as InferenceSession.WebNNContextOptions)?.powerPreference;\n          if (context) {\n            wasm.currentContext = context as MLContext;\n          } else if (gpuDevice) {\n            wasm.currentContext = await navigator.ml.createContext(gpuDevice);\n          } else {\n            wasm.currentContext = await navigator.ml.createContext({ deviceType, numThreads, powerPreference });\n          }\n        } else {\n          wasm.currentContext = await navigator.ml.createContext();\n        }\n        break;\n      }\n    }\n\n    sessionHandle = await wasm._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);\n    if (sessionHandle === 0) {\n      checkLastError(\"Can't create a session.\");\n    }\n\n    // clear current MLContext after session creation\n    if (wasm.currentContext) {\n      wasm.jsepRegisterMLContext!(sessionHandle, wasm.currentContext);\n      wasm.currentContext = undefined;\n      wasm.shouldTransferToMLTensor = true;\n    }\n\n    const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);\n\n    const enableGraphCapture = !!options?.enableGraphCapture;\n\n    const inputNames = [];\n    const outputNames = [];\n    const outputPreferredLocations: SupportedTensorDataLocationForInputOutput[] = [];\n    for (let i = 0; i < inputCount; i++) {\n      const name = wasm._OrtGetInputName(sessionHandle, i);\n      if (name === 0) {\n        checkLastError(\"Can't get an input name.\");\n      }\n      inputNamesUTF8Encoded.push(name);\n      inputNames.push(wasm.UTF8ToString(name));\n    }\n    for (let i = 0; i < outputCount; i++) {\n      const name = wasm._OrtGetOutputName(sessionHandle, i);\n      if (name === 0) {\n        checkLastError(\"Can't get an output name.\");\n      }\n      outputNamesUTF8Encoded.push(name);\n      const nameString = wasm.UTF8ToString(name);\n      outputNames.push(nameString);\n\n      if (!BUILD_DEFS.DISABLE_JSEP) {\n        if (enableGraphCapture && options?.preferredOutputLocation === undefined) {\n          outputPreferredLocations.push('gpu-buffer');\n          continue;\n        }\n        const location =\n          typeof options?.preferredOutputLocation === 'string'\n            ? options.preferredOutputLocation\n            : (options?.preferredOutputLocation?.[nameString] ?? 'cpu');\n        if (location !== 'cpu' && location !== 'cpu-pinned' && location !== 'gpu-buffer' && location !== 'ml-tensor') {\n          throw new Error(`Not supported preferred output location: ${location}.`);\n        }\n        if (enableGraphCapture && location !== 'gpu-buffer') {\n          throw new Error(\n            `Not supported preferred output location: ${location}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`,\n          );\n        }\n        outputPreferredLocations.push(location);\n      }\n    }\n\n    // use IO binding only when at least one output is preferred to be on GPU.\n    let bindingState: IOBindingState | null = null;\n    if (!BUILD_DEFS.DISABLE_JSEP && outputPreferredLocations.some((l) => l === 'gpu-buffer' || l === 'ml-tensor')) {\n      ioBindingHandle = wasm._OrtCreateBinding(sessionHandle);\n      if (ioBindingHandle === 0) {\n        checkLastError(\"Can't create IO binding.\");\n      }\n\n      bindingState = {\n        handle: ioBindingHandle,\n        outputPreferredLocations,\n        outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => dataLocationStringToEnum(l)),\n      };\n    }\n\n    activeSessions.set(sessionHandle, [\n      sessionHandle,\n      inputNamesUTF8Encoded,\n      outputNamesUTF8Encoded,\n      bindingState,\n      enableGraphCapture,\n      false,\n    ]);\n    return [sessionHandle, inputNames, outputNames];\n  } catch (e) {\n    inputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\n    outputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\n\n    if (ioBindingHandle !== 0) {\n      wasm._OrtReleaseBinding(ioBindingHandle);\n    }\n\n    if (sessionHandle !== 0) {\n      wasm._OrtReleaseSession(sessionHandle);\n    }\n    throw e;\n  } finally {\n    wasm._free(modelDataOffset);\n    if (sessionOptionsHandle !== 0) {\n      wasm._OrtReleaseSessionOptions(sessionOptionsHandle);\n    }\n    allocs.forEach((alloc) => wasm._free(alloc));\n\n    // unmount external data if necessary\n    wasm.unmountExternalData?.();\n  }\n};\n\nexport const releaseSession = (sessionId: number): void => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error(`cannot release session. invalid session id: ${sessionId}`);\n  }\n  const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;\n\n  if (ioBindingState) {\n    if (enableGraphCapture) {\n      wasm._OrtClearBoundOutputs(ioBindingState.handle);\n    }\n    wasm._OrtReleaseBinding(ioBindingState.handle);\n  }\n\n  wasm.jsepOnReleaseSession?.(sessionId);\n\n  inputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\n  outputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\n  wasm._OrtReleaseSession(sessionHandle);\n  activeSessions.delete(sessionId);\n};\n\nexport const prepareInputOutputTensor = (\n  tensor: TensorMetadata | null,\n  tensorHandles: number[],\n  allocs: number[],\n  sessionId: number,\n  index: number,\n  enableGraphCapture = false,\n): void => {\n  if (!tensor) {\n    tensorHandles.push(0);\n    return;\n  }\n\n  const wasm = getInstance();\n\n  const dataType = tensor[0];\n  const dims = tensor[1];\n  const location = tensor[3];\n\n  let rawData: number;\n  let dataByteLength: number;\n\n  if (dataType === 'string' && (location === 'gpu-buffer' || location === 'ml-tensor')) {\n    throw new Error('String tensor is not supported on GPU.');\n  }\n\n  if (enableGraphCapture && location !== 'gpu-buffer') {\n    throw new Error(\n      `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`,\n    );\n  }\n\n  if (location === 'gpu-buffer') {\n    const gpuBuffer = tensor[2].gpuBuffer as GPUBuffer;\n    dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims)!;\n\n    const registerBuffer = wasm.jsepRegisterBuffer;\n    if (!registerBuffer) {\n      throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');\n    }\n    rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);\n  } else if (location === 'ml-tensor') {\n    const mlTensor = tensor[2].mlTensor as MLTensor;\n    dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims)!;\n\n    const registerMLTensor = wasm.jsepRegisterMLTensor;\n    if (!registerMLTensor) {\n      throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');\n    }\n    rawData = registerMLTensor(mlTensor, tensorDataTypeStringToEnum(dataType), dims);\n  } else {\n    const data = tensor[2];\n\n    if (Array.isArray(data)) {\n      // string tensor\n      dataByteLength = 4 * data.length;\n      rawData = wasm._malloc(dataByteLength);\n      allocs.push(rawData);\n      let dataIndex = rawData / 4;\n      for (let i = 0; i < data.length; i++) {\n        if (typeof data[i] !== 'string') {\n          throw new TypeError(`tensor data at index ${i} is not a string`);\n        }\n        wasm.HEAPU32[dataIndex++] = allocWasmString(data[i], allocs);\n      }\n    } else {\n      dataByteLength = data.byteLength;\n      rawData = wasm._malloc(dataByteLength);\n      allocs.push(rawData);\n      wasm.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);\n    }\n  }\n\n  const stack = wasm.stackSave();\n  const dimsOffset = wasm.stackAlloc(4 * dims.length);\n  try {\n    let dimIndex = dimsOffset / 4;\n    dims.forEach((d) => (wasm.HEAP32[dimIndex++] = d));\n    const tensor = wasm._OrtCreateTensor(\n      tensorDataTypeStringToEnum(dataType),\n      rawData,\n      dataByteLength,\n      dimsOffset,\n      dims.length,\n      dataLocationStringToEnum(location),\n    );\n    if (tensor === 0) {\n      checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);\n    }\n    tensorHandles.push(tensor);\n  } finally {\n    wasm.stackRestore(stack);\n  }\n};\n\n/**\n * perform inference run\n */\nexport const run = async (\n  sessionId: number,\n  inputIndices: number[],\n  inputTensors: TensorMetadata[],\n  outputIndices: number[],\n  outputTensors: Array<TensorMetadata | null>,\n  options: InferenceSession.RunOptions,\n): Promise<TensorMetadata[]> => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error(`cannot run inference. invalid session id: ${sessionId}`);\n  }\n  const sessionHandle = session[0];\n  const inputNamesUTF8Encoded = session[1];\n  const outputNamesUTF8Encoded = session[2];\n  const ioBindingState = session[3];\n  const enableGraphCapture = session[4];\n  const inputOutputBound = session[5];\n\n  const inputCount = inputIndices.length;\n  const outputCount = outputIndices.length;\n\n  let runOptionsHandle = 0;\n  let runOptionsAllocs: number[] = [];\n\n  const inputTensorHandles: number[] = [];\n  const outputTensorHandles: number[] = [];\n  const inputOutputAllocs: number[] = [];\n\n  const beforeRunStack = wasm.stackSave();\n  const inputValuesOffset = wasm.stackAlloc(inputCount * 4);\n  const inputNamesOffset = wasm.stackAlloc(inputCount * 4);\n  const outputValuesOffset = wasm.stackAlloc(outputCount * 4);\n  const outputNamesOffset = wasm.stackAlloc(outputCount * 4);\n\n  try {\n    // WebNN backend needs the active session to check MLTensors with the current context.\n    wasm.jsepOnRunStart?.(sessionHandle);\n\n    [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);\n\n    // create input tensors\n    for (let i = 0; i < inputCount; i++) {\n      prepareInputOutputTensor(\n        inputTensors[i],\n        inputTensorHandles,\n        inputOutputAllocs,\n        sessionId,\n        inputIndices[i],\n        enableGraphCapture,\n      );\n    }\n\n    // create output tensors\n    for (let i = 0; i < outputCount; i++) {\n      prepareInputOutputTensor(\n        outputTensors[i],\n        outputTensorHandles,\n        inputOutputAllocs,\n        sessionId,\n        inputCount + outputIndices[i],\n        enableGraphCapture,\n      );\n    }\n\n    let inputValuesIndex = inputValuesOffset / 4;\n    let inputNamesIndex = inputNamesOffset / 4;\n    let outputValuesIndex = outputValuesOffset / 4;\n    let outputNamesIndex = outputNamesOffset / 4;\n    for (let i = 0; i < inputCount; i++) {\n      wasm.HEAPU32[inputValuesIndex++] = inputTensorHandles[i];\n      wasm.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];\n    }\n    for (let i = 0; i < outputCount; i++) {\n      wasm.HEAPU32[outputValuesIndex++] = outputTensorHandles[i];\n      wasm.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];\n    }\n\n    if (!BUILD_DEFS.DISABLE_JSEP && ioBindingState && !inputOutputBound) {\n      const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;\n\n      if (inputNamesUTF8Encoded.length !== inputCount) {\n        throw new Error(\n          `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`,\n        );\n      }\n\n      // process inputs\n      for (let i = 0; i < inputCount; i++) {\n        const index = inputIndices[i];\n        const errorCode = await wasm._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);\n        if (errorCode !== 0) {\n          checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);\n        }\n      }\n\n      // process pre-allocated outputs\n      for (let i = 0; i < outputCount; i++) {\n        const index = outputIndices[i];\n        const location = outputTensors[i]?.[3]; // undefined means output is not pre-allocated.\n\n        if (location) {\n          // output is pre-allocated. bind the tensor.\n          const errorCode = wasm._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);\n          if (errorCode !== 0) {\n            checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);\n          }\n        } else {\n          // output is not pre-allocated. reset preferred location.\n          const errorCode = wasm._OrtBindOutput(\n            handle,\n            outputNamesUTF8Encoded[index],\n            0,\n            outputPreferredLocationsEncoded[index],\n          );\n          if (errorCode !== 0) {\n            checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);\n          }\n        }\n      }\n      activeSessions.set(sessionId, [\n        sessionHandle,\n        inputNamesUTF8Encoded,\n        outputNamesUTF8Encoded,\n        ioBindingState,\n        enableGraphCapture,\n        true,\n      ]);\n    }\n\n    let errorCode: number;\n    if (!BUILD_DEFS.DISABLE_JSEP && ioBindingState) {\n      errorCode = await wasm._OrtRunWithBinding(\n        sessionHandle,\n        ioBindingState.handle,\n        outputCount,\n        outputValuesOffset,\n        runOptionsHandle,\n      );\n    } else {\n      errorCode = await wasm._OrtRun(\n        sessionHandle,\n        inputNamesOffset,\n        inputValuesOffset,\n        inputCount,\n        outputNamesOffset,\n        outputCount,\n        outputValuesOffset,\n        runOptionsHandle,\n      );\n    }\n\n    if (errorCode !== 0) {\n      checkLastError('failed to call OrtRun().');\n    }\n\n    const output: TensorMetadata[] = [];\n\n    for (let i = 0; i < outputCount; i++) {\n      const tensor = wasm.HEAPU32[outputValuesOffset / 4 + i];\n      if (tensor === outputTensorHandles[i]) {\n        // output tensor is pre-allocated. no need to copy data.\n        output.push(outputTensors[i]!);\n        continue;\n      }\n\n      const beforeGetTensorDataStack = wasm.stackSave();\n      // stack allocate 4 pointer value\n      const tensorDataOffset = wasm.stackAlloc(4 * 4);\n\n      let keepOutputTensor = false;\n      let type: Tensor.Type | undefined,\n        dataOffset = 0;\n      try {\n        const errorCode = wasm._OrtGetTensorData(\n          tensor,\n          tensorDataOffset,\n          tensorDataOffset + 4,\n          tensorDataOffset + 8,\n          tensorDataOffset + 12,\n        );\n        if (errorCode !== 0) {\n          checkLastError(`Can't access output tensor data on index ${i}.`);\n        }\n        let tensorDataIndex = tensorDataOffset / 4;\n        const dataType = wasm.HEAPU32[tensorDataIndex++];\n        dataOffset = wasm.HEAPU32[tensorDataIndex++];\n        const dimsOffset = wasm.HEAPU32[tensorDataIndex++];\n        const dimsLength = wasm.HEAPU32[tensorDataIndex++];\n        const dims = [];\n        for (let i = 0; i < dimsLength; i++) {\n          dims.push(wasm.HEAPU32[dimsOffset / 4 + i]);\n        }\n        wasm._OrtFree(dimsOffset);\n\n        const size = dims.reduce((a, b) => a * b, 1);\n        type = tensorDataTypeEnumToString(dataType);\n\n        const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];\n\n        if (type === 'string') {\n          if (preferredLocation === 'gpu-buffer' || preferredLocation === 'ml-tensor') {\n            throw new Error('String tensor is not supported on GPU.');\n          }\n          const stringData: string[] = [];\n          let dataIndex = dataOffset / 4;\n          for (let i = 0; i < size; i++) {\n            const offset = wasm.HEAPU32[dataIndex++];\n            const maxBytesToRead = i === size - 1 ? undefined : wasm.HEAPU32[dataIndex] - offset;\n            stringData.push(wasm.UTF8ToString(offset, maxBytesToRead));\n          }\n          output.push([type, dims, stringData, 'cpu']);\n        } else {\n          // If a certain output's preferred location is GPU but the tensor is empty, we still need to create a CPU\n          // tensor for it. There is no mapping GPU buffer for an empty tensor.\n          if (preferredLocation === 'gpu-buffer' && size > 0) {\n            const getBuffer = wasm.jsepGetBuffer;\n            if (!getBuffer) {\n              throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');\n            }\n            const gpuBuffer = getBuffer(dataOffset);\n            const bufferSize = calculateTensorSizeInBytes(dataType, size);\n            if (bufferSize === undefined || !isGpuBufferSupportedType(type)) {\n              throw new Error(`Unsupported data type: ${type}`);\n            }\n\n            // do not release the tensor right now. it will be released when user calls tensor.dispose().\n            keepOutputTensor = true;\n\n            output.push([\n              type,\n              dims,\n              {\n                gpuBuffer,\n                download: wasm.jsepCreateDownloader!(gpuBuffer, bufferSize, type),\n                dispose: () => {\n                  wasm._OrtReleaseTensor(tensor);\n                },\n              },\n              'gpu-buffer',\n            ]);\n          } else if (preferredLocation === 'ml-tensor' && size > 0) {\n            const ensureTensor = wasm.jsepEnsureTensor;\n            if (!ensureTensor) {\n              throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');\n            }\n            const tensorSize = calculateTensorSizeInBytes(dataType, size);\n            if (tensorSize === undefined || !isMLTensorSupportedType(type)) {\n              throw new Error(`Unsupported data type: ${type}`);\n            }\n\n            // If the graph has been partitioned, the output tensor may have not been created. For this reason, we use\n            // ensureTensor to get/create the MLTensor. In which case, we don't need to copy the data if a new tensor\n            // has been created.\n            const mlTensor = await ensureTensor(dataOffset, dataType, dims, false);\n\n            // do not release the tensor right now. it will be released when user calls tensor.dispose().\n            keepOutputTensor = true;\n\n            output.push([\n              type,\n              dims,\n              {\n                mlTensor,\n                download: wasm.jsepCreateMLTensorDownloader!(dataOffset, type),\n                dispose: () => {\n                  wasm.jsepReleaseTensorId!(dataOffset);\n                  wasm._OrtReleaseTensor(tensor);\n                },\n              },\n              'ml-tensor',\n            ]);\n          } else {\n            const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);\n            const data = new typedArrayConstructor(size);\n            new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(\n              wasm.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength),\n            );\n            output.push([type, dims, data, 'cpu']);\n          }\n        }\n      } finally {\n        wasm.stackRestore(beforeGetTensorDataStack);\n        if (type === 'string' && dataOffset) {\n          wasm._free(dataOffset);\n        }\n        if (!keepOutputTensor) {\n          wasm._OrtReleaseTensor(tensor);\n        }\n      }\n    }\n\n    if (ioBindingState && !enableGraphCapture) {\n      wasm._OrtClearBoundOutputs(ioBindingState.handle);\n      activeSessions.set(sessionId, [\n        sessionHandle,\n        inputNamesUTF8Encoded,\n        outputNamesUTF8Encoded,\n        ioBindingState,\n        enableGraphCapture,\n        false,\n      ]);\n    }\n    return output;\n  } finally {\n    wasm.stackRestore(beforeRunStack);\n\n    inputTensorHandles.forEach((v) => wasm._OrtReleaseTensor(v));\n    outputTensorHandles.forEach((v) => wasm._OrtReleaseTensor(v));\n    inputOutputAllocs.forEach((p) => wasm._free(p));\n\n    if (runOptionsHandle !== 0) {\n      wasm._OrtReleaseRunOptions(runOptionsHandle);\n    }\n    runOptionsAllocs.forEach((p) => wasm._free(p));\n  }\n};\n\n/**\n * end profiling\n */\nexport const endProfiling = (sessionId: number): void => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error('invalid session id');\n  }\n  const sessionHandle = session[0];\n\n  // profile file name is not used yet, but it must be freed.\n  const profileFileName = wasm._OrtEndProfiling(sessionHandle);\n  if (profileFileName === 0) {\n    checkLastError(\"Can't get an profile file name.\");\n  }\n  wasm._OrtFree(profileFileName);\n};\n\nexport const extractTransferableBuffers = (tensors: readonly SerializableTensorMetadata[]): ArrayBufferLike[] => {\n  const buffers: ArrayBufferLike[] = [];\n  for (const tensor of tensors) {\n    const data = tensor[2];\n    if (!Array.isArray(data) && 'buffer' in data) {\n      buffers.push(data.buffer);\n    }\n  }\n  return buffers;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { env, InferenceSession } from 'onnxruntime-common';\n\nimport {\n  OrtWasmMessage,\n  SerializableInternalBuffer,\n  SerializableSessionMetadata,\n  SerializableTensorMetadata,\n  TensorMetadata,\n} from './proxy-messages';\nimport * as core from './wasm-core-impl';\nimport { initializeWebAssembly } from './wasm-factory';\nimport { importProxyWorker } from './wasm-utils-import';\n\nconst isProxy = (): boolean => !!env.wasm.proxy && typeof document !== 'undefined';\nlet proxyWorker: Worker | undefined;\nlet initializing = false;\nlet initialized = false;\nlet aborted = false;\nlet temporaryObjectUrl: string | undefined;\n\ntype PromiseCallbacks<T = void> = [resolve: (result: T) => void, reject: (reason: unknown) => void];\nlet initWasmCallbacks: PromiseCallbacks;\nconst queuedCallbacks: Map<OrtWasmMessage['type'], Array<PromiseCallbacks<unknown>>> = new Map();\n\nconst enqueueCallbacks = (type: OrtWasmMessage['type'], callbacks: PromiseCallbacks<unknown>): void => {\n  const queue = queuedCallbacks.get(type);\n  if (queue) {\n    queue.push(callbacks);\n  } else {\n    queuedCallbacks.set(type, [callbacks]);\n  }\n};\n\nconst ensureWorker = (): void => {\n  if (initializing || !initialized || aborted || !proxyWorker) {\n    throw new Error('worker not ready');\n  }\n};\n\nconst onProxyWorkerMessage = (ev: MessageEvent<OrtWasmMessage>): void => {\n  switch (ev.data.type) {\n    case 'init-wasm':\n      initializing = false;\n      if (ev.data.err) {\n        aborted = true;\n        initWasmCallbacks[1](ev.data.err);\n      } else {\n        initialized = true;\n        initWasmCallbacks[0]();\n      }\n      if (temporaryObjectUrl) {\n        URL.revokeObjectURL(temporaryObjectUrl);\n        temporaryObjectUrl = undefined;\n      }\n      break;\n    case 'init-ep':\n    case 'copy-from':\n    case 'create':\n    case 'release':\n    case 'run':\n    case 'end-profiling': {\n      const callbacks = queuedCallbacks.get(ev.data.type)!;\n      if (ev.data.err) {\n        callbacks.shift()![1](ev.data.err);\n      } else {\n        callbacks.shift()![0](ev.data.out!);\n      }\n      break;\n    }\n    default:\n  }\n};\n\nexport const initializeWebAssemblyAndOrtRuntime = async (): Promise<void> => {\n  if (initialized) {\n    return;\n  }\n  if (initializing) {\n    throw new Error(\"multiple calls to 'initWasm()' detected.\");\n  }\n  if (aborted) {\n    throw new Error(\"previous call to 'initWasm()' failed.\");\n  }\n\n  initializing = true;\n\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    return new Promise<void>((resolve, reject) => {\n      proxyWorker?.terminate();\n\n      void importProxyWorker().then(([objectUrl, worker]) => {\n        try {\n          proxyWorker = worker;\n          proxyWorker.onerror = (ev: ErrorEvent) => reject(ev);\n          proxyWorker.onmessage = onProxyWorkerMessage;\n          initWasmCallbacks = [resolve, reject];\n          const message: OrtWasmMessage = { type: 'init-wasm', in: env };\n          proxyWorker.postMessage(message);\n          temporaryObjectUrl = objectUrl;\n        } catch (e) {\n          reject(e);\n        }\n      }, reject);\n    });\n  } else {\n    try {\n      await initializeWebAssembly(env.wasm);\n      await core.initRuntime(env);\n      initialized = true;\n    } catch (e) {\n      aborted = true;\n      throw e;\n    } finally {\n      initializing = false;\n    }\n  }\n};\n\nexport const initializeOrtEp = async (epName: string): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      enqueueCallbacks('init-ep', [resolve, reject]);\n      const message: OrtWasmMessage = { type: 'init-ep', in: { epName, env } };\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    await core.initEp(env, epName);\n  }\n};\n\nexport const copyFromExternalBuffer = async (buffer: Uint8Array): Promise<SerializableInternalBuffer> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<SerializableInternalBuffer>((resolve, reject) => {\n      enqueueCallbacks('copy-from', [resolve, reject]);\n      const message: OrtWasmMessage = { type: 'copy-from', in: { buffer } };\n      proxyWorker!.postMessage(message, [buffer.buffer]);\n    });\n  } else {\n    return core.copyFromExternalBuffer(buffer);\n  }\n};\n\nexport const createSession = async (\n  model: SerializableInternalBuffer | Uint8Array,\n  options?: InferenceSession.SessionOptions,\n): Promise<SerializableSessionMetadata> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    // check unsupported options\n    if (options?.preferredOutputLocation) {\n      throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');\n    }\n    ensureWorker();\n    return new Promise<SerializableSessionMetadata>((resolve, reject) => {\n      enqueueCallbacks('create', [resolve, reject]);\n      const message: OrtWasmMessage = { type: 'create', in: { model, options: { ...options } } };\n      const transferable: Transferable[] = [];\n      if (model instanceof Uint8Array) {\n        transferable.push(model.buffer);\n      }\n      proxyWorker!.postMessage(message, transferable);\n    });\n  } else {\n    return core.createSession(model, options);\n  }\n};\n\nexport const releaseSession = async (sessionId: number): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      enqueueCallbacks('release', [resolve, reject]);\n      const message: OrtWasmMessage = { type: 'release', in: sessionId };\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    core.releaseSession(sessionId);\n  }\n};\n\nexport const run = async (\n  sessionId: number,\n  inputIndices: number[],\n  inputs: TensorMetadata[],\n  outputIndices: number[],\n  outputs: Array<TensorMetadata | null>,\n  options: InferenceSession.RunOptions,\n): Promise<TensorMetadata[]> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    // check inputs location\n    if (inputs.some((t) => t[3] !== 'cpu')) {\n      throw new Error('input tensor on GPU is not supported for proxy.');\n    }\n    // check outputs location\n    if (outputs.some((t) => t)) {\n      throw new Error('pre-allocated output tensor is not supported for proxy.');\n    }\n    ensureWorker();\n    return new Promise<SerializableTensorMetadata[]>((resolve, reject) => {\n      enqueueCallbacks('run', [resolve, reject]);\n      const serializableInputs = inputs as SerializableTensorMetadata[]; // every input is on CPU.\n      const message: OrtWasmMessage = {\n        type: 'run',\n        in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options },\n      };\n      proxyWorker!.postMessage(message, core.extractTransferableBuffers(serializableInputs));\n    });\n  } else {\n    return core.run(sessionId, inputIndices, inputs, outputIndices, outputs, options);\n  }\n};\n\nexport const endProfiling = async (sessionId: number): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      enqueueCallbacks('end-profiling', [resolve, reject]);\n      const message: OrtWasmMessage = { type: 'end-profiling', in: sessionId };\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    core.endProfiling(sessionId);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {\n  InferenceSession,\n  InferenceSessionHandler,\n  SessionHandler,\n  Tensor,\n  TRACE_FUNC_BEGIN,\n  TRACE_FUNC_END,\n} from 'onnxruntime-common';\n\nimport { SerializableInternalBuffer, TensorMetadata } from './proxy-messages';\nimport { copyFromExternalBuffer, createSession, endProfiling, releaseSession, run } from './proxy-wrapper';\nimport { isGpuBufferSupportedType, isMLTensorSupportedType } from './wasm-common';\nimport { isNode } from './wasm-utils-env';\nimport { loadFile } from './wasm-utils-load-file';\n\nexport const encodeTensorMetadata = (tensor: Tensor, getName: () => string): TensorMetadata => {\n  switch (tensor.location) {\n    case 'cpu':\n      return [tensor.type, tensor.dims, tensor.data, 'cpu'];\n    case 'gpu-buffer':\n      return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, 'gpu-buffer'];\n    case 'ml-tensor':\n      return [tensor.type, tensor.dims, { mlTensor: tensor.mlTensor }, 'ml-tensor'];\n    default:\n      throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);\n  }\n};\n\nexport const decodeTensorMetadata = (tensor: TensorMetadata): Tensor => {\n  switch (tensor[3]) {\n    case 'cpu':\n      return new Tensor(tensor[0], tensor[2], tensor[1]);\n    case 'gpu-buffer': {\n      const dataType = tensor[0];\n      if (!isGpuBufferSupportedType(dataType)) {\n        throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);\n      }\n      const { gpuBuffer, download, dispose } = tensor[2];\n      return Tensor.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });\n    }\n    case 'ml-tensor': {\n      const dataType = tensor[0];\n      if (!isMLTensorSupportedType(dataType)) {\n        throw new Error(`not supported data type: ${dataType} for deserializing MLTensor tensor`);\n      }\n      const { mlTensor, download, dispose } = tensor[2];\n      return Tensor.fromMLTensor(mlTensor, { dataType, dims: tensor[1], download, dispose });\n    }\n    default:\n      throw new Error(`invalid data location: ${tensor[3]}`);\n  }\n};\n\nexport class OnnxruntimeWebAssemblySessionHandler implements InferenceSessionHandler {\n  private sessionId: number;\n\n  inputNames: string[];\n  outputNames: string[];\n\n  async fetchModelAndCopyToWasmMemory(path: string): Promise<SerializableInternalBuffer> {\n    // fetch model from url and move to wasm heap.\n    return copyFromExternalBuffer(await loadFile(path));\n  }\n\n  async loadModel(pathOrBuffer: string | Uint8Array, options?: InferenceSession.SessionOptions): Promise<void> {\n    TRACE_FUNC_BEGIN();\n    let model: Parameters<typeof createSession>[0];\n\n    if (typeof pathOrBuffer === 'string') {\n      if (isNode) {\n        // node\n        model = await loadFile(pathOrBuffer);\n      } else {\n        // browser\n        // fetch model and copy to wasm heap.\n        model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);\n      }\n    } else {\n      model = pathOrBuffer;\n    }\n\n    [this.sessionId, this.inputNames, this.outputNames] = await createSession(model, options);\n    TRACE_FUNC_END();\n  }\n\n  async dispose(): Promise<void> {\n    return releaseSession(this.sessionId);\n  }\n\n  async run(\n    feeds: SessionHandler.FeedsType,\n    fetches: SessionHandler.FetchesType,\n    options: InferenceSession.RunOptions,\n  ): Promise<SessionHandler.ReturnType> {\n    TRACE_FUNC_BEGIN();\n    const inputArray: Tensor[] = [];\n    const inputIndices: number[] = [];\n    Object.entries(feeds).forEach((kvp) => {\n      const name = kvp[0];\n      const tensor = kvp[1];\n      const index = this.inputNames.indexOf(name);\n      if (index === -1) {\n        throw new Error(`invalid input '${name}'`);\n      }\n      inputArray.push(tensor);\n      inputIndices.push(index);\n    });\n\n    const outputArray: Array<Tensor | null> = [];\n    const outputIndices: number[] = [];\n    Object.entries(fetches).forEach((kvp) => {\n      const name = kvp[0];\n      const tensor = kvp[1];\n      const index = this.outputNames.indexOf(name);\n      if (index === -1) {\n        throw new Error(`invalid output '${name}'`);\n      }\n      outputArray.push(tensor);\n      outputIndices.push(index);\n    });\n\n    const inputs = inputArray.map((t, i) =>\n      encodeTensorMetadata(t, () => `input \"${this.inputNames[inputIndices[i]]}\"`),\n    );\n    const outputs = outputArray.map((t, i) =>\n      t ? encodeTensorMetadata(t, () => `output \"${this.outputNames[outputIndices[i]]}\"`) : null,\n    );\n\n    const results = await run(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);\n\n    const resultMap: SessionHandler.ReturnType = {};\n    for (let i = 0; i < results.length; i++) {\n      resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);\n    }\n    TRACE_FUNC_END();\n    return resultMap;\n  }\n\n  startProfiling(): void {\n    // TODO: implement profiling\n  }\n\n  endProfiling(): void {\n    void endProfiling(this.sessionId);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Backend, env, InferenceSession, InferenceSessionHandler } from 'onnxruntime-common';\n\nimport { initializeOrtEp, initializeWebAssemblyAndOrtRuntime } from './wasm/proxy-wrapper';\nimport { OnnxruntimeWebAssemblySessionHandler } from './wasm/session-handler-inference';\nimport { scriptSrc } from './wasm/wasm-utils-import';\n\n/**\n * This function initializes all flags for WebAssembly.\n *\n * Those flags are accessible from `ort.env.wasm`. Users are allow to set those flags before the first inference session\n * being created, to override default value.\n */\nexport const initializeFlags = (): void => {\n  if (typeof env.wasm.initTimeout !== 'number' || env.wasm.initTimeout < 0) {\n    env.wasm.initTimeout = 0;\n  }\n\n  if (env.wasm.simd === false) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Deprecated property \"env.wasm.simd\" is set to false. ' +\n        'non-SIMD build is no longer provided, and this setting will be ignored.',\n    );\n  }\n\n  if (typeof env.wasm.proxy !== 'boolean') {\n    env.wasm.proxy = false;\n  }\n\n  if (typeof env.wasm.trace !== 'boolean') {\n    env.wasm.trace = false;\n  }\n\n  if (typeof env.wasm.numThreads !== 'number' || !Number.isInteger(env.wasm.numThreads) || env.wasm.numThreads <= 0) {\n    // The following logic only applies when `ort.env.wasm.numThreads` is not set by user. We will always honor user's\n    // setting if it is provided.\n\n    // Browser: when crossOriginIsolated is false, SharedArrayBuffer is not available so WebAssembly threads will not\n    // work. In this case, we will set numThreads to 1.\n    //\n    // There is an exception: when the browser is configured to force-enable SharedArrayBuffer (e.g. Chromuim with\n    // --enable-features=SharedArrayBuffer), it is possible that `self.crossOriginIsolated` is false and\n    // SharedArrayBuffer is available at the same time. This is usually for testing. In this case,  we will still set\n    // numThreads to 1 here. If we want to enable multi-threading in test, we should set `ort.env.wasm.numThreads` to a\n    // value greater than 1.\n    if (typeof self !== 'undefined' && !self.crossOriginIsolated) {\n      env.wasm.numThreads = 1;\n    } else {\n      const numCpuLogicalCores =\n        typeof navigator === 'undefined' ? require('node:os').cpus().length : navigator.hardwareConcurrency;\n      env.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));\n    }\n  }\n\n  if (!BUILD_DEFS.DISABLE_DYNAMIC_IMPORT) {\n    // overwrite wasm paths override if not set\n    if (env.wasm.wasmPaths === undefined && scriptSrc && scriptSrc.indexOf('blob:') !== 0) {\n      env.wasm.wasmPaths = scriptSrc.substring(0, scriptSrc.lastIndexOf('/') + 1);\n    }\n  }\n};\n\nexport class OnnxruntimeWebAssemblyBackend implements Backend {\n  /**\n   * This function initializes the WebAssembly backend.\n   *\n   * This function will be called only once for each backend name. It will be called the first time when\n   * `ort.InferenceSession.create()` is called with a registered backend name.\n   *\n   * @param backendName - the registered backend name.\n   */\n  async init(backendName: string): Promise<void> {\n    // populate wasm flags\n    initializeFlags();\n\n    // init wasm\n    await initializeWebAssemblyAndOrtRuntime();\n\n    // performe EP specific initialization\n    await initializeOrtEp(backendName);\n  }\n  createInferenceSessionHandler(\n    path: string,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSessionHandler>;\n  createInferenceSessionHandler(\n    buffer: Uint8Array,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSessionHandler>;\n  async createInferenceSessionHandler(\n    pathOrBuffer: string | Uint8Array,\n    options?: InferenceSession.SessionOptions,\n  ): Promise<InferenceSessionHandler> {\n    const handler = new OnnxruntimeWebAssemblySessionHandler();\n    await handler.loadModel(pathOrBuffer, options);\n    return Promise.resolve(handler);\n  }\n}\n\nexport const wasmBackend = new OnnxruntimeWebAssemblyBackend();\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/* eslint-disable @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports */\n\n// We use \"require\" instead of \"import\" here because import statement must be put in top level. Our current code does\n// not allow bundler to tree-shaking code as expected because some codes are treated as having side effects.\n// So we import code inside the if-clause to allow bundler remove the code safely.\n\nexport * from 'onnxruntime-common';\nimport * as ort from 'onnxruntime-common';\nexport default ort;\n\nimport { registerBackend, env } from 'onnxruntime-common';\nimport { version } from './version';\n\nif (!BUILD_DEFS.DISABLE_WEBGL) {\n  const onnxjsBackend = require('./backend-onnxjs').onnxjsBackend;\n  registerBackend('webgl', onnxjsBackend, -10);\n}\n\nif (!BUILD_DEFS.DISABLE_WASM) {\n  const wasmBackend = require('./backend-wasm').wasmBackend;\n  if (!BUILD_DEFS.DISABLE_JSEP) {\n    registerBackend('webgpu', wasmBackend, 5);\n    registerBackend('webnn', wasmBackend, 5);\n  }\n  registerBackend('cpu', wasmBackend, 10);\n  registerBackend('wasm', wasmBackend, 10);\n}\n\nObject.defineProperty(env.versions, 'web', { value: version, enumerable: true });\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// This file is generated by /js/scripts/update-version.ts\n// Do not modify file content manually.\n\nexport const version = '1.20.1';\n"],"names":["_defineProperty","e","r","t","Object","defineProperty","value","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","toPrimitive","Symbol","i","call","TypeError","String","Number","toPropertyKey","_typeof","iterator","constructor","prototype","un","ke","nr","Jd","ln","fn","O","Map","registerBackend","init","createInferenceSessionHandler","get","set","backend","priority","Error","concat","indexOf","splice","n","async","initialized","aborted","error","initPromise","executionProviders","map","u","name","s","Set","l","err","add","join","includes","console","warn","a","has","Proxy","Reflect","ts","es","rs","ns","Gt","No","wasm","webgl","webgpu","versions","common","logLevel","z","os","is","as","ss","tensorToDataURL","document","createElement","OffscreenCanvas","width","dims","height","getContext","tensorLayout","format","norm","mean","bias","f","p","d","y","T","v","S","L","data","P","A","M","fillStyle","fillRect","toDataURL","tensorToImageData","createImageData","V","Ro","us","ls","fs","cs","ps","ds","cn","bufferToTensor","_e$norm","_r$mean$","_r$bias$","tensorFormat","Float32Array","St","HTMLImageElement","ImageData","ImageBitmap","createCanvas","HTMLCanvasElement","resizedHeight","resizedWidth","drawImage","getImageData","Promise","Image","crossOrigin","src","onload","putImageData","tensorFromTexture","download","dispose","location","type","texture","tensorFromGpuBuffer","dataType","gpuBuffer","tensorFromMLTensor","mlTensor","tensorFromPinnedBuffer","Be","Sr","hs","ms","bs","Uint8Array","Int8Array","Uint16Array","Int16Array","Int32Array","Float64Array","Uint32Array","checkTypedArray","BigInt64Array","from","BigUint64Array","Float16Array","gs","ys","xs","isSafeInteger","RangeError","tensorReshape","this","dataLocation","cpuData","gpuTextureData","downloader","disposer","gpuBufferData","mlTensorData","Array","isArray","BigInt","Uint8ClampedArray","Math","ceil","size","fromImage","fromTexture","fromGpuBuffer","fromMLTensor","fromPinnedBuffer","toImageData","ensureValid","getData","isDownloading","reshape","yt","pn","Ts","ws","Fe","Ce","Go","TRACE","trace","timeStamp","TRACE_FUNC","_Error$stack","stack","split","trim","dn","vs","handler","run","outputNames","getOwnPropertyNames","inputNames","hasOwnProperty","release","create","ArrayBuffer","SharedArrayBuffer","byteLength","startProfiling","endProfiling","Yd","Is","_s","Os","Ss","As","Zd","hn","Ps","hasOptimizerModel","hasEvalModel","trainingInputNames","trainingOutputNames","evalInputNames","evalOutputNames","evalModel","optimizerModel","createTrainingSessionHandler","checkpointState","trainModel","typeNarrowingForRunStep","convertHandlerReturnTypeToMapOfTensors","lazyResetGrad","runTrainStep","runOptimizerStep","runEvalStep","getParametersSize","undefined","loadParametersBuffer","getContiguousParameters","Qd","Es","Mo","Or","InferenceSession","TRACE_FUNC_BEGIN","TRACE_FUNC_END","Tensor","TrainingSession","env","Yt","_e","eh","mn","verbose","bind","info","warning","fatal","Ar","Ls","minimalSeverity","logDateTime","Date","toISOString","logSourceLocation","th","provider","log","Uo","Vo","$s","tt","gn","yn","xn","bn","Ut","color","none","reset","setWithEnv","category","startTime","endCallback","timer","ctx","end","checkTimer","endTimer","waitForQueryAndGetTime","endTime","_started","_flushPointer","_maxNumberEvents","_flushBatchSize","_flushIntervalInMilliseconds","maxNumberEvents","flushBatchSize","flushIntervalInMilliseconds","start","_timingEvents","_flushTime","stop","logOneEvent","event","begin","then","flush","endSync","beginTimer","toFixed","started","performance","now","ks","opType","domain","rh","version","opImpl","opInit","endsWith","parseInt","substring","isNaN","Bs","Fs","mt","zo","__esModule","nh","EMPTY","isGuid","toString","validator","test","gen","createEmpty","parse","raw","random","equals","isEmpty","toJSON","RegExp","Guid","rt","low","high","unsigned","Et","__isLong__","Cs","clz32","Ne","Rs","J","Ns","zt","ye","Zt","Vs","Hs","Ms","Ct","Ws","neg","ir","Ho","Tn","min","mul","Qt","Vt","Gs","oh","Us","or","zs","Wo","D","xe","qo","WebAssembly","Instance","Module","exports","_unused","isLong","fromInt","fromNumber","fromBits","pow","fromString","fromValue","ZERO","UZERO","ONE","UONE","NEG_ONE","MAX_VALUE","MAX_UNSIGNED_VALUE","MIN_VALUE","toInt","toNumber","isZero","isNegative","eq","div","sub","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","eqz","isPositive","isOdd","isEven","notEquals","neq","ne","lessThan","comp","lt","lessThanOrEqual","lte","le","greaterThan","gt","greaterThanOrEqual","gte","ge","compare","negate","not","subtract","multiply","get_high","divide","div_u","div_s","toUnsigned","shru","shr","shl","max","floor","LN2","modulo","rem_u","rem_s","mod","rem","countLeadingZeros","clz","countTrailingZeros","ctz","and","xor","shiftLeft","shiftRight","shiftRightUnsigned","shr_u","rotateLeft","rotl","rotateRight","rotr","toSigned","toBytes","toBytesLE","toBytesBE","fromBytes","fromBytesLE","fromBytesBE","w","wn","Table","SIZEOF_SHORT","SIZEOF_INT","FILE_IDENTIFIER_LENGTH","SIZE_PREFIX_LENGTH","Encoding","UTF8_BYTES","UTF16_STRING","int32","float32","buffer","float64","isLittleEndian","Long","toFloat64","Builder","bb","ByteBuffer","allocate","space","minalign","vtable","vtable_in_use","isNested","object_start","vtables","vector_num_elems","force_defaults","clear","capacity","forceDefaults","dataBuffer","asUint8Array","bytes","subarray","position","offset","prep","growByteBuffer","pad","writeInt8","writeInt16","writeInt32","writeInt64","writeFloat32","writeFloat64","addInt8","addInt16","addInt32","addInt64","addFloat32","addFloat64","addFieldInt8","slot","addFieldInt16","addFieldInt32","addFieldInt64","addFieldFloat32","addFieldFloat64","addFieldOffset","addOffset","addFieldStruct","nested","notNested","setPosition","startObject","endObject","readInt16","finish","charCodeAt","finishSizePrefixed","requiredField","readInt32","startVector","endVector","createString","createLong","bytes_","position_","readInt8","readUint8","readUint16","readUint32","readInt64","readUint64","readFloat32","readFloat64","writeUint8","writeUint16","writeUint32","writeUint64","getBufferIdentifier","fromCharCode","__offset","__union","bb_pos","__string","__indirect","__vector","__vector_len","__has_identifier","F","Pr","AttributeType","UNDEFINED","FLOAT","INT","STRING","TENSOR","GRAPH","FLOATS","INTS","STRINGS","TENSORS","GRAPHS","SPARSE_TENSOR","SPARSE_TENSORS","fbs","experimental","DimensionValueType","UNKNOWN","VALUE","PARAM","C","TensorDataType","UINT8","INT8","UINT16","INT16","INT32","INT64","BOOL","FLOAT16","DOUBLE","UINT32","UINT64","COMPLEX64","COMPLEX128","BFLOAT16","FLOAT8E4M3FN","FLOAT8E4M3FNUZ","FLOAT8E5M2","FLOAT8E5M2FNUZ","NodeType","Primitive","Fused","TypeInfoValue","NONE","tensor_type","sequence_type","map_type","__init","getRootAsShape","getSizePrefixedRootAsShape","dim","Dimension","dimLength","startShape","addDim","createDimVector","startDimVector","endShape","createShape","Shape","getRootAsDimension","getSizePrefixedRootAsDimension","DimensionValue","denotation","startDimension","addValue","addDenotation","endDimension","createDimension","getRootAsDimensionValue","getSizePrefixedRootAsDimensionValue","dimType","dimValue","dimParam","startDimensionValue","addDimType","addDimValue","addDimParam","endDimensionValue","createDimensionValue","getRootAsTensorTypeAndShape","getSizePrefixedRootAsTensorTypeAndShape","elemType","shape","startTensorTypeAndShape","addElemType","addShape","endTensorTypeAndShape","createTensorTypeAndShape","TensorTypeAndShape","getRootAsMapType","getSizePrefixedRootAsMapType","keyType","valueType","TypeInfo","startMapType","addKeyType","addValueType","endMapType","createMapType","MapType","getRootAsSequenceType","getSizePrefixedRootAsSequenceType","startSequenceType","endSequenceType","createSequenceType","SequenceType","EdgeEnd","nodeIndex","srcArgIndex","dstArgIndex","createEdgeEnd","getRootAsNodeEdge","getSizePrefixedRootAsNodeEdge","inputEdges","inputEdgesLength","outputEdges","outputEdgesLength","startNodeEdge","addNodeIndex","addInputEdges","startInputEdgesVector","addOutputEdges","startOutputEdgesVector","endNodeEdge","createNodeEdge","NodeEdge","getRootAsNode","getSizePrefixedRootAsNode","docString","sinceVersion","index","executionProviderType","inputs","inputsLength","outputs","outputsLength","attributes","Attribute","attributesLength","inputArgCounts","inputArgCountsLength","inputArgCountsArray","byteOffset","implicitInputs","implicitInputsLength","startNode","addName","addDocString","addDomain","addSinceVersion","addIndex","addOpType","addType","addExecutionProviderType","addInputs","createInputsVector","startInputsVector","addOutputs","createOutputsVector","startOutputsVector","addAttributes","createAttributesVector","startAttributesVector","addInputArgCounts","createInputArgCountsVector","startInputArgCountsVector","addImplicitInputs","createImplicitInputsVector","startImplicitInputsVector","endNode","createNode","Node","getRootAsValueInfo","getSizePrefixedRootAsValueInfo","startValueInfo","endValueInfo","createValueInfo","ValueInfo","getRootAsTypeInfo","getSizePrefixedRootAsTypeInfo","startTypeInfo","endTypeInfo","createTypeInfo","getRootAsOperatorSetId","getSizePrefixedRootAsOperatorSetId","startOperatorSetId","addVersion","endOperatorSetId","createOperatorSetId","OperatorSetId","getRootAsTensor","getSizePrefixedRootAsTensor","dimsLength","rawData","rawDataLength","rawDataArray","stringData","stringDataLength","startTensor","addDims","createDimsVector","startDimsVector","addDataType","addRawData","createRawDataVector","startRawDataVector","addStringData","createStringDataVector","startStringDataVector","endTensor","createTensor","getRootAsSparseTensor","getSizePrefixedRootAsSparseTensor","values","indices","startSparseTensor","addValues","addIndices","endSparseTensor","createSparseTensor","SparseTensor","getRootAsAttribute","getSizePrefixedRootAsAttribute","g","Graph","floats","floatsLength","floatsArray","ints","intsLength","strings","stringsLength","tensors","tensorsLength","graphs","graphsLength","startAttribute","addF","addI","addS","addT","addG","addFloats","createFloatsVector","startFloatsVector","addInts","createIntsVector","startIntsVector","addStrings","createStringsVector","startStringsVector","addTensors","createTensorsVector","startTensorsVector","addGraphs","createGraphsVector","startGraphsVector","endAttribute","createAttribute","getRootAsGraph","getSizePrefixedRootAsGraph","initializers","initializersLength","nodeArgs","nodeArgsLength","nodes","nodesLength","maxNodeIndex","nodeEdges","nodeEdgesLength","sparseInitializers","sparseInitializersLength","startGraph","addInitializers","createInitializersVector","startInitializersVector","addNodeArgs","createNodeArgsVector","startNodeArgsVector","addNodes","createNodesVector","startNodesVector","addMaxNodeIndex","addNodeEdges","createNodeEdgesVector","startNodeEdgesVector","addSparseInitializers","createSparseInitializersVector","startSparseInitializersVector","endGraph","createGraph","getRootAsModel","getSizePrefixedRootAsModel","irVersion","opsetImport","opsetImportLength","producerName","producerVersion","modelVersion","graph","graphDocString","startModel","addIrVersion","addOpsetImport","createOpsetImportVector","startOpsetImportVector","addProducerName","addProducerVersion","addModelVersion","addGraph","addGraphDocString","endModel","createModel","Model","getRootAsKernelCreateInfos","getSizePrefixedRootAsKernelCreateInfos","nodeIndices","nodeIndicesLength","nodeIndicesArray","kernelDefHashes","kernelDefHashesLength","startKernelCreateInfos","addNodeIndices","createNodeIndicesVector","startNodeIndicesVector","addKernelDefHashes","createKernelDefHashesVector","startKernelDefHashesVector","endKernelCreateInfos","createKernelCreateInfos","KernelCreateInfos","getRootAsSubGraphSessionState","getSizePrefixedRootAsSubGraphSessionState","graphId","sessionState","SessionState","startSubGraphSessionState","addGraphId","addSessionState","endSubGraphSessionState","createSubGraphSessionState","SubGraphSessionState","getRootAsSessionState","getSizePrefixedRootAsSessionState","kernels","subGraphSessionStates","subGraphSessionStatesLength","startSessionState","addKernels","addSubGraphSessionStates","createSubGraphSessionStatesVector","startSubGraphSessionStatesVector","endSessionState","createSessionState","getRootAsInferenceSession","getSizePrefixedRootAsInferenceSession","bufferHasIdentifier","ortVersion","model","startInferenceSession","addOrtVersion","addModel","endInferenceSession","finishInferenceSessionBuffer","finishSizePrefixedInferenceSessionBuffer","createInferenceSession","js","Vy","qs","Ys","Js","vn","charAt","te","ar","Ks","encode","slice","Xs","decode","Qs","Wy","Zs","In","_listeners","on","off","emit","au","Hy","iu","tu","writeFloatLE","writeFloatBE","readFloatLE","readFloatBE","round","NaN","eu","ru","nu","ou","writeDoubleLE","writeDoubleBE","readDoubleLE","readDoubleBE","su","module","inquire","moduleName","eval","replace","lu","uu","jo","read","write","cu","jy","fu","du","Xy","pu","vt","Er","Se","lo","hi","Re","zero","zzEncode","zzDecode","sh","zeroHash","isString","toLong","Oe","fromHash","toHash","Xo","N","hu","mu","captureStackTrace","message","asPromise","base64","EventEmitter","float","utf8","pool","LongBits","isNode","global","process","node","window","self","emptyArray","freeze","emptyObject","isInteger","isFinite","isObject","isset","isSet","Buffer","utf8Write","_unused2","_Buffer_from","_Buffer_allocUnsafe","newBuffer","dcodeIO","key2Re","key32Re","key64Re","longToHash","longFromHash","merge","lcFirst","toLowerCase","newError","ProtocolError","oneOfGetter","oneOfSetter","toJSONOptions","longs","enums","json","_configure","allocUnsafe","ei","Jy","xu","X","Ko","Wt","_n","bu","gu","Dr","len","next","val","Yo","uh","head","tail","states","yu","Zo","Qo","ti","Jo","alloc","_push","uint32","sint32","uint64","int64","sint64","bool","fixed32","sfixed32","fixed64","sfixed64","double","fh","string","fork","ldelim","vu","Yy","wu","ce","Tu","Ae","ch","writeBytesBuffer","copy","oi","Zy","Au","ct","ni","ee","Ou","ph","re","pos","buf","Iu","Su","isBuffer","ri","On","_u","_slice","skip","skipType","Lu","Qy","Du","Ge","Eu","Pu","utf8Slice","ku","tx","$u","Lr","ii","rpcImpl","requestDelimited","responseDelimited","rpcCall","setTimeout","Fu","Bu","Service","Nu","rx","Cu","Mu","Gu","Nt","Ru","util","Writer","BufferWriter","Reader","BufferReader","build","rpc","roots","configure","Vu","ox","Uu","sr","ix","zu","nt","$","pt","b","h","default","onnx","Version","AttributeProto","sparseTensors","typeProtos","refAttrName","sparseTensor","tp","TensorProto","GraphProto","TypeProto","SparseTensorProto","encodeDelimited","decodeDelimited","verify","fromObject","toObject","arrays","defaults","getTypeUrl","ValueInfoProto","NodeProto","input","output","attribute","TrainingInfoProto","initializationBinding","updateBinding","initialization","algorithm","StringStringEntryProto","ModelProto","metadataProps","trainingInfo","functions","OperatorSetIdProto","FunctionProto","key","TensorAnnotation","quantParameterTensorNames","tensorName","initializer","sparseInitializer","valueInfo","quantizationAnnotation","floatData","int32Data","int64Data","externalData","doubleData","uint64Data","segment","Segment","DataLocation","DataType","TensorShapeProto","oneofs","tensorType","sequenceType","mapType","optionalType","sparseTensorType","Sequence","Optional","OperatorStatus","attributeProto","ur","kr","TextDecoder","ot","Me","ai","kt","Sn","At","Rt","B","$r","Ue","Ve","ze","Y","rr","We","arraysEqual","preprocessInputShapes","postprocessOutputShape","pop","calcMatMulShape","calcShape","fillIndex","calc","areEqual","bt","isValidBroadcast","getBroadcastDims","unshift","getShapeOfGemmResult","tensorDataTypeFromProto","tensorDataTypeStringToEnum","tensorDimsFromProto","tensorValueTypeFromProto","tensorDimsFromORTFormat","longToNumber","tensorAttributesFromORTFormat","getSizeFromDimensionRange","sizeFromDimension","sizeToDimension","computeStrides","transpose","reverse","indicesToOffset","offsetToIndices","normalizeAxis","normalizeAxes","incrementIndex","calculateReshapedDims","sortBasedOnPerm","padShape","every","validateDimsAndCalcSize","flattenShape","reduce","squeezeShape","unsqueezeShape","fill","splitShape","determineSplit","adjustPoolAttributes","adjustPadsBasedOnAutoPad","adjustPadAndReturnShape","computePoolOutputShape","computeShapeHelper","computeConvOutputShape","hh","Wu","H","mh","ju","ui","si","Hu","getUint8","getInt8","getUint16","getInt16","getFloat32","getInt32","getUint32","getFloat64","qu","dataProvider","asyncDataProvider","cache","dataId","integerData","numberData","strides","_strides","fromProto","DataView","fromData","fromOrtTensor","G","bh","gh","Xu","varyingVertex","Ku","varyingFrag","outputDeclaration","Ju","ut","texture2D","j","li","tryFn","An","toUpperCase","Yu","lr","JSON","stringify","fr","Bt","pe","yh","cr","de","He","Th","wh","vh","Zu","xh","Qu","tl","inputTypes","createPackProgramInfo","session","glContext","_objectSpread","hasMain","textureType","shaderSource","createPackProgramInfoLoader","fi","rl","Oh","Sh","Ih","_h","el","nl","cacheHint","createPackedReshape3DProgramInfo","createPackedReshape3DProgramInfoLoader","ci","ol","encodeAsUint8","tensor","executeProgram","Ph","il","Ah","al","sl","createUnpackProgramInfo","createUnpackProgramInfoLoader","Pn","Br","En","Fr","internalFormat","R32F","RED","channelSize","RGBA32F","RGBA","ALPHA","UNSIGNED_BYTE","Cr","ul","pi","ll","createTextureLayoutFromTextureType","isPacked","reverseWH","breakAxis","calculateTextureWidthAndHeight","computeTextureWH","channels","unpackedShape","reversedWH","Dh","Dn","cl","getProgramInfoUniqueKey","packedTextureDataCache","unpackedTextureDataCache","layoutStrategy","getOrCreateTextureData","programManager","getArtifact","programInfo","createTextureData","setArtifact","runProgram","getTextureData","pack","unpack","createTextureDataFromLayoutBindTensor","textureManager","createTextureFromLayout","createTextureDataFromTexture","reshapeUnpacked","reshapePacked","cast","readTexture","readTextureAsync","setTextureData","isInitializer","isTextureLayoutCached","clearActiveTextures","releaseTexture","isFloat32DownloadSupported","readUint8TextureAsFloat","di","W","It","assign","cacheKey","sort","pl","dl","hl","Lh","$h","ml","batchNormalization","getFloat","getInt","epsilon","momentum","spatial","createBatchNormalizationProgramInfo","Ln","Ht","k","Nr","$n","Te","inputTextureLayouts","outputTextureLayout","context","routineBody","dependencies","addDependency","returnOrderedNodes","createOrderedNodes","dfsTraverse","delete","Bh","body","Fh","Ch","Nh","Rh","Gh","Mh","Uh","Vh","zh","Wh","qh","Hh","qt","jh","bl","gl","yl","xl","Tl","wl","vl","Il","_l","Ol","Sl","Al","Pl","equal","greater","less","pRelu","El","Dl","Kh","Ll","Jh","Yh","$l","kn","kl","createPackedConcatProgramMetadata","createPackedConcatProgramInfo","wt","createPackedConcatProgramInfoLoader","axis","getShiftedChannelsSnippet","Bl","Zh","Qh","tm","Fl","em","rm","nm","Cl","om","Nl","createUnpackedConcatProgramMetadata","createUnpackedConcatProgramInfo","createUnpackedConcatProgramInfoLoader","getFetchDataFromCorrectTextureMethod","im","jt","am","sm","um","lm","fm","cm","pm","dm","hm","mm","bm","gm","ym","xm","mi","bi","Tm","wm","vm","Im","dt","Rl","Gl","Ml","Ul","gi","Vl","zl","_m","Wl","Hl","ql","jl","Xl","Kl","yi","Jl","Yl","Zl","Ql","tf","ef","rf","nf","of","af","sf","xi","createElementwiseProgramInfo","createElementwiseProgramInfoLoader","abs","acos","asin","atan","clip","clipV11","generateClipAttributesFromInputs","cos","elu","alpha","exp","identity","leakyRelu","relu","sigmoid","sin","sqrt","tan","tanh","he","activation","clipMin","clipMax","activationFunction","applyActivation","pr","qe","getString","getFloats","activationCacheKey","Sm","Am","uf","lf","Bn","createUnpackedGroupedConvProgramMetadata","createUnpackedGroupedConvProgramInfo","group","autoPad","dilations","kernelShape","pads","dr","createUnpackedGroupedConvProgramInfoLoader","Pm","Em","ff","cf","createPackedIm2ColProgramInfo","createPackedIm2ColProgramInfoLoader","Lm","wi","Ti","Dm","pf","df","$m","Fn","vi","matMul","Cn","createMatmulProgramMetadata","Fm","Cm","Nm","km","Bm","createPackedMatmulProgramMetadata","createPackedMatmulProgramInfo","et","Dt","createPackedMatmulProgramInfoLoader","hf","mf","conv2DPacked","Rm","Gm","bf","Ii","_i","createIm2ColProgramInfo","createIm2ColProgramInfoLoader","Mm","Um","gf","yf","createDotProductProgramMetadata","createDotProductProgramInfo","createDotProductProgramInfoLoader","Oi","Vm","zm","Wm","Hm","Si","qm","calculateOutputShape","conv","conv2d","conv2DUnpackedPointwise","conv2DUnpacked","getAdjustedConvAttributes","getInts","validateInputs","jm","Xm","Km","xf","Jm","Ym","Zm","Qm","tb","eb","Tf","rb","wf","computeTotalPad","distributePadding","calculateOutputShapeAndPads","convTranspose","convTranspose2d","createConvTransposeProgramMetadata","createUnpackedConvTransposeProgramInfo","outputShape","createUnpackedConvTransposeProgramInfoLoader","convTranspose2DUnpacked","getAdjustedConvTransposeAttributes","outputPadding","vf","je","If","nb","_f","ob","ib","ab","Nn","perm","createTransposeProgramInfo","getAdjustedPerm","getOutputShape","getPermFunctionBody","Of","Sf","sb","Af","depthToSpace","blocksize","mode","Pf","Ef","ub","Df","flatten","Pe","Rr","Lf","$f","lb","fb","cb","pb","kf","gather","createGatherProgramInfo","createGatherProgramInfoLoader","Ai","Bf","Ff","Cf","db","hb","mb","Nf","gemm","parseGemmAttributes","transA","transB","beta","isOptionalC","createGemmProgramInfoLoader","createGemmProgramInfo","variables","Rf","Gf","gb","yb","xb","Tb","Mf","imageScaler","scale","createImageScalerProgramInfo","arrayLength","createImageScalerProgramInfoLoader","Vf","zf","Uf","wb","vb","Ib","_b","Ob","Sb","Wf","instanceNormalization","createMeanAndVarianceProgramInfo","createComputeOutputProgramInfo","createComputeOutputProgramInfoLoader","Ab","jf","Pb","Hf","qf","Eb","Xf","lrn","Db","Pi","Kf","Jf","Yf","Lb","$b","kb","Bb","Fb","Cb","Nb","Rb","Zf","padV2","padV11","generatePadAttributesFromInputs","createPadProgramInfo","getPadFunction","getPadConstant","getPadReflect","getPadEdge","tc","ec","rc","nc","oc","ic","ac","sc","uc","Gb","Qf","lc","Gn","fc","Rn","Mb","cc","averagePool","ceilMode","countIncludePad","createAveragePoolProgramInfo","globalAveragePool","maxPool","storageOrder","createMaxPoolProgramInfo","getAdjustedPoolAttributesAndOutputShape","globalMaxPool","generatePoolingCode","copyArray","Xe","Ee","Ub","Vb","pc","dc","hc","mc","bc","gc","yc","xc","axes","keepDims","createReduceProgramInfo","reduceSum","reduceMean","reduceMax","reduceMin","reduceProd","reduceLogSum","reduceLogSumSquare","Tc","wc","vc","Ei","Ic","_c","Gr","zb","Di","Mn","Li","upsample","parseUpsampleAttributes","opset","isResize","scales","extrapolationValue","coordinateTransformMode","useExtrapolation","needRoiInput","nearestMode","cubicCoefficientA","excludeOutside","useNearest2xOptimization","roiInputIdx","scalesInputIdx","sizesInputIdx","createUpsampleProgramInfo","scalesValidation","$i","ki","Oc","Sc","Wb","Hb","qb","jb","Ac","resize","createPackedResizeProgramInfo","prepareInputs","parseScalesData","parseScalesDataFromOutputSize","Pc","Xb","Ec","Bi","Dc","Lc","$c","Kb","kc","Jb","Yb","Bc","starts","ends","createSliceProgramInfo","sliceV10","generateSliceAttributesFromInputs","some","Fc","Cc","Nc","Rc","Gc","Mc","Uc","Vc","Zb","Qb","tg","zc","Wc","softmax","softmaxV13","computeSoftmax","createComputeMaxProgramInfo","createComputScaleProgramInfo","createSoftMaxProgramInfo","Hc","qc","jc","eg","rg","ng","Xc","numOutputs","getProgramCount","createSplitProgramInfo","Fi","Kc","Jc","og","ig","Yc","squeeze","squeezeV13","Zc","ag","sg","Qc","sum","createSumProgramInfo","ug","lg","ep","tile","createTileProgramInfo","Ci","rp","np","fg","cg","op","unsqueeze","unsqueezeV13","ip","ap","up","sp","exec","params","pg","lp","hr","dg","newShape","keptDims","hg","mg","fp","Un","Ni","maxTextureSize","computeTexture","Vn","cp","super","getFunctions","offsetToCoords","coordsToOffset","toVec","valueFrom","getCommonUtilFuncs","getInputsSamplingSnippets","getOutputSamplingSnippet","getCustomTypes","getPackedOutputSamplingSnippet","getUnpackedOutputSamplingSnippet","getOutputScalarCoords","getOutputPacked1DCoords","getOutputPacked2DCoords","getOutputPacked3DCoords","getOutputPackedNDCoords","getOutputUnpacked1DCoords","getOutputUnpacked2DCoords","getOutputUnpacked3DCoords","getOutputUnpacked4DCoords","getOutputUnpacked5DCoords","getOutputUnpacked6DCoords","getPackedSamplerFromInput","getUnpackedSamplerFromInput","getPackedSamplerAtOutputCoords","getUnpackedSamplerAtOutputCoords","_t","getPackedSamplerScalar","getPackedSampler1D","getPackedSampler2D","getPackedSampler3D","getPackedSamplerND","getUnpackedSamplerScalar","getUnpackedSampler1D","getUnpackedSampler2D","getUnpackedSampler3D","getUnpackedSampler4D","getUnpackedSampler5D","getUnpackedSampler6D","getValueFromSingle","getPackedValueFrom","zn","pp","encodeFloat32","decodeFloat32","encodeUint8","decodeUint8","Wn","dp","setFragColor","getColorAsFloat","Hn","hp","bcastIndex","bcastMatmulIndex","incrementIndices","indexToOffsetSingle","offsetToIndicesSingle","qn","mp","binaryVecFunctions","copyVec","setVecItem","getVecItem","Ri","bp","encoding","fragcolor","vec","shapeUtils","coordinates","jn","gp","libs","glslLibRoutineDependencyGraph","preprocess","getUniforms","getImports","selectGlslLibRoutinesToBeIncluded","Xn","yp","profiler","textureLayoutStrategy","repo","attributesBound","_e$programInfo$name","program","useProgram","_e$programInfo$variab","bindOutput","bindAttributes","attribLocations","bindUniforms","uniformLocations","draw","vertexShader","deleteShader","deleteProgram","compile","getUniformLocations","getAttribLocations","compileShader","VERTEX_SHADER","debug","FRAGMENT_SHADER","createProgram","attachFramebuffer","textureCoord","setVertexAttributes","_o$find","find","bindTexture","uniform1fv","uniform1f","uniform1iv","uniform1i","bindTextureToUniform","getAttribLocation","getUniformLocation","Kn","xp","config","pendingRead","reuseTextures","inUseTextures","idleTextures","textureLookup","toEncoderType","getEncoder","updateTexture","toTextureData","allocateTexture","toTensorData","createAndWaitForFence","deleteTexture","Jn","Tp","textureCacheMode","pack2unpackMap","unpack2packMap","createInferenceHandler","onGraphInitialized","getValues","addInitializer","resolve","impl","bg","Mr","wp","frameBufferBound","itemsToPoll","getExtensions","vertexbuffer","createVertexbuffer","framebuffer","createFramebuffer","queryVitalParameters","createTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","checkError","texSubImage2D","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","viewport","scissor","readPixels","isFramebufferReady","getActiveTexture","getParameter","ACTIVE_TEXTURE","TEXTURE0","getTextureBinding","TEXTURE_BINDING_2D","getFramebufferBinding","FRAMEBUFFER_BINDING","vertexAttribPointer","enableVertexAttribArray","attachShader","linkProgram","createShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","activeTexture","drawArrays","TRIANGLE_STRIP","getError","NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","isRenderFloat32Supported","textureHalfFloatExtension","HALF_FLOAT_OES","maxTextureImageUnits","disposed","deleteFramebuffer","bindBuffer","ARRAY_BUFFER","deleteBuffer","ELEMENT_ARRAY_BUFFER","createDefaultGeometry","createBuffer","bufferData","STATIC_DRAW","isFloatTextureAttachableToFrameBuffer","checkFloatTextureAttachableToFrameBuffer","checkRenderFloat32","checkFloat32Download","isBlendSupported","checkFloat32Blend","MAX_TEXTURE_SIZE","MAX_TEXTURE_IMAGE_UNITS","colorBufferFloatExtension","getExtension","disjointTimerQueryWebgl2Extension","textureFloatExtension","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","enable","BLEND","POINTS","disable","createQuery","beginQuery","TIME_ELAPSED_EXT","endQuery","isTimerResultAvailable","getQueryParameter","QUERY_RESULT_AVAILABLE","GPU_DISJOINT_EXT","getTimerResult","QUERY_RESULT","deleteQuery","createFence","pollFence","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","isFencePassed","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","query","addItemToPoll","pollItems","isDoneFn","resolveFn","Gi","mr","webgl2","vp","yg","_unused3","gg","isContextLost","DEPTH_TEST","STENCIL_TEST","DITHER","POLYGON_OFFSET_FILL","SAMPLE_COVERAGE","SCISSOR_TEST","CULL_FACE","cullFace","BACK","depth","antialias","stencil","preserveDrawingBuffer","premultipliedAlpha","failIfMajorPerformanceCaveat","Ip","Yn","_p","contextId","matmulMaxBatchSize","initialize","createSessionHandler","Mi","Op","Tg","xg","wg","Sp","Ui","Zn","Ap","getNodes","_ops","_starter","_values","getInputIndices","execute","to","getOutputIndices","q","Xt","Ur","Pp","_attributes","getValue","getType","getTensor","getStrings","getTensors","getValueNoCheck","getValueNoCheckFromOnnxFormat","getValueNoCheckFromOrtFormat","zi","Qn","Wi","me","Vi","Ep","_from","_to","executeNode","buildGraph","transformGraph","checkIsAcyclic","_allInputIndices","getInputNames","_allInputNames","_allOutputIndices","getOutputNames","_allOutputNames","_allData","_nodes","buildGraphFromOnnxFormat","buildGraphFromOrtFormat","_e$nodeArgs","_e$nodeArgs2","removeAllIdentityNodes","removeAllDropoutNodes","fuseConvActivationNodes","finalizeGraph","deleteNode","isActivation","_unused4","Dp","vg","eo","Lp","load","loadFromOnnxFormat","loadFromOrtFormat","_opsets","_graph","opsets","ro","$p","_initialized","backendHint","graphInputTypes","graphInputDims","_model","loadModel","sessionHandler","fetch","arrayBuffer","isView","initializeOps","_executionPlan","normalizeAndValidateInputs","createOutput","validateInputTensorDims","validateInputTensorTypes","compareTensorDims","no","kp","Bp","onnxjsBackend","Ig","Hi","Fp","oo","Rp","_g","Cp","Np","Gp","_globalThis$self","qi","Ke","Vr","globalThis","onmessage","in","io","ao","postMessage","epName","so","zr","out","options","uo","sessionId","inputIndices","outputIndices","fo","po","co","Worker","br","Up","Og","ji","Mp","Vp","_globalThis$self2","import","_globalThis$SharedArr","oe","it","be","Z","ae","c","m","importScripts","mountExternalData","startsWith","Ua","unmountExternalData","Memory","initial","maximum","shared","href","currentScript","substr","lastIndexOf","XMLHttpRequest","open","responseType","send","response","x","status","onerror","cmd","I","E","startWorker","handlers","proxy","_len","R","_key","Za","args","wasmMemory","wasmModule","$o","pthread_ptr","Ao","md","aa","bd","start_routine","arg","er","nn","target","tn","Ha","_len2","_key2","alert","_len3","_key3","text","instantiateWasm","Yr","onunhandledrejection","reason","wasmBinary","Kr","we","ie","se","HEAP8","HEAP16","HEAPU8","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","HEAP64","HEAPU64","Lt","Jr","Ye","ue","Ze","De","clearInterval","Mt","RuntimeError","ve","Ot","Jt","wr","credentials","ok","catch","instantiate","hd","yd","ca","ha","ma","ya","xa","Ta","wa","va","Ia","_a","Oa","Sa","U","Aa","Pa","_","xd","Td","wd","vd","Id","_d","Od","Sd","Ad","K","Pd","La","$a","Ed","Dd","Ld","$d","kd","Bd","Fd","ka","Cd","Nd","Rd","Gd","Md","Q","Ca","Na","So","Ra","Ga","Ma","Oo","Wa","zd","ea","Ir","_unused5","wasmOffsetConverter","Io","_o","terminate","ra","Ie","ua","sa","Le","fe","vr","st","Fo","Bo","at","Pt","qa","na","oa","ia","ko","targetThread","transferList","thread","loaded","threadId","filename","lineno","URL","workerData","la","Zr","shift","Xa","Qr","gd","fa","pa","da","ba","ga","_r","Atomics","store","ja","Po","Wd","getUTCSeconds","getUTCMinutes","getUTCHours","getUTCDate","getUTCMonth","getUTCFullYear","getUTCDay","getTime","UTC","Qe","Ea","Da","getSeconds","getMinutes","getHours","getDate","getMonth","getFullYear","getDay","getTimezoneOffset","setTime","getYear","$t","toLocaleTimeString","hour12","timeZoneName","Eo","timeOrigin","navigator","hardwareConcurrency","grow","_unused6","en","tr","Ba","Do","Lo","Fa","USER","LOGNAME","PATH","PWD","HOME","LANG","languages","Ud","Ft","Va","za","Vd","ft","$e","setDate","setMonth","setFullYear","Ya","Qa","Ja","%n","%t","%%","numThreads","all","emscripten_main_runtime_thread_id","locateFile","instantiateStreaming","instance","_OrtInit","_OrtGetLastError","_OrtCreateSessionOptions","_OrtAppendExecutionProvider","_OrtAddFreeDimensionOverride","_OrtAddSessionConfigEntry","_OrtReleaseSessionOptions","_OrtCreateSession","_OrtReleaseSession","_OrtGetInputOutputCount","_OrtGetInputName","_OrtGetOutputName","_OrtFree","_OrtCreateTensor","_OrtGetTensorData","_OrtReleaseTensor","_OrtCreateRunOptions","_OrtAddRunConfigEntry","_OrtReleaseRunOptions","_OrtCreateBinding","ta","_OrtBindInput","_OrtBindOutput","_OrtClearBoundOutputs","_OrtReleaseBinding","_OrtRunWithBinding","_OrtRun","_OrtEndProfiling","_malloc","_free","rn","Ka","calledRun","___start_em_js","___stop_em_js","stackSave","stackRestore","stackAlloc","UTF8ToString","stringToUTF8","lengthBytesUTF8","Sg","Ag","Pg","zp","Wp","Eg","Hp","_import$meta$url","_document$currentScri","_self$location","origin","isSameOrigin","_unused7","blob","createObjectURL","sn","Xi","Ki","ho","qp","Dg","Lg","xt","isMultiThreadSupported","MessageChannel","port1","validate","_unused8","isSimdSupported","_unused9","_s$href","_u$href","initTimeout","crossOriginIsolated","wasmPaths","mjs","revokeObjectURL","race","getInstance","Tt","Wr","ht","mo","allocWasmString","iterateExtraOptions","entries","_ref","jp","Xp","logSeverityLevel","logVerbosityLevel","tag","extra","WeakSet","$g","kg","Bg","Fg","Kp","Jp","use_ort_model_bytes_directly","enableMemPattern","setExecutionProviders","deviceType","preferredLayout","_r$graphOptimizationL","_r$executionMode","_r$logSeverityLevel","_r$logVerbosityLevel","graphOptimizationLevel","executionMode","logId","optimizedModelFilePath","enableCpuMemArena","enableProfiling","enableGraphCapture","freeDimensionOverrides","Hr","Yp","qr","Zp","Qp","bo","go","td","Ji","calculateTensorSizeInBytes","jr","Yi","headers","getReader","done","Blob","Cg","yr","Ng","ed","initOrt","path","_e$executionProviders","shouldTransferToMLTensor","currentContext","gpuDevice","powerPreference","createContext","jsepRegisterMLContext","_r$unmountExternalDat","_e$jsepOnReleaseSessi","handle","jsepOnReleaseSession","jsepRegisterBuffer","jsepRegisterMLTensor","_s$jsepOnRunStart","jsepOnRunStart","outputPreferredLocations","jsepGetBuffer","jsepCreateDownloader","jsepEnsureTensor","jsepCreateMLTensorDownloader","jsepReleaseTensorId","Je","Kt","Xr","xo","To","yo","Zi","Qi","xr","Tr","Gg","rd","nd","od","id","ad","sd","ud","isProxy","enqueueCallbacks","ensureWorker","_Kt","_ref2","preferredOutputLocation","ld","Mg","wo","fd","encodeTensorMetadata","fetchModelAndCopyToWasmMemory","_s$d","pd","OnnxruntimeWebAssemblyBackend","vo","initializeFlags","cd","wasmBackend","Ug","dd","simd","Co","cpus","Ds","mO"],"sourceRoot":""}